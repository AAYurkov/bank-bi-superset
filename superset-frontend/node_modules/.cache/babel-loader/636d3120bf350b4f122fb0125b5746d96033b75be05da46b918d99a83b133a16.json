{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { extendedDayjs } from 'src/utils/dates';\nimport { parseDttmToDate, customTimeRangeDecode, computeCustomDateTime, fetchTimeRange } from '@superset-ui/core';\nimport { DatePicker } from 'src/components/DatePicker';\nimport { useSelector } from 'react-redux';\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { DEFAULT_DATE_PATTERN, INVALID_DATE } from '@superset-ui/chart-controls';import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst DAYJS_FORMAT = 'YYYY-MM-DD';\nconst isTimeRangeEqual = (left, right) => _isEqual(left, right);\nconst isStartDateEqual = (left, right) => _isEqual(left, right);\nexport default function TimeOffsetControls({ onChange, ...props }) {\n  const [startDate, setStartDate] = useState('');\n  const [formatedDate, setFormatedDate] = useState(undefined);\n  const [customStartDateInFilter, setCustomStartDateInFilter] = useState(undefined);\n  const [formatedFilterDate, setFormatedFilterDate] = useState(undefined);\n  const [savedStartDate, setSavedStartDate] = useState(null);\n  const [isDateSelected, setIsDateSelected] = useState(true);\n  const currentTimeRangeFilters = useSelector((state) => state.explore.form_data.adhoc_filters.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE'), isTimeRangeEqual);\n  const currentStartDate = useSelector((state) => state.explore.form_data.start_date_offset, isStartDateEqual);\n  useEffect(() => {\n    if (savedStartDate !== currentStartDate) {\n      setSavedStartDate(currentStartDate);\n      if (currentStartDate !== INVALID_DATE) {\n        onChange(extendedDayjs(currentStartDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      } else\n      {\n        setIsDateSelected(false);\n      }\n    }\n  }, [currentStartDate]);\n  const previousCustomFilter = useSelector((state) => {var _state$explore$form_d;return (_state$explore$form_d = state.explore.form_data.adhoc_custom) == null ? void 0 : _state$explore$form_d.filter((adhoc_filter) => adhoc_filter.operator === 'TEMPORAL_RANGE');}, isTimeRangeEqual);\n  // let's use useCallback to compute the custom start date\n  const customTimeRange = useCallback((date) => {\n    const customRange = customTimeRangeDecode(date);\n    if (customRange.matchedFlag) {var _customStartDate;\n      const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue } = {\n        ...customRange.customRange\n      };\n      let customStartDate = null;\n      if (sinceMode !== 'relative') {\n        if (sinceMode === 'specific') {\n          customStartDate = new Date(sinceDatetime);\n        } else\n        {\n          customStartDate = parseDttmToDate(sinceDatetime, false, true);\n        }\n      } else\n      {\n        customStartDate = computeCustomDateTime(sinceDatetime, sinceGrain, sinceGrainValue);\n      }\n      (_customStartDate = customStartDate) == null ? void 0 : _customStartDate.setHours(0, 0, 0, 0);\n      setCustomStartDateInFilter(extendedDayjs(customStartDate));\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n    }\n  }, [setCustomStartDateInFilter]);\n  useEffect(() => {\n    if (!_isEmpty(currentTimeRangeFilters)) {var _currentTimeRangeFilt, _currentTimeRangeFilt2;\n      fetchTimeRange((_currentTimeRangeFilt = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt.comparator, (_currentTimeRangeFilt2 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt2.subject).then((res) => {var _res$value;\n        const dates = res == null ? void 0 : (_res$value = res.value) == null ? void 0 : _res$value.match(DEFAULT_DATE_PATTERN);\n        const [startDate, endDate] = dates != null ? dates : [];\n        customTimeRange(`${startDate} : ${endDate}`);\n        setFormatedFilterDate(extendedDayjs(parseDttmToDate(startDate)));\n      });\n    } else\n    {\n      setCustomStartDateInFilter(undefined);\n      setFormatedFilterDate(extendedDayjs(parseDttmToDate('')));\n    }\n  }, [currentTimeRangeFilters, customTimeRange]);\n  useEffect(() => {\n    if (!savedStartDate && (previousCustomFilter || customStartDateInFilter)) {var _previousCustomFilter;\n      let date = '';\n      if (_isEmpty(previousCustomFilter)) {var _currentTimeRangeFilt3;\n        date = (_currentTimeRangeFilt3 = currentTimeRangeFilters[0]) == null ? void 0 : _currentTimeRangeFilt3.comparator.split(' : ')[0];\n      } else\n      if (((_previousCustomFilter = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter.comparator.split(' : ')[0]) !== 'No filter') {var _previousCustomFilter2;\n        date = (_previousCustomFilter2 = previousCustomFilter[0]) == null ? void 0 : _previousCustomFilter2.comparator.split(' : ')[0];\n      }\n      if (customStartDateInFilter) {\n        setStartDate(customStartDateInFilter.toString());\n        setFormatedDate(extendedDayjs(customStartDateInFilter));\n      } else\n      if (date) {\n        setStartDate(date);\n        setFormatedDate(extendedDayjs(parseDttmToDate(date)));\n      }\n    } else\n    if (savedStartDate) {\n      if (savedStartDate !== INVALID_DATE) {\n        setStartDate(savedStartDate);\n        setFormatedDate(extendedDayjs(parseDttmToDate(savedStartDate)));\n      }\n    }\n  }, [previousCustomFilter, savedStartDate, customStartDateInFilter]);\n  useEffect(() => {\n    // When switching offsets from inherit and the previous custom is no longer valid\n    if (customStartDateInFilter) {\n      if (formatedDate && formatedDate > customStartDateInFilter) {\n        const resetDate = extendedDayjs.\n        utc(customStartDateInFilter).\n        subtract(1, 'day');\n        setStartDate(resetDate.toString());\n        setFormatedDate(resetDate);\n        onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      }\n    }\n    if (formatedDate &&\n    formatedFilterDate &&\n    formatedDate > formatedFilterDate) {\n      const resetDate = extendedDayjs.\n      utc(formatedFilterDate).\n      subtract(1, 'day');\n      setStartDate(resetDate.toString());\n      setFormatedDate(resetDate);\n      onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n      setIsDateSelected(true);\n    }\n  }, [formatedFilterDate, formatedDate, customStartDateInFilter]);\n  const disabledDate = (current) => {\n    if (!customStartDateInFilter) {\n      return formatedFilterDate ?\n      current && current > formatedFilterDate :\n      false;\n    }\n    return current && current > extendedDayjs(customStartDateInFilter);\n  };\n  return startDate || formatedDate ? _jsxs(\"div\", { children: [\n    _jsx(ControlHeader, { ...props }),\n    _jsx(DatePicker, { onChange: (datetime) => onChange(datetime ? datetime.format(DAYJS_FORMAT) : ''), defaultPickerValue: startDate ? extendedDayjs(formatedDate).subtract(1, 'day') : undefined, disabledDate: disabledDate, defaultValue: extendedDayjs(formatedDate), value: isDateSelected ? extendedDayjs(formatedDate) : null })] }\n  ) : null;\n}__signature__(TimeOffsetControls, \"useState{[startDate, setStartDate]('')}\\nuseState{[formatedDate, setFormatedDate](undefined)}\\nuseState{[customStartDateInFilter, setCustomStartDateInFilter](undefined)}\\nuseState{[formatedFilterDate, setFormatedFilterDate](undefined)}\\nuseState{[savedStartDate, setSavedStartDate](null)}\\nuseState{[isDateSelected, setIsDateSelected](true)}\\nuseSelector{currentTimeRangeFilters}\\nuseSelector{currentStartDate}\\nuseEffect{}\\nuseSelector{previousCustomFilter}\\nuseCallback{customTimeRange}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\", () => [useSelector, useSelector, useSelector]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DAYJS_FORMAT, \"DAYJS_FORMAT\", \"/Users/aryurkov/superset/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(isTimeRangeEqual, \"isTimeRangeEqual\", \"/Users/aryurkov/superset/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(isStartDateEqual, \"isStartDateEqual\", \"/Users/aryurkov/superset/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");reactHotLoader.register(TimeOffsetControls, \"TimeOffsetControls\", \"/Users/aryurkov/superset/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useCallback","useEffect","useState","extendedDayjs","parseDttmToDate","customTimeRangeDecode","computeCustomDateTime","fetchTimeRange","DatePicker","useSelector","ControlHeader","DEFAULT_DATE_PATTERN","INVALID_DATE","jsx","_jsx","jsxs","_jsxs","DAYJS_FORMAT","isTimeRangeEqual","left","right","_isEqual","isStartDateEqual","TimeOffsetControls","onChange","props","startDate","setStartDate","formatedDate","setFormatedDate","undefined","customStartDateInFilter","setCustomStartDateInFilter","formatedFilterDate","setFormatedFilterDate","savedStartDate","setSavedStartDate","isDateSelected","setIsDateSelected","currentTimeRangeFilters","state","explore","form_data","adhoc_filters","filter","adhoc_filter","operator","currentStartDate","start_date_offset","format","previousCustomFilter","_state$explore$form_d","adhoc_custom","customTimeRange","date","customRange","matchedFlag","_customStartDate","sinceDatetime","sinceMode","sinceGrain","sinceGrainValue","customStartDate","Date","setHours","_isEmpty","_currentTimeRangeFilt","_currentTimeRangeFilt2","comparator","subject","then","res","_res$value","dates","value","match","endDate","_previousCustomFilter","_currentTimeRangeFilt3","split","_previousCustomFilter2","toString","resetDate","utc","subtract","disabledDate","current","children","datetime","defaultPickerValue","defaultValue","__signature__","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/explore/components/controls/TimeOffsetControl.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ReactNode, useCallback, useEffect, useState } from 'react';\nimport { isEmpty, isEqual } from 'lodash';\nimport { extendedDayjs } from 'src/utils/dates';\nimport {\n  parseDttmToDate,\n  BinaryAdhocFilter,\n  SimpleAdhocFilter,\n  customTimeRangeDecode,\n  computeCustomDateTime,\n  fetchTimeRange,\n} from '@superset-ui/core';\nimport { DatePicker } from 'src/components/DatePicker';\nimport { RangePickerProps } from 'antd-v5/es/date-picker';\nimport { useSelector } from 'react-redux';\n\nimport ControlHeader from 'src/explore/components/ControlHeader';\nimport { RootState } from 'src/views/store';\nimport {\n  DEFAULT_DATE_PATTERN,\n  INVALID_DATE,\n} from '@superset-ui/chart-controls';\nimport { Dayjs } from 'dayjs';\n\nexport interface TimeOffsetControlsProps {\n  label?: ReactNode;\n  startDate?: string;\n  description?: string;\n  hovered?: boolean;\n  value?: Dayjs;\n  onChange: (datetime: string) => void;\n}\nconst DAYJS_FORMAT = 'YYYY-MM-DD';\n\nconst isTimeRangeEqual = (\n  left: BinaryAdhocFilter[],\n  right: BinaryAdhocFilter[],\n) => isEqual(left, right);\n\nconst isStartDateEqual = (left: string, right: string) => isEqual(left, right);\n\nexport default function TimeOffsetControls({\n  onChange,\n  ...props\n}: TimeOffsetControlsProps) {\n  const [startDate, setStartDate] = useState<string>('');\n  const [formatedDate, setFormatedDate] = useState<Dayjs | undefined>(\n    undefined,\n  );\n  const [customStartDateInFilter, setCustomStartDateInFilter] = useState<\n    Dayjs | undefined\n  >(undefined);\n  const [formatedFilterDate, setFormatedFilterDate] = useState<\n    Dayjs | undefined\n  >(undefined);\n  const [savedStartDate, setSavedStartDate] = useState<string | null>(null);\n  const [isDateSelected, setIsDateSelected] = useState<boolean>(true);\n\n  const currentTimeRangeFilters = useSelector<RootState, BinaryAdhocFilter[]>(\n    state =>\n      state.explore.form_data.adhoc_filters.filter(\n        (adhoc_filter: SimpleAdhocFilter) =>\n          adhoc_filter.operator === 'TEMPORAL_RANGE',\n      ),\n    isTimeRangeEqual,\n  );\n\n  const currentStartDate = useSelector<RootState, string>(\n    state => state.explore.form_data.start_date_offset,\n    isStartDateEqual,\n  );\n\n  useEffect(() => {\n    if (savedStartDate !== currentStartDate) {\n      setSavedStartDate(currentStartDate);\n      if (currentStartDate !== INVALID_DATE) {\n        onChange(extendedDayjs(currentStartDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      } else {\n        setIsDateSelected(false);\n      }\n    }\n  }, [currentStartDate]);\n\n  const previousCustomFilter = useSelector<RootState, BinaryAdhocFilter[]>(\n    state =>\n      state.explore.form_data.adhoc_custom?.filter(\n        (adhoc_filter: SimpleAdhocFilter) =>\n          adhoc_filter.operator === 'TEMPORAL_RANGE',\n      ),\n    isTimeRangeEqual,\n  );\n\n  // let's use useCallback to compute the custom start date\n  const customTimeRange = useCallback(\n    (date: string) => {\n      const customRange = customTimeRangeDecode(date);\n      if (customRange.matchedFlag) {\n        const { sinceDatetime, sinceMode, sinceGrain, sinceGrainValue } = {\n          ...customRange.customRange,\n        };\n        let customStartDate: Date | null = null;\n        if (sinceMode !== 'relative') {\n          if (sinceMode === 'specific') {\n            customStartDate = new Date(sinceDatetime);\n          } else {\n            customStartDate = parseDttmToDate(sinceDatetime, false, true);\n          }\n        } else {\n          customStartDate = computeCustomDateTime(\n            sinceDatetime,\n            sinceGrain,\n            sinceGrainValue,\n          );\n        }\n        customStartDate?.setHours(0, 0, 0, 0);\n        setCustomStartDateInFilter(extendedDayjs(customStartDate));\n      } else {\n        setCustomStartDateInFilter(undefined);\n      }\n    },\n    [setCustomStartDateInFilter],\n  );\n\n  useEffect(() => {\n    if (!isEmpty(currentTimeRangeFilters)) {\n      fetchTimeRange(\n        currentTimeRangeFilters[0]?.comparator,\n        currentTimeRangeFilters[0]?.subject,\n      ).then(res => {\n        const dates = res?.value?.match(DEFAULT_DATE_PATTERN);\n        const [startDate, endDate] = dates ?? [];\n        customTimeRange(`${startDate} : ${endDate}`);\n        setFormatedFilterDate(extendedDayjs(parseDttmToDate(startDate)));\n      });\n    } else {\n      setCustomStartDateInFilter(undefined);\n      setFormatedFilterDate(extendedDayjs(parseDttmToDate('')));\n    }\n  }, [currentTimeRangeFilters, customTimeRange]);\n\n  useEffect(() => {\n    if (!savedStartDate && (previousCustomFilter || customStartDateInFilter)) {\n      let date = '';\n      if (isEmpty(previousCustomFilter)) {\n        date = currentTimeRangeFilters[0]?.comparator.split(' : ')[0];\n      } else if (\n        previousCustomFilter[0]?.comparator.split(' : ')[0] !== 'No filter'\n      ) {\n        date = previousCustomFilter[0]?.comparator.split(' : ')[0];\n      }\n      if (customStartDateInFilter) {\n        setStartDate(customStartDateInFilter.toString());\n        setFormatedDate(extendedDayjs(customStartDateInFilter));\n      } else if (date) {\n        setStartDate(date);\n        setFormatedDate(extendedDayjs(parseDttmToDate(date)));\n      }\n    } else if (savedStartDate) {\n      if (savedStartDate !== INVALID_DATE) {\n        setStartDate(savedStartDate);\n        setFormatedDate(extendedDayjs(parseDttmToDate(savedStartDate)));\n      }\n    }\n  }, [previousCustomFilter, savedStartDate, customStartDateInFilter]);\n\n  useEffect(() => {\n    // When switching offsets from inherit and the previous custom is no longer valid\n    if (customStartDateInFilter) {\n      if (formatedDate && formatedDate > customStartDateInFilter) {\n        const resetDate = extendedDayjs\n          .utc(customStartDateInFilter)\n          .subtract(1, 'day');\n        setStartDate(resetDate.toString());\n        setFormatedDate(resetDate);\n        onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n        setIsDateSelected(true);\n      }\n    }\n    if (\n      formatedDate &&\n      formatedFilterDate &&\n      formatedDate > formatedFilterDate\n    ) {\n      const resetDate = extendedDayjs\n        .utc(formatedFilterDate)\n        .subtract(1, 'day');\n      setStartDate(resetDate.toString());\n      setFormatedDate(resetDate);\n      onChange(extendedDayjs.utc(resetDate).format(DAYJS_FORMAT));\n      setIsDateSelected(true);\n    }\n  }, [formatedFilterDate, formatedDate, customStartDateInFilter]);\n\n  const disabledDate: RangePickerProps['disabledDate'] = current => {\n    if (!customStartDateInFilter) {\n      return formatedFilterDate\n        ? current && current > formatedFilterDate\n        : false;\n    }\n    return current && current > extendedDayjs(customStartDateInFilter);\n  };\n\n  return startDate || formatedDate ? (\n    <div>\n      <ControlHeader {...props} />\n      <DatePicker\n        onChange={(datetime: Dayjs) =>\n          onChange(datetime ? datetime.format(DAYJS_FORMAT) : '')\n        }\n        defaultPickerValue={\n          startDate ? extendedDayjs(formatedDate).subtract(1, 'day') : undefined\n        }\n        disabledDate={disabledDate}\n        defaultValue={extendedDayjs(formatedDate)}\n        value={isDateSelected ? extendedDayjs(formatedDate) : null}\n      />\n    </div>\n  ) : null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}