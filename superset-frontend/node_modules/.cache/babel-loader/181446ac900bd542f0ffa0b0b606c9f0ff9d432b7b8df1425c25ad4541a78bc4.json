{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { buildQueryContext, ensureIsArray, getMetricLabel, isPhysicalColumn, QueryMode, removeDuplicates } from '@superset-ui/core';\nimport { isTimeComparison, timeCompareOperator } from '@superset-ui/chart-controls';\n\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData == null ? void 0 : formData.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\nconst buildQuery = (formData, options) => {\n  const { percent_metrics: percentMetrics, order_desc: orderDesc = false, extra_form_data } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla = (extra_form_data == null ? void 0 : extra_form_data.time_grain_sqla) || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false\n    };\n  }\n  const addComparisonPercentMetrics = (metrics, suffixes) => metrics.reduce((acc, metric) => {\n    const newMetrics = suffixes.map((suffix) => `${metric}__${suffix}`);\n    return acc.concat([metric, ...newMetrics]);\n  }, []);\n  return buildQueryContext(formDataCopy, (baseQueryObject) => {var _options$ownState, _options$extras, _options$extras$cache, _options$extras2, _options$extras2$cach, _options$hooks2, _metrics2, _formData$extra_form_;\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    const { extras = {} } = baseQueryObject;\n    let postProcessing = [];\n    const nonCustomNorInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift !== 'custom' && shift !== 'inherit');\n    const customOrInheritShifts = ensureIsArray(formData.time_compare).filter((shift) => shift === 'custom' || shift === 'inherit');\n    let timeOffsets = [];\n    // Shifts for non-custom or non inherit time comparison\n    if (isTimeComparison(formData, baseQueryObject) &&\n    !_isEmpty(nonCustomNorInheritShifts)) {\n      timeOffsets = nonCustomNorInheritShifts;\n    }\n    // Shifts for custom or inherit time comparison\n    if (isTimeComparison(formData, baseQueryObject) &&\n    !_isEmpty(customOrInheritShifts)) {\n      if (customOrInheritShifts.includes('custom')) {\n        timeOffsets = timeOffsets.concat([formData.start_date_offset]);\n      }\n      if (customOrInheritShifts.includes('inherit')) {\n        timeOffsets = timeOffsets.concat(['inherit']);\n      }\n    }\n    let temporalColumnAdded = false;\n    let temporalColumn = null;\n    if (queryMode === QueryMode.Aggregate) {var _metrics;\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else\n      if (((_metrics = metrics) == null ? void 0 : _metrics.length) > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricsLabelsWithTimeComparison = isTimeComparison(formData, baseQueryObject) ?\n        addComparisonPercentMetrics(percentMetrics.map(getMetricLabel), timeOffsets) :\n        percentMetrics.map(getMetricLabel);\n        const percentMetricLabels = removeDuplicates(percentMetricsLabelsWithTimeComparison);\n        metrics = removeDuplicates(metrics.concat(percentMetrics), getMetricLabel);\n        postProcessing = [\n        {\n          operation: 'contribution',\n          options: {\n            columns: percentMetricLabels,\n            rename_columns: percentMetricLabels.map((x) => `%${x}`)\n          }\n        }];\n\n      }\n      // Add the operator for the time comparison if some is selected\n      if (!_isEmpty(timeOffsets)) {\n        postProcessing.push(timeCompareOperator(formData, baseQueryObject));\n      }\n      const temporalColumnsLookup = formData == null ? void 0 : formData.temporal_columns_lookup;\n      // Filter out the column if needed and prepare the temporal column object\n      columns = columns.filter((col) => {\n        const shouldBeAdded = isPhysicalColumn(col) &&\n        time_grain_sqla && (\n        temporalColumnsLookup == null ? void 0 : temporalColumnsLookup[col]);\n        if (shouldBeAdded && !temporalColumnAdded) {\n          temporalColumn = {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL'\n          };\n          temporalColumnAdded = true;\n          return false; // Do not include this in the output; it's added separately\n        }\n        return true;\n      });\n      // So we ensure the temporal column is added first\n      if (temporalColumn) {\n        columns = [temporalColumn, ...columns];\n      }\n    }\n    const moreProps = {};\n    const ownState = (_options$ownState = options == null ? void 0 : options.ownState) != null ? _options$ownState : {};\n    if (formDataCopy.server_pagination) {var _ownState$pageSize, _ownState$currentPage, _ownState$pageSize2;\n      moreProps.row_limit = (_ownState$pageSize =\n      ownState.pageSize) != null ? _ownState$pageSize : formDataCopy.server_page_length;\n      moreProps.row_offset =\n      ((_ownState$currentPage = ownState.currentPage) != null ? _ownState$currentPage : 0) * ((_ownState$pageSize2 = ownState.pageSize) != null ? _ownState$pageSize2 : 0);\n    }\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      extras,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      time_offsets: timeOffsets,\n      ...moreProps\n    };\n    if (formData.server_pagination &&\n    options != null && (_options$extras = options.extras) != null && (_options$extras$cache = _options$extras.cachedChanges) != null && _options$extras$cache[formData.slice_id] &&\n    JSON.stringify(options == null ? void 0 : (_options$extras2 = options.extras) == null ? void 0 : (_options$extras2$cach = _options$extras2.cachedChanges) == null ? void 0 : _options$extras2$cach[formData.slice_id]) !==\n    JSON.stringify(queryObject.filters)) {var _options$hooks, _queryObject$row_limi;\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(options == null ? void 0 : (_options$hooks = options.hooks) == null ? void 0 : _options$hooks.setDataMask, 0, (_queryObject$row_limi = queryObject.row_limit) != null ? _queryObject$row_limi : 0);\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options == null ? void 0 : (_options$hooks2 = options.hooks) == null ? void 0 : _options$hooks2.setCachedChanges({\n      [formData.slice_id]: queryObject.filters\n    });\n    const extraQueries = [];\n    if ((_metrics2 = metrics) != null && _metrics2.length &&\n    formData.show_totals &&\n    queryMode === QueryMode.Aggregate) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined,\n        orderby: undefined // because this query will be used for get total aggregation.\n      });\n    }\n    const interactiveGroupBy = (_formData$extra_form_ = formData.extra_form_data) == null ? void 0 : _formData$extra_form_.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n      ...new Set([...queryObject.columns, ...interactiveGroupBy])];\n\n    }\n    if (formData.server_pagination) {\n      return [\n      { ...queryObject },\n      {\n        ...queryObject,\n        time_offsets: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        is_rowcount: true\n      },\n      ...extraQueries];\n\n    }\n    return [queryObject, ...extraQueries];\n  });\n};\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = () => {\n  let cachedChanges = {};\n  const setCachedChanges = (newChanges) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n  return (formData, options) => {var _options$ownState2;return buildQuery({ ...formData }, {\n      extras: { cachedChanges },\n      ownState: (_options$ownState2 = options == null ? void 0 : options.ownState) != null ? _options$ownState2 : {},\n      hooks: {\n        ...(options == null ? void 0 : options.hooks),\n        setDataMask: () => {},\n        setCachedChanges\n      }\n    });};\n};const _default =\ncachedBuildQuery();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getQueryMode, \"getQueryMode\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(buildQuery, \"buildQuery\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(cachedBuildQuery, \"cachedBuildQuery\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");reactHotLoader.register(_default, \"default\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["buildQueryContext","ensureIsArray","getMetricLabel","isPhysicalColumn","QueryMode","removeDuplicates","isTimeComparison","timeCompareOperator","updateExternalFormData","getQueryMode","formData","query_mode","mode","Aggregate","Raw","rawColumns","all_columns","hasRawColumns","length","buildQuery","options","percent_metrics","percentMetrics","order_desc","orderDesc","extra_form_data","queryMode","sortByMetric","timeseries_limit_metric","time_grain_sqla","formDataCopy","include_time","addComparisonPercentMetrics","metrics","suffixes","reduce","acc","metric","newMetrics","map","suffix","concat","baseQueryObject","_options$ownState","_options$extras","_options$extras$cache","_options$extras2","_options$extras2$cach","_options$hooks2","_metrics2","_formData$extra_form_","orderby","columns","extras","postProcessing","nonCustomNorInheritShifts","time_compare","filter","shift","customOrInheritShifts","timeOffsets","_isEmpty","includes","start_date_offset","temporalColumnAdded","temporalColumn","_metrics","percentMetricsLabelsWithTimeComparison","percentMetricLabels","operation","rename_columns","x","push","temporalColumnsLookup","temporal_columns_lookup","col","shouldBeAdded","timeGrain","columnType","sqlExpression","label","expressionType","moreProps","ownState","server_pagination","_ownState$pageSize","_ownState$currentPage","_ownState$pageSize2","row_limit","pageSize","server_page_length","row_offset","currentPage","queryObject","post_processing","time_offsets","cachedChanges","slice_id","JSON","stringify","filters","_options$hooks","_queryObject$row_limi","hooks","setDataMask","setCachedChanges","extraQueries","show_totals","undefined","interactiveGroupBy","interactive_groupby","Set","is_rowcount","cachedBuildQuery","newChanges","_options$ownState2","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-table/src/buildQuery.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AdhocColumn,\n  buildQueryContext,\n  ensureIsArray,\n  getMetricLabel,\n  isPhysicalColumn,\n  QueryMode,\n  QueryObject,\n  removeDuplicates,\n} from '@superset-ui/core';\nimport { PostProcessingRule } from '@superset-ui/core/src/query/types/PostProcessing';\nimport { BuildQuery } from '@superset-ui/core/src/chart/registries/ChartBuildQueryRegistrySingleton';\nimport {\n  isTimeComparison,\n  timeCompareOperator,\n} from '@superset-ui/chart-controls';\nimport { isEmpty } from 'lodash';\nimport { TableChartFormData } from './types';\nimport { updateExternalFormData } from './DataTable/utils/externalAPIs';\n\n/**\n * Infer query mode from form data. If `all_columns` is set, then raw records mode,\n * otherwise defaults to aggregation mode.\n *\n * The same logic is used in `controlPanel` with control values as well.\n */\nexport function getQueryMode(formData: TableChartFormData) {\n  const { query_mode: mode } = formData;\n  if (mode === QueryMode.Aggregate || mode === QueryMode.Raw) {\n    return mode;\n  }\n  const rawColumns = formData?.all_columns;\n  const hasRawColumns = rawColumns && rawColumns.length > 0;\n  return hasRawColumns ? QueryMode.Raw : QueryMode.Aggregate;\n}\n\nconst buildQuery: BuildQuery<TableChartFormData> = (\n  formData: TableChartFormData,\n  options,\n) => {\n  const {\n    percent_metrics: percentMetrics,\n    order_desc: orderDesc = false,\n    extra_form_data,\n  } = formData;\n  const queryMode = getQueryMode(formData);\n  const sortByMetric = ensureIsArray(formData.timeseries_limit_metric)[0];\n  const time_grain_sqla =\n    extra_form_data?.time_grain_sqla || formData.time_grain_sqla;\n  let formDataCopy = formData;\n  // never include time in raw records mode\n  if (queryMode === QueryMode.Raw) {\n    formDataCopy = {\n      ...formData,\n      include_time: false,\n    };\n  }\n\n  const addComparisonPercentMetrics = (metrics: string[], suffixes: string[]) =>\n    metrics.reduce<string[]>((acc, metric) => {\n      const newMetrics = suffixes.map(suffix => `${metric}__${suffix}`);\n      return acc.concat([metric, ...newMetrics]);\n    }, []);\n\n  return buildQueryContext(formDataCopy, baseQueryObject => {\n    let { metrics, orderby = [], columns = [] } = baseQueryObject;\n    const { extras = {} } = baseQueryObject;\n    let postProcessing: PostProcessingRule[] = [];\n    const nonCustomNorInheritShifts = ensureIsArray(\n      formData.time_compare,\n    ).filter((shift: string) => shift !== 'custom' && shift !== 'inherit');\n    const customOrInheritShifts = ensureIsArray(formData.time_compare).filter(\n      (shift: string) => shift === 'custom' || shift === 'inherit',\n    );\n\n    let timeOffsets: string[] = [];\n\n    // Shifts for non-custom or non inherit time comparison\n    if (\n      isTimeComparison(formData, baseQueryObject) &&\n      !isEmpty(nonCustomNorInheritShifts)\n    ) {\n      timeOffsets = nonCustomNorInheritShifts;\n    }\n\n    // Shifts for custom or inherit time comparison\n    if (\n      isTimeComparison(formData, baseQueryObject) &&\n      !isEmpty(customOrInheritShifts)\n    ) {\n      if (customOrInheritShifts.includes('custom')) {\n        timeOffsets = timeOffsets.concat([formData.start_date_offset]);\n      }\n      if (customOrInheritShifts.includes('inherit')) {\n        timeOffsets = timeOffsets.concat(['inherit']);\n      }\n    }\n\n    let temporalColumnAdded = false;\n    let temporalColumn = null;\n\n    if (queryMode === QueryMode.Aggregate) {\n      metrics = metrics || [];\n      // override orderby with timeseries metric when in aggregation mode\n      if (sortByMetric) {\n        orderby = [[sortByMetric, !orderDesc]];\n      } else if (metrics?.length > 0) {\n        // default to ordering by first metric in descending order\n        // when no \"sort by\" metric is set (regardless if \"SORT DESC\" is set to true)\n        orderby = [[metrics[0], false]];\n      }\n      // add postprocessing for percent metrics only when in aggregation mode\n      if (percentMetrics && percentMetrics.length > 0) {\n        const percentMetricsLabelsWithTimeComparison = isTimeComparison(\n          formData,\n          baseQueryObject,\n        )\n          ? addComparisonPercentMetrics(\n              percentMetrics.map(getMetricLabel),\n              timeOffsets,\n            )\n          : percentMetrics.map(getMetricLabel);\n        const percentMetricLabels = removeDuplicates(\n          percentMetricsLabelsWithTimeComparison,\n        );\n        metrics = removeDuplicates(\n          metrics.concat(percentMetrics),\n          getMetricLabel,\n        );\n        postProcessing = [\n          {\n            operation: 'contribution',\n            options: {\n              columns: percentMetricLabels,\n              rename_columns: percentMetricLabels.map(x => `%${x}`),\n            },\n          },\n        ];\n      }\n      // Add the operator for the time comparison if some is selected\n      if (!isEmpty(timeOffsets)) {\n        postProcessing.push(timeCompareOperator(formData, baseQueryObject));\n      }\n\n      const temporalColumnsLookup = formData?.temporal_columns_lookup;\n      // Filter out the column if needed and prepare the temporal column object\n\n      columns = columns.filter(col => {\n        const shouldBeAdded =\n          isPhysicalColumn(col) &&\n          time_grain_sqla &&\n          temporalColumnsLookup?.[col];\n\n        if (shouldBeAdded && !temporalColumnAdded) {\n          temporalColumn = {\n            timeGrain: time_grain_sqla,\n            columnType: 'BASE_AXIS',\n            sqlExpression: col,\n            label: col,\n            expressionType: 'SQL',\n          } as AdhocColumn;\n          temporalColumnAdded = true;\n          return false; // Do not include this in the output; it's added separately\n        }\n        return true;\n      });\n\n      // So we ensure the temporal column is added first\n      if (temporalColumn) {\n        columns = [temporalColumn, ...columns];\n      }\n    }\n\n    const moreProps: Partial<QueryObject> = {};\n    const ownState = options?.ownState ?? {};\n    if (formDataCopy.server_pagination) {\n      moreProps.row_limit =\n        ownState.pageSize ?? formDataCopy.server_page_length;\n      moreProps.row_offset =\n        (ownState.currentPage ?? 0) * (ownState.pageSize ?? 0);\n    }\n\n    let queryObject = {\n      ...baseQueryObject,\n      columns,\n      extras,\n      orderby,\n      metrics,\n      post_processing: postProcessing,\n      time_offsets: timeOffsets,\n      ...moreProps,\n    };\n\n    if (\n      formData.server_pagination &&\n      options?.extras?.cachedChanges?.[formData.slice_id] &&\n      JSON.stringify(options?.extras?.cachedChanges?.[formData.slice_id]) !==\n        JSON.stringify(queryObject.filters)\n    ) {\n      queryObject = { ...queryObject, row_offset: 0 };\n      updateExternalFormData(\n        options?.hooks?.setDataMask,\n        0,\n        queryObject.row_limit ?? 0,\n      );\n    }\n    // Because we use same buildQuery for all table on the page we need split them by id\n    options?.hooks?.setCachedChanges({\n      [formData.slice_id]: queryObject.filters,\n    });\n\n    const extraQueries: QueryObject[] = [];\n    if (\n      metrics?.length &&\n      formData.show_totals &&\n      queryMode === QueryMode.Aggregate\n    ) {\n      extraQueries.push({\n        ...queryObject,\n        columns: [],\n        row_limit: 0,\n        row_offset: 0,\n        post_processing: [],\n        order_desc: undefined, // we don't need orderby stuff here,\n        orderby: undefined, // because this query will be used for get total aggregation.\n      });\n    }\n\n    const interactiveGroupBy = formData.extra_form_data?.interactive_groupby;\n    if (interactiveGroupBy && queryObject.columns) {\n      queryObject.columns = [\n        ...new Set([...queryObject.columns, ...interactiveGroupBy]),\n      ];\n    }\n\n    if (formData.server_pagination) {\n      return [\n        { ...queryObject },\n        {\n          ...queryObject,\n          time_offsets: [],\n          row_limit: 0,\n          row_offset: 0,\n          post_processing: [],\n          is_rowcount: true,\n        },\n        ...extraQueries,\n      ];\n    }\n\n    return [queryObject, ...extraQueries];\n  });\n};\n\n// Use this closure to cache changing of external filters, if we have server pagination we need reset page to 0, after\n// external filter changed\nexport const cachedBuildQuery = (): BuildQuery<TableChartFormData> => {\n  let cachedChanges: any = {};\n  const setCachedChanges = (newChanges: any) => {\n    cachedChanges = { ...cachedChanges, ...newChanges };\n  };\n\n  return (formData, options) =>\n    buildQuery(\n      { ...formData },\n      {\n        extras: { cachedChanges },\n        ownState: options?.ownState ?? {},\n        hooks: {\n          ...options?.hooks,\n          setDataMask: () => {},\n          setCachedChanges,\n        },\n      },\n    );\n};\n\nexport default cachedBuildQuery();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}