{"ast":null,"code":"import _pick from \"lodash/pick\";import _omit from \"lodash/omit\";import _intersection from \"lodash/intersection\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, ensureIsArray, getCategoricalSchemeRegistry, getLabelsColorMap } from '@superset-ui/core';\n\nimport { areObjectsEqual } from 'src/reduxUtils';\nconst EMPTY_ARRAY = [];\n/**\n * Force falsy namespace values to undefined to default to GLOBAL\n *\n * @param namespace\n * @returns - namespace or default undefined\n */\nexport const getColorNamespace = (namespace) => namespace || undefined;\n/**\n *\n * Field shared_label_colors used to be a dict of all colors for all labels.\n * Force shared_label_colors field to be a list of actual shared labels.\n *\n * @param sharedLabelsColors - the shared label colors list\n * @returns string[]\n */\nexport const enforceSharedLabelsColorsArray = (sharedLabelsColors) => Array.isArray(sharedLabelsColors) ? sharedLabelsColors : EMPTY_ARRAY;\n/**\n * Get labels shared across all charts in a dashboard.\n * Merges a fresh instance of shared label colors with a stored one.\n *\n * @param currentSharedLabels - existing shared labels to merge with fresh\n * @returns Record<string, string>\n */\nexport const getFreshSharedLabels = (currentSharedLabels = []) => {\n  const { chartsLabelsMap } = getLabelsColorMap();\n  const allLabels = Array.from(chartsLabelsMap.values()).flatMap(({ labels }) => labels);\n  const duplicates = Array.from(allLabels.reduce((counts, label) => counts.set(label, (counts.get(label) || 0) + 1), new Map())).\n  filter(([, count]) => count > 1).\n  map(([label]) => label);\n  return Array.from(new Set([...ensureIsArray(currentSharedLabels), ...duplicates]));\n};\nexport const getSharedLabelsColorMapEntries = (currentColorMap, sharedLabels) => Object.fromEntries(Object.entries(currentColorMap).filter(([label]) => sharedLabels.includes(label)));\n/**\n * Returns all entries (labels and colors) except custom label colors.\n *\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getFreshLabelsColorMapEntries = (customLabelsColor = {}) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const allEntries = Object.fromEntries(labelsColorMapInstance.getColorMap());\n  // custom label colors are applied and stored separetely via label_colors\n  Object.keys(customLabelsColor).forEach((label) => {\n    delete allEntries[label];\n  });\n  return allEntries;\n};\n/**\n * Returns all dynamic labels and colors (excluding custom label colors).\n *\n * @param labelsColorMap - the labels color map\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getDynamicLabelsColors = (fullLabelsColors, customLabelsColor = {}) => _omit(fullLabelsColors, Object.keys(customLabelsColor));\nexport const getColorSchemeDomain = (colorScheme) => {var _getCategoricalScheme;return ((_getCategoricalScheme = getCategoricalSchemeRegistry().get(colorScheme)) == null ? void 0 : _getCategoricalScheme.colors) || [];};\n/**\n * Compare the current labels color map with a fresh one\n *\n * @param currentLabelsColorMap - the current labels color map\n * @returns true if the labels color map is the same as fresh\n */\nexport const isLabelsColorMapSynced = (storedLabelsColors, freshLabelsColors, customLabelColors) => {\n  const freshLabelsCount = Object.keys(freshLabelsColors).length;\n  // still updating, pass\n  if (!freshLabelsCount)\n  return true;\n  const commonKeys = _intersection(Object.keys(storedLabelsColors), Object.keys(freshLabelsColors));\n  const comparableStoredLabelsColors = _pick(storedLabelsColors, commonKeys);\n  const comparableFreshLabelsColors = _pick(freshLabelsColors, commonKeys);\n  const isSynced = areObjectsEqual(comparableStoredLabelsColors, comparableFreshLabelsColors, {\n    ignoreFields: Object.keys(customLabelColors)\n  });\n  return isSynced;\n};\n/**\n * Annihilate color maps\n *\n * @param color_namespace - the categorical namespace\n */\nexport const resetColors = (color_namespace) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(getColorNamespace(color_namespace));\n  categoricalNamespace.resetColors();\n  labelsColorMapInstance.reset();\n};\n/**\n * Update the labels color map based on current color scheme\n * It will respect custom label colors if set via namespace\n *\n * @param namespace - the color namespace\n * @param colorScheme - the current color scheme\n */\nexport const refreshLabelsColorMap = (namespace, colorScheme, merge = false) => {\n  const colorNameSpace = getColorNamespace(namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const labelsColorMapInstance = getLabelsColorMap();\n  labelsColorMapInstance.updateColorMap(categoricalNamespace, colorScheme, merge);\n};\n/**\n * Merge labels colors with custom labels colors\n * Apply labels color based on chosen color scheme\n *\n * @param metadata - the dashboard metadata object\n */\nexport const applyColors = (metadata,\n// Create a fresh color map by changing color scheme\nfresh = false,\n// Catch new labels in the color map as they appear\nmerge = false,\n// Apply only label colors that are shared across multiple charts.\nshared = false) => {\n  const colorNameSpace = getColorNamespace(metadata == null ? void 0 : metadata.color_namespace);\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const colorScheme = metadata == null ? void 0 : metadata.color_scheme;\n  const fullLabelsColor = (metadata == null ? void 0 : metadata.map_label_colors) || {};\n  const sharedLabels = enforceSharedLabelsColorsArray(metadata == null ? void 0 : metadata.shared_label_colors);\n  const customLabelsColor = (metadata == null ? void 0 : metadata.label_colors) || {};\n  const sharedLabelsColor = getSharedLabelsColorMapEntries(fullLabelsColor, sharedLabels);\n  if (fresh && !Array.isArray(fresh)) {\n    // reset custom label colors\n    // re-evaluate all other label colors\n    categoricalNamespace.resetColors();\n  }\n  if (fresh && Array.isArray(fresh)) {\n    // when a color scheme is not set for the dashboard\n    // should only reset colors for charts that have changed scheme\n    // while keeping colors of existing shared label colors intact\n    // this is used also to reset custom label colors when added or removed\n    categoricalNamespace.resetColorsForLabels(fresh);\n  }\n  if (fresh || merge) {\n    // re-instantiate a fresh labels color map based on current scheme\n    // it consider just applied custom label colors if present and all forced colors\n    // it will merge with the existing color map new labels only when merge is true\n    refreshLabelsColorMap(metadata == null ? void 0 : metadata.color_namespace, colorScheme, merge);\n  }\n  let applicableColorMapEntries = fullLabelsColor;\n  if (fresh) {\n    // requires a new map all together\n    applicableColorMapEntries = {\n      ...getFreshLabelsColorMapEntries(customLabelsColor)\n    };\n  }\n  if (merge) {\n    // must only add up newly appearing labels\n    // without overriding existing ones\n    applicableColorMapEntries = {\n      ...fullLabelsColor,\n      ...getFreshLabelsColorMapEntries(customLabelsColor)\n    };\n  }\n  if (shared) {\n    // must apply the colors to only shared labels\n    applicableColorMapEntries = sharedLabelsColor;\n  }\n  applicableColorMapEntries = {\n    ...applicableColorMapEntries,\n    ...customLabelsColor\n  };\n  // apply the final color map\n  if (applicableColorMapEntries) {\n    Object.keys(applicableColorMapEntries).forEach((label) => {\n      categoricalNamespace.setColor(label, applicableColorMapEntries[label]);\n    });\n  }\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EMPTY_ARRAY, \"EMPTY_ARRAY\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getColorNamespace, \"getColorNamespace\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(enforceSharedLabelsColorsArray, \"enforceSharedLabelsColorsArray\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getFreshSharedLabels, \"getFreshSharedLabels\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getSharedLabelsColorMapEntries, \"getSharedLabelsColorMapEntries\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getFreshLabelsColorMapEntries, \"getFreshLabelsColorMapEntries\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getDynamicLabelsColors, \"getDynamicLabelsColors\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(getColorSchemeDomain, \"getColorSchemeDomain\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(isLabelsColorMapSynced, \"isLabelsColorMapSynced\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(resetColors, \"resetColors\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(refreshLabelsColorMap, \"refreshLabelsColorMap\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");reactHotLoader.register(applyColors, \"applyColors\", \"/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CategoricalColorNamespace","ensureIsArray","getCategoricalSchemeRegistry","getLabelsColorMap","areObjectsEqual","EMPTY_ARRAY","getColorNamespace","namespace","undefined","enforceSharedLabelsColorsArray","sharedLabelsColors","Array","isArray","getFreshSharedLabels","currentSharedLabels","chartsLabelsMap","allLabels","from","values","flatMap","labels","duplicates","reduce","counts","label","set","get","Map","filter","count","map","Set","getSharedLabelsColorMapEntries","currentColorMap","sharedLabels","Object","fromEntries","entries","includes","getFreshLabelsColorMapEntries","customLabelsColor","labelsColorMapInstance","allEntries","getColorMap","keys","forEach","getDynamicLabelsColors","fullLabelsColors","_omit","getColorSchemeDomain","colorScheme","_getCategoricalScheme","colors","isLabelsColorMapSynced","storedLabelsColors","freshLabelsColors","customLabelColors","freshLabelsCount","length","commonKeys","_intersection","comparableStoredLabelsColors","_pick","comparableFreshLabelsColors","isSynced","ignoreFields","resetColors","color_namespace","categoricalNamespace","getNamespace","reset","refreshLabelsColorMap","merge","colorNameSpace","updateColorMap","applyColors","metadata","fresh","shared","color_scheme","fullLabelsColor","map_label_colors","shared_label_colors","label_colors","sharedLabelsColor","resetColorsForLabels","applicableColorMapEntries","setColor","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/utils/colorScheme.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  CategoricalColorNamespace,\n  ensureIsArray,\n  getCategoricalSchemeRegistry,\n  getLabelsColorMap,\n} from '@superset-ui/core';\nimport { intersection, omit, pick } from 'lodash';\nimport { areObjectsEqual } from 'src/reduxUtils';\n\nconst EMPTY_ARRAY: string[] = [];\n\n/**\n * Force falsy namespace values to undefined to default to GLOBAL\n *\n * @param namespace\n * @returns - namespace or default undefined\n */\nexport const getColorNamespace = (namespace?: string) => namespace || undefined;\n\n/**\n *\n * Field shared_label_colors used to be a dict of all colors for all labels.\n * Force shared_label_colors field to be a list of actual shared labels.\n *\n * @param sharedLabelsColors - the shared label colors list\n * @returns string[]\n */\nexport const enforceSharedLabelsColorsArray = (\n  sharedLabelsColors: string[] | Record<string, string> | undefined,\n) => (Array.isArray(sharedLabelsColors) ? sharedLabelsColors : EMPTY_ARRAY);\n\n/**\n * Get labels shared across all charts in a dashboard.\n * Merges a fresh instance of shared label colors with a stored one.\n *\n * @param currentSharedLabels - existing shared labels to merge with fresh\n * @returns Record<string, string>\n */\nexport const getFreshSharedLabels = (\n  currentSharedLabels: string[] = [],\n): string[] => {\n  const { chartsLabelsMap } = getLabelsColorMap();\n  const allLabels = Array.from(chartsLabelsMap.values()).flatMap(\n    ({ labels }) => labels,\n  );\n\n  const duplicates = Array.from(\n    allLabels.reduce(\n      (counts, label) => counts.set(label, (counts.get(label) || 0) + 1),\n      new Map(),\n    ),\n  )\n    .filter(([, count]) => count > 1)\n    .map(([label]) => label);\n\n  return Array.from(\n    new Set([...ensureIsArray(currentSharedLabels), ...duplicates]),\n  );\n};\n\nexport const getSharedLabelsColorMapEntries = (\n  currentColorMap: Record<string, string>,\n  sharedLabels: string[],\n): Record<string, string> =>\n  Object.fromEntries(\n    Object.entries(currentColorMap).filter(([label]) =>\n      sharedLabels.includes(label),\n    ),\n  );\n\n/**\n * Returns all entries (labels and colors) except custom label colors.\n *\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getFreshLabelsColorMapEntries = (\n  customLabelsColor: Record<string, string> = {},\n): Record<string, string> => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const allEntries = Object.fromEntries(labelsColorMapInstance.getColorMap());\n\n  // custom label colors are applied and stored separetely via label_colors\n  Object.keys(customLabelsColor).forEach(label => {\n    delete allEntries[label];\n  });\n\n  return allEntries;\n};\n\n/**\n * Returns all dynamic labels and colors (excluding custom label colors).\n *\n * @param labelsColorMap - the labels color map\n * @param customLabelsColor - the custom label colors in label_colors field\n * @returns all color entries except custom label colors\n */\nexport const getDynamicLabelsColors = (\n  fullLabelsColors: Record<string, string>,\n  customLabelsColor: Record<string, string> = {},\n): Record<string, string> =>\n  omit(fullLabelsColors, Object.keys(customLabelsColor));\n\nexport const getColorSchemeDomain = (colorScheme: string) =>\n  getCategoricalSchemeRegistry().get(colorScheme)?.colors || [];\n\n/**\n * Compare the current labels color map with a fresh one\n *\n * @param currentLabelsColorMap - the current labels color map\n * @returns true if the labels color map is the same as fresh\n */\nexport const isLabelsColorMapSynced = (\n  storedLabelsColors: Record<string, any>,\n  freshLabelsColors: Record<string, any>,\n  customLabelColors: Record<string, string>,\n): boolean => {\n  const freshLabelsCount = Object.keys(freshLabelsColors).length;\n\n  // still updating, pass\n  if (!freshLabelsCount) return true;\n\n  const commonKeys = intersection(\n    Object.keys(storedLabelsColors),\n    Object.keys(freshLabelsColors),\n  );\n\n  const comparableStoredLabelsColors = pick(storedLabelsColors, commonKeys);\n  const comparableFreshLabelsColors = pick(freshLabelsColors, commonKeys);\n\n  const isSynced = areObjectsEqual(\n    comparableStoredLabelsColors,\n    comparableFreshLabelsColors,\n    {\n      ignoreFields: Object.keys(customLabelColors),\n    },\n  );\n\n  return isSynced;\n};\n\n/**\n * Annihilate color maps\n *\n * @param color_namespace - the categorical namespace\n */\nexport const resetColors = (color_namespace?: string) => {\n  const labelsColorMapInstance = getLabelsColorMap();\n  const categoricalNamespace = CategoricalColorNamespace.getNamespace(\n    getColorNamespace(color_namespace),\n  );\n  categoricalNamespace.resetColors();\n  labelsColorMapInstance.reset();\n};\n\n/**\n * Update the labels color map based on current color scheme\n * It will respect custom label colors if set via namespace\n *\n * @param namespace - the color namespace\n * @param colorScheme - the current color scheme\n */\nexport const refreshLabelsColorMap = (\n  namespace?: string,\n  colorScheme?: string,\n  merge = false,\n) => {\n  const colorNameSpace = getColorNamespace(namespace);\n  const categoricalNamespace =\n    CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const labelsColorMapInstance = getLabelsColorMap();\n\n  labelsColorMapInstance.updateColorMap(\n    categoricalNamespace,\n    colorScheme,\n    merge,\n  );\n};\n\n/**\n * Merge labels colors with custom labels colors\n * Apply labels color based on chosen color scheme\n *\n * @param metadata - the dashboard metadata object\n */\nexport const applyColors = (\n  metadata: Record<string, any>,\n  // Create a fresh color map by changing color scheme\n  fresh: boolean | string[] = false,\n  // Catch new labels in the color map as they appear\n  merge = false,\n  // Apply only label colors that are shared across multiple charts.\n  shared = false,\n) => {\n  const colorNameSpace = getColorNamespace(metadata?.color_namespace);\n  const categoricalNamespace =\n    CategoricalColorNamespace.getNamespace(colorNameSpace);\n  const colorScheme = metadata?.color_scheme;\n  const fullLabelsColor = metadata?.map_label_colors || {};\n  const sharedLabels = enforceSharedLabelsColorsArray(\n    metadata?.shared_label_colors,\n  );\n  const customLabelsColor = metadata?.label_colors || {};\n  const sharedLabelsColor = getSharedLabelsColorMapEntries(\n    fullLabelsColor,\n    sharedLabels,\n  );\n\n  if (fresh && !Array.isArray(fresh)) {\n    // reset custom label colors\n    // re-evaluate all other label colors\n    categoricalNamespace.resetColors();\n  }\n\n  if (fresh && Array.isArray(fresh)) {\n    // when a color scheme is not set for the dashboard\n    // should only reset colors for charts that have changed scheme\n    // while keeping colors of existing shared label colors intact\n    // this is used also to reset custom label colors when added or removed\n    categoricalNamespace.resetColorsForLabels(fresh);\n  }\n\n  if (fresh || merge) {\n    // re-instantiate a fresh labels color map based on current scheme\n    // it consider just applied custom label colors if present and all forced colors\n    // it will merge with the existing color map new labels only when merge is true\n    refreshLabelsColorMap(metadata?.color_namespace, colorScheme, merge);\n  }\n\n  let applicableColorMapEntries: Record<string, any> = fullLabelsColor;\n  if (fresh) {\n    // requires a new map all together\n    applicableColorMapEntries = {\n      ...getFreshLabelsColorMapEntries(customLabelsColor),\n    };\n  }\n  if (merge) {\n    // must only add up newly appearing labels\n    // without overriding existing ones\n    applicableColorMapEntries = {\n      ...fullLabelsColor,\n      ...getFreshLabelsColorMapEntries(customLabelsColor),\n    };\n  }\n\n  if (shared) {\n    // must apply the colors to only shared labels\n    applicableColorMapEntries = sharedLabelsColor;\n  }\n\n  applicableColorMapEntries = {\n    ...applicableColorMapEntries,\n    ...customLabelsColor,\n  };\n\n  // apply the final color map\n  if (applicableColorMapEntries) {\n    Object.keys(applicableColorMapEntries).forEach(label => {\n      categoricalNamespace.setColor(label, applicableColorMapEntries[label]);\n    });\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}