{"ast":null,"code":"import _uniq from \"lodash/uniq\";import _isEqual from \"lodash/isEqual\";import _debounce from \"lodash/debounce\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { forwardRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport { ensureIsArray, t, usePrevious } from '@superset-ui/core';\n\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport { getValue, hasOption, isLabeledValue, renderSelectOptions, sortSelectedFirstHelper, sortComparatorWithSearchHelper, handleFilterOptionHelper, dropDownRenderHelper, getSuffixIcon, mapValues, mapOptions, hasCustomLabels, getOption, isObject, isEqual as utilsIsEqual } from './utils';\nimport { StyledBulkActionsContainer, StyledCheckOutlined, StyledContainer, StyledHeader, StyledSelect, StyledStopOutlined } from './styles';\nimport { EMPTY_OPTIONS, MAX_TAG_COUNT, TOKEN_SEPARATORS, DEFAULT_SORT_COMPARATOR } from './constants';\nimport { customTagRender } from './CustomTag';\nimport Button from '../Button';\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */import { jsx as _jsx, jsxs as _jsxs } from \"@emotion/react/jsx-runtime\";\nconst Select = /*#__PURE__*/forwardRef(__signature__(({ className, allowClear, allowNewOptions = false, allowSelectAll = true, ariaLabel, autoClearSearchValue = false, filterOption = true, header = null, headerPosition = 'top', helperText, invertSelection = false, labelInValue = false, loading, mode = 'single', name, notFoundContent, onBlur, onChange, onClear, onDropdownVisibleChange, onDeselect, onSearch, onSelect, optionFilterProps = ['label', 'value'], options, placeholder = t('Select ...'), showSearch = true, sortComparator = DEFAULT_SORT_COMPARATOR, tokenSeparators = TOKEN_SEPARATORS, value, getPopupContainer, oneLine, maxTagCount: propsMaxTagCount, ...props }, ref) => {\n  const isSingleMode = mode === 'single';\n  const shouldShowSearch = allowNewOptions ? true : showSearch;\n  const [selectValue, setSelectValue] = useState(value);\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(loading);\n  const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n  const [isSearching, setIsSearching] = useState(false);\n  const [visibleOptions, setVisibleOptions] = useState([]);\n  const [maxTagCount, setMaxTagCount] = useState(propsMaxTagCount != null ? propsMaxTagCount : MAX_TAG_COUNT);\n  const [onChangeCount, setOnChangeCount] = useState(0);\n  const previousChangeCount = usePrevious(onChangeCount, 0);\n  const fireOnChange = useCallback(() => setOnChangeCount(onChangeCount + 1), [onChangeCount]);\n  useEffect(() => {\n    if (oneLine) {\n      setMaxTagCount(isDropdownVisible ? 0 : 1);\n    }\n  }, [isDropdownVisible, oneLine]);\n  const mappedMode = isSingleMode ? undefined : 'multiple';\n  const sortSelectedFirst = useCallback((a, b) => sortSelectedFirstHelper(a, b, selectValue), [selectValue]);\n  const sortComparatorWithSearch = useCallback((a, b) => sortComparatorWithSearchHelper(a, b, inputValue, sortSelectedFirst, sortComparator), [inputValue, sortComparator, sortSelectedFirst]);\n  const initialOptions = useMemo(() => Array.isArray(options) ? options.slice() : EMPTY_OPTIONS, [options]);\n  const initialOptionsSorted = useMemo(() => initialOptions.slice().sort(sortSelectedFirst), [initialOptions, sortSelectedFirst]);\n  const [selectOptions, setSelectOptions] = useState(initialOptionsSorted);\n  // add selected values to options list if they are not in it\n  const fullSelectOptions = useMemo(() => {\n    // check to see if selectOptions are grouped\n    let groupedOptions;\n    if (selectOptions.some((opt) => opt.options)) {\n      groupedOptions = selectOptions.reduce((acc, group) => [...acc, ...group.options], []);\n    }\n    const missingValues = ensureIsArray(selectValue).\n    filter((opt) => !hasOption(getValue(opt), groupedOptions || selectOptions)).\n    map((opt) => isLabeledValue(opt) ? opt : { value: opt, label: String(opt) });\n    const result = missingValues.length > 0 ?\n    missingValues.concat(selectOptions) :\n    selectOptions;\n    return result.slice().sort(sortSelectedFirst);\n  }, [selectOptions, selectValue, sortSelectedFirst]);\n  const enabledOptions = useMemo(() => visibleOptions.filter((option) => !option.disabled), [visibleOptions]);\n  const selectAllEligible = useMemo(() => visibleOptions.filter((option) => (hasOption(option.value, selectValue) || !option.disabled) &&\n  !option.isNewOption), [visibleOptions, selectValue]);\n  const selectAllEnabled = useMemo(() => !isSingleMode &&\n  allowSelectAll &&\n  selectOptions.length > 0 &&\n  enabledOptions.length > 1, [\n  isSingleMode,\n  allowSelectAll,\n  selectOptions.length,\n  enabledOptions.length]\n  );\n  const selectAllMode = useMemo(() => ensureIsArray(selectValue).length === selectAllEligible.length + 1, [selectValue, selectAllEligible]);\n  const bulkSelectCounts = useMemo(() => {\n    const selectedValuesSet = new Set(ensureIsArray(selectValue).map(getValue));\n    return visibleOptions.reduce((acc, option) => {\n      const isSelected = selectedValuesSet.has(option.value);\n      const isDisabled = option.disabled;\n      const isNew = option.isNewOption;\n      if ((!isDisabled || isSelected) && (\n      isNew && isSelected || !isNew)) {\n        acc.selectable += 1;\n      }\n      if (isSelected && !isDisabled) {\n        acc.deselectable += 1;\n      }\n      return acc;\n    }, { selectable: 0, deselectable: 0 });\n  }, [visibleOptions, selectValue]);\n  const handleOnSelect = (selectedItem, option) => {\n    if (isSingleMode) {\n      // on select is fired in single value mode if the same value is selected\n      const valueChanged = !utilsIsEqual(selectedItem, selectValue, 'value');\n      setSelectValue(selectedItem);\n      if (valueChanged) {\n        fireOnChange();\n      }\n    } else\n    {\n      setSelectValue((previousState) => {\n        const array = ensureIsArray(previousState);\n        const value = getValue(selectedItem);\n        if (!hasOption(value, array)) {\n          const result = [...array, selectedItem];\n          if (result.length === selectAllEligible.length &&\n          selectAllEnabled) {\n            return isLabeledValue(selectedItem) ?\n            [...result] :\n            [...result];\n          }\n          return result;\n        }\n        return previousState;\n      });\n      fireOnChange();\n    }\n    onSelect == null ? void 0 : onSelect(selectedItem, option);\n  };\n  const clear = () => {\n    if (isSingleMode) {\n      setSelectValue(undefined);\n    } else\n    {\n      setSelectValue(fullSelectOptions.\n      filter((option) => option.disabled && hasOption(option.value, selectValue)).\n      map((option) => labelInValue ?\n      { label: option.label, value: option.value } :\n      option.value));\n    }\n    fireOnChange();\n  };\n  const handleOnDeselect = (value, option) => {\n    if (Array.isArray(selectValue)) {\n      const array = selectValue.filter((element) => getValue(element) !== getValue(value));\n      setSelectValue(array);\n      // removes new option\n      if (option.isNewOption) {\n        const updatedOptions = fullSelectOptions.filter((option) => getValue(option.value) !== getValue(value));\n        setSelectOptions(updatedOptions);\n        setVisibleOptions(updatedOptions);\n      }\n    }\n    fireOnChange();\n    onDeselect == null ? void 0 : onDeselect(value, option);\n  };\n  const handleFilterOption = (search, option) => handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n  const handleOnSearch = _debounce((search) => {\n    const searchValue = search.trim();\n    setIsSearching(!!searchValue);\n    let updatedOptions = selectOptions;\n    if (allowNewOptions) {\n      const newOption = searchValue &&\n      !hasOption(searchValue, fullSelectOptions, true) && {\n        label: searchValue,\n        value: searchValue,\n        isNewOption: true\n      };\n      const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter((opt) => !opt.isNewOption || hasOption(opt.value, selectValue));\n      updatedOptions = newOption ?\n      [newOption, ...cleanSelectOptions] :\n      cleanSelectOptions;\n      setSelectOptions(updatedOptions);\n    }\n    const filteredOptions = updatedOptions.filter((option) => handleFilterOption(search, option));\n    setVisibleOptions(filteredOptions);\n    setInputValue(searchValue);\n    onSearch == null ? void 0 : onSearch(searchValue);\n  }, FAST_DEBOUNCE);\n  useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n  const handleOnDropdownVisibleChange = (isDropdownVisible) => {\n    setIsDropdownVisible(isDropdownVisible);\n    setVisibleOptions(fullSelectOptions);\n    // if no search input value, force sort options because it won't be sorted by\n    // `filterSort`.\n    if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n      if (!_isEqual(initialOptionsSorted, selectOptions)) {\n        setSelectOptions(initialOptionsSorted);\n      }\n    }\n    if (!isDropdownVisible) {\n      setSelectOptions(initialOptionsSorted);\n    }\n    if (onDropdownVisibleChange) {\n      onDropdownVisibleChange(isDropdownVisible);\n    }\n  };\n  const handleSelectAll = useCallback(() => {\n    if (isSingleMode)\n    return;\n    const optionsToSelect = isSearching ?\n    visibleOptions.filter((option) => !option.isNewOption) :\n    enabledOptions;\n    const currentValues = ensureIsArray(selectValue);\n    const currentValuesSet = new Set(currentValues.map(getValue));\n    const newValues = [...currentValues];\n    optionsToSelect.forEach((option) => {\n      if (!option.disabled && !currentValuesSet.has(option.value)) {\n        if (labelInValue) {\n          newValues.push({\n            label: option.label,\n            value: option.value\n          });\n        } else\n        {\n          newValues.push(option.value);\n        }\n      }\n    });\n    setSelectValue(newValues);\n    fireOnChange();\n  }, [\n  isSingleMode,\n  isSearching,\n  visibleOptions,\n  enabledOptions,\n  selectValue,\n  labelInValue,\n  fireOnChange]\n  );\n  const handleDeselectAll = useCallback(() => {\n    if (isSingleMode)\n    return;\n    const deselectionValues = new Set(enabledOptions.map((opt) => opt.value));\n    const newValues = ensureIsArray(selectValue).filter((item) => {\n      const itemValue = getValue(item);\n      return !deselectionValues.has(itemValue);\n    });\n    setSelectValue(newValues);\n    fireOnChange();\n  }, [isSingleMode, enabledOptions, selectValue, fireOnChange]);\n  const bulkSelectComponent = useMemo(() => _jsxs(StyledBulkActionsContainer, { size: 0, children: [\n    _jsx(Button, { type: \"link\", buttonSize: \"xsmall\", disabled: bulkSelectCounts.selectable === 0, onMouseDown: (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        handleSelectAll();\n      }, children:\n      `${t('Select all')} (${bulkSelectCounts.selectable})` }\n    ),\n    _jsx(Button, { type: \"link\", buttonSize: \"xsmall\", disabled: bulkSelectCounts.deselectable === 0, onMouseDown: (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        handleDeselectAll();\n      }, children:\n      `${t('Deselect all')} (${bulkSelectCounts.deselectable})` }\n    )] }\n  ), [\n  handleSelectAll,\n  handleDeselectAll,\n  bulkSelectCounts.selectable,\n  bulkSelectCounts.deselectable]\n  );\n  const dropdownRender = (originNode) => dropDownRenderHelper(originNode, isDropdownVisible, isLoading, fullSelectOptions.length, helperText, undefined, selectAllEnabled ? bulkSelectComponent : undefined);\n  const handleClear = () => {\n    clear();\n    if (onClear) {\n      onClear();\n    }\n  };\n  useEffect(() => {\n    // when `options` list is updated from component prop, reset states\n    setSelectOptions(initialOptions);\n    setVisibleOptions(initialOptions);\n  }, [initialOptions]);\n  useEffect(() => {\n    if (loading !== undefined && loading !== isLoading) {\n      setIsLoading(loading);\n    }\n  }, [isLoading, loading]);\n  useEffect(() => {\n    setSelectValue(value);\n  }, [value]);\n  const handleOnBlur = (event) => {\n    setInputValue('');\n    onBlur == null ? void 0 : onBlur(event);\n  };\n  const handleOnChange = useCallback((values, options) => {\n    // intercept onChange call to handle the select all case\n    // if the \"select all\" option is selected, we want to send all options to the onChange,\n    // otherwise we want to remove\n    let newValues = values;\n    let newOptions = options;\n    if (!isSingleMode) {\n      if (ensureIsArray(values).length === selectAllEligible.length &&\n      selectAllMode) {\n        const array = selectAllEligible.filter((option) => hasOption(option.value, selectValue) && option.disabled);\n        newValues = mapValues(array, labelInValue);\n        newOptions = mapOptions(array);\n      }\n    }\n    onChange == null ? void 0 : onChange(newValues, newOptions);\n  }, [\n  isSingleMode,\n  labelInValue,\n  onChange,\n  selectAllEligible,\n  selectAllMode,\n  selectValue]\n  );\n  useEffect(() => {\n    if (onChangeCount !== previousChangeCount) {\n      const array = ensureIsArray(selectValue);\n      const set = new Set(array.map(getValue));\n      const options = mapOptions(fullSelectOptions.filter((opt) => set.has(opt.value)));\n      if (isSingleMode) {\n        handleOnChange(selectValue, selectValue ? options[0] : undefined);\n      } else\n      {\n        handleOnChange(array, options);\n      }\n    }\n  }, [\n  fullSelectOptions,\n  handleOnChange,\n  isSingleMode,\n  onChange,\n  onChangeCount,\n  previousChangeCount,\n  selectValue]\n  );\n  const shouldRenderChildrenOptions = useMemo(() => selectAllEnabled || hasCustomLabels(options), [selectAllEnabled, options]);\n  const omittedCount = useMemo(() => {\n    const num_selected = ensureIsArray(selectValue).length;\n    const num_shown = maxTagCount;\n    return num_selected - num_shown - (selectAllMode ? 1 : 0);\n  }, [maxTagCount, selectAllMode, selectValue]);\n  const customMaxTagPlaceholder = () => `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n  // We can't remove the + tag so when Select All\n  // is the only item omitted, we subtract one from maxTagCount\n  let actualMaxTagCount = maxTagCount;\n  if (actualMaxTagCount !== 'responsive' &&\n  omittedCount === 0 &&\n  selectAllMode) {\n    actualMaxTagCount -= 1;\n  }\n  const getPastedTextValue = useCallback((text) => {\n    const option = getOption(text, fullSelectOptions, true);\n    if (!option && !allowNewOptions) {\n      return undefined;\n    }\n    if (labelInValue) {\n      const value = {\n        label: text,\n        value: text\n      };\n      if (option) {\n        value.label = isObject(option) ? option.label : option;\n        value.value = isObject(option) ? option.value : option;\n      }\n      return value;\n    }\n    return option ? isObject(option) ? option.value : option : text;\n  }, [allowNewOptions, fullSelectOptions, labelInValue]);\n  const onPaste = (e) => {\n    const pastedText = e.clipboardData.getData('text');\n    if (isSingleMode) {\n      const value = getPastedTextValue(pastedText);\n      if (value) {\n        setSelectValue(value);\n      }\n    } else\n    {\n      const token = tokenSeparators.find((token) => pastedText.includes(token));\n      const array = token ? _uniq(pastedText.split(token)) : [pastedText];\n      const newOptions = [];\n      const values = array.\n      map((item) => {\n        const option = getOption(item, fullSelectOptions, true);\n        if (!option && allowNewOptions) {\n          const newOption = {\n            label: item,\n            value: item,\n            isNewOption: true\n          };\n          newOptions.push(newOption);\n        }\n        return getPastedTextValue(item);\n      }).\n      filter((item) => item !== undefined);\n      if (newOptions.length > 0) {\n        const updatedOptions = [...fullSelectOptions, ...newOptions];\n        setSelectOptions(updatedOptions);\n        setVisibleOptions(updatedOptions);\n      }\n      if (labelInValue) {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      } else\n      {\n        setSelectValue((previous) => [\n        ...(previous || []),\n        ...values]\n        );\n      }\n    }\n    fireOnChange();\n  };\n  return _jsxs(StyledContainer, { className: className, headerPosition: headerPosition, children: [\n    header && _jsx(StyledHeader, { headerPosition: headerPosition, children: header }),\n    _jsx(StyledSelect, { id: name, allowClear: !isLoading && allowClear, \"aria-label\": ariaLabel, autoClearSearchValue: autoClearSearchValue, dropdownRender: dropdownRender, filterOption: handleFilterOption, filterSort: sortComparatorWithSearch, getPopupContainer: getPopupContainer || ((triggerNode) => triggerNode.parentNode), headerPosition: headerPosition, labelInValue: labelInValue, maxTagCount: actualMaxTagCount, maxTagPlaceholder: customMaxTagPlaceholder, mode: mappedMode, notFoundContent: isLoading ? t('Loading...') : notFoundContent, onBlur: handleOnBlur, onDeselect: handleOnDeselect, onDropdownVisibleChange: handleOnDropdownVisibleChange\n      // @ts-ignore\n      , onPaste: onPaste, onPopupScroll: undefined, onSearch: shouldShowSearch ? handleOnSearch : undefined, onSelect: handleOnSelect, onClear: handleClear, placeholder: placeholder, showSearch: shouldShowSearch, showArrow: true, tokenSeparators: tokenSeparators, value: selectValue, suffixIcon: getSuffixIcon(isLoading, shouldShowSearch, isDropdownVisible), menuItemSelectedIcon: invertSelection ? _jsx(StyledStopOutlined, { iconSize: \"m\", \"aria-label\": \"stop\" }) : _jsx(StyledCheckOutlined, { iconSize: \"m\", \"aria-label\": \"check\" }), options: shouldRenderChildrenOptions ? undefined : visibleOptions, oneLine: oneLine, tagRender: customTagRender, ...props, ref: ref, children:\n      shouldRenderChildrenOptions && renderSelectOptions(visibleOptions) }\n    )] }\n  );\n}, \"useState{[selectValue, setSelectValue](value)}\\nuseState{[inputValue, setInputValue]('')}\\nuseState{[isLoading, setIsLoading](loading)}\\nuseState{[isDropdownVisible, setIsDropdownVisible](false)}\\nuseState{[isSearching, setIsSearching](false)}\\nuseState{[visibleOptions, setVisibleOptions]([])}\\nuseState{[maxTagCount, setMaxTagCount](propsMaxTagCount ?? MAX_TAG_COUNT)}\\nuseState{[onChangeCount, setOnChangeCount](0)}\\nusePrevious{previousChangeCount}\\nuseCallback{fireOnChange}\\nuseEffect{}\\nuseCallback{sortSelectedFirst}\\nuseCallback{sortComparatorWithSearch}\\nuseMemo{initialOptions}\\nuseMemo{initialOptionsSorted}\\nuseState{[selectOptions, setSelectOptions](initialOptionsSorted)}\\nuseMemo{fullSelectOptions}\\nuseMemo{enabledOptions}\\nuseMemo{selectAllEligible}\\nuseMemo{selectAllEnabled}\\nuseMemo{selectAllMode}\\nuseMemo{bulkSelectCounts}\\nuseEffect{}\\nuseCallback{handleSelectAll}\\nuseCallback{handleDeselectAll}\\nuseMemo{bulkSelectComponent}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseCallback{handleOnChange}\\nuseEffect{}\\nuseMemo{shouldRenderChildrenOptions}\\nuseMemo{omittedCount}\\nuseCallback{getPastedTextValue}\", () => [usePrevious]));const _default =\nSelect;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(Select, \"Select\", \"/Users/aryurkov/superset/superset-frontend/src/components/Select/Select.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/aryurkov/superset/superset-frontend/src/components/Select/Select.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["forwardRef","useEffect","useMemo","useState","useCallback","ensureIsArray","t","usePrevious","FAST_DEBOUNCE","getValue","hasOption","isLabeledValue","renderSelectOptions","sortSelectedFirstHelper","sortComparatorWithSearchHelper","handleFilterOptionHelper","dropDownRenderHelper","getSuffixIcon","mapValues","mapOptions","hasCustomLabels","getOption","isObject","isEqual","utilsIsEqual","StyledBulkActionsContainer","StyledCheckOutlined","StyledContainer","StyledHeader","StyledSelect","StyledStopOutlined","EMPTY_OPTIONS","MAX_TAG_COUNT","TOKEN_SEPARATORS","DEFAULT_SORT_COMPARATOR","customTagRender","Button","jsx","_jsx","jsxs","_jsxs","Select","__signature__","className","allowClear","allowNewOptions","allowSelectAll","ariaLabel","autoClearSearchValue","filterOption","header","headerPosition","helperText","invertSelection","labelInValue","loading","mode","name","notFoundContent","onBlur","onChange","onClear","onDropdownVisibleChange","onDeselect","onSearch","onSelect","optionFilterProps","options","placeholder","showSearch","sortComparator","tokenSeparators","value","getPopupContainer","oneLine","maxTagCount","propsMaxTagCount","props","ref","isSingleMode","shouldShowSearch","selectValue","setSelectValue","inputValue","setInputValue","isLoading","setIsLoading","isDropdownVisible","setIsDropdownVisible","isSearching","setIsSearching","visibleOptions","setVisibleOptions","setMaxTagCount","onChangeCount","setOnChangeCount","previousChangeCount","fireOnChange","mappedMode","undefined","sortSelectedFirst","a","b","sortComparatorWithSearch","initialOptions","Array","isArray","slice","initialOptionsSorted","sort","selectOptions","setSelectOptions","fullSelectOptions","groupedOptions","some","opt","reduce","acc","group","missingValues","filter","map","label","String","result","length","concat","enabledOptions","option","disabled","selectAllEligible","isNewOption","selectAllEnabled","selectAllMode","bulkSelectCounts","selectedValuesSet","Set","isSelected","has","isDisabled","isNew","selectable","deselectable","handleOnSelect","selectedItem","valueChanged","previousState","array","clear","handleOnDeselect","element","updatedOptions","handleFilterOption","search","handleOnSearch","_debounce","searchValue","trim","newOption","cleanSelectOptions","filteredOptions","cancel","handleOnDropdownVisibleChange","_isEqual","handleSelectAll","optionsToSelect","currentValues","currentValuesSet","newValues","forEach","push","handleDeselectAll","deselectionValues","item","itemValue","bulkSelectComponent","size","children","type","buttonSize","onMouseDown","e","preventDefault","stopPropagation","dropdownRender","originNode","handleClear","handleOnBlur","event","handleOnChange","values","newOptions","set","shouldRenderChildrenOptions","omittedCount","num_selected","num_shown","customMaxTagPlaceholder","actualMaxTagCount","getPastedTextValue","text","onPaste","pastedText","clipboardData","getData","token","find","includes","_uniq","split","previous","id","filterSort","triggerNode","parentNode","maxTagPlaceholder","onPopupScroll","showArrow","suffixIcon","menuItemSelectedIcon","iconSize","tagRender","_default","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/components/Select/Select.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  forwardRef,\n  FocusEvent,\n  ReactElement,\n  RefObject,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  ClipboardEvent,\n} from 'react';\n\nimport { ensureIsArray, t, usePrevious } from '@superset-ui/core';\n// eslint-disable-next-line no-restricted-imports\nimport { LabeledValue as AntdLabeledValue } from 'antd/lib/select'; // TODO: Remove antd\nimport { debounce, isEqual, uniq } from 'lodash';\nimport { FAST_DEBOUNCE } from 'src/constants';\nimport {\n  getValue,\n  hasOption,\n  isLabeledValue,\n  renderSelectOptions,\n  sortSelectedFirstHelper,\n  sortComparatorWithSearchHelper,\n  handleFilterOptionHelper,\n  dropDownRenderHelper,\n  getSuffixIcon,\n  mapValues,\n  mapOptions,\n  hasCustomLabels,\n  getOption,\n  isObject,\n  isEqual as utilsIsEqual,\n} from './utils';\nimport { RawValue, SelectOptionsType, SelectProps } from './types';\nimport {\n  StyledBulkActionsContainer,\n  StyledCheckOutlined,\n  StyledContainer,\n  StyledHeader,\n  StyledSelect,\n  StyledStopOutlined,\n} from './styles';\nimport {\n  EMPTY_OPTIONS,\n  MAX_TAG_COUNT,\n  TOKEN_SEPARATORS,\n  DEFAULT_SORT_COMPARATOR,\n} from './constants';\nimport { customTagRender } from './CustomTag';\nimport Button from '../Button';\n\n/**\n * This component is a customized version of the Antdesign 4.X Select component\n * https://ant.design/components/select/.\n * This Select component provides an API that is tested against all the different use cases of Superset.\n * It limits and overrides the existing Antdesign API in order to keep their usage to the minimum\n * and to enforce simplification and standardization.\n * It is divided into two macro categories, Static and Async.\n * The Static type accepts a static array of options.\n * The Async type accepts a promise that will return the options.\n * Each of the categories come with different abilities. For a comprehensive guide please refer to\n * the storybook in src/components/Select/Select.stories.tsx.\n */\nconst Select = forwardRef(\n  (\n    {\n      className,\n      allowClear,\n      allowNewOptions = false,\n      allowSelectAll = true,\n      ariaLabel,\n      autoClearSearchValue = false,\n      filterOption = true,\n      header = null,\n      headerPosition = 'top',\n      helperText,\n      invertSelection = false,\n      labelInValue = false,\n      loading,\n      mode = 'single',\n      name,\n      notFoundContent,\n      onBlur,\n      onChange,\n      onClear,\n      onDropdownVisibleChange,\n      onDeselect,\n      onSearch,\n      onSelect,\n      optionFilterProps = ['label', 'value'],\n      options,\n      placeholder = t('Select ...'),\n      showSearch = true,\n      sortComparator = DEFAULT_SORT_COMPARATOR,\n      tokenSeparators = TOKEN_SEPARATORS,\n      value,\n      getPopupContainer,\n      oneLine,\n      maxTagCount: propsMaxTagCount,\n\n      ...props\n    }: SelectProps,\n    ref: RefObject<HTMLInputElement>,\n  ) => {\n    const isSingleMode = mode === 'single';\n    const shouldShowSearch = allowNewOptions ? true : showSearch;\n    const [selectValue, setSelectValue] = useState(value);\n    const [inputValue, setInputValue] = useState('');\n    const [isLoading, setIsLoading] = useState(loading);\n    const [isDropdownVisible, setIsDropdownVisible] = useState(false);\n    const [isSearching, setIsSearching] = useState(false);\n    const [visibleOptions, setVisibleOptions] = useState<SelectOptionsType>([]);\n    const [maxTagCount, setMaxTagCount] = useState(\n      propsMaxTagCount ?? MAX_TAG_COUNT,\n    );\n    const [onChangeCount, setOnChangeCount] = useState(0);\n    const previousChangeCount = usePrevious(onChangeCount, 0);\n    const fireOnChange = useCallback(\n      () => setOnChangeCount(onChangeCount + 1),\n      [onChangeCount],\n    );\n\n    useEffect(() => {\n      if (oneLine) {\n        setMaxTagCount(isDropdownVisible ? 0 : 1);\n      }\n    }, [isDropdownVisible, oneLine]);\n\n    const mappedMode = isSingleMode ? undefined : 'multiple';\n\n    const sortSelectedFirst = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortSelectedFirstHelper(a, b, selectValue),\n      [selectValue],\n    );\n    const sortComparatorWithSearch = useCallback(\n      (a: AntdLabeledValue, b: AntdLabeledValue) =>\n        sortComparatorWithSearchHelper(\n          a,\n          b,\n          inputValue,\n          sortSelectedFirst,\n          sortComparator,\n        ),\n      [inputValue, sortComparator, sortSelectedFirst],\n    );\n\n    const initialOptions = useMemo(\n      () => (Array.isArray(options) ? options.slice() : EMPTY_OPTIONS),\n      [options],\n    );\n    const initialOptionsSorted = useMemo(\n      () => initialOptions.slice().sort(sortSelectedFirst),\n      [initialOptions, sortSelectedFirst],\n    );\n\n    const [selectOptions, setSelectOptions] =\n      useState<SelectOptionsType>(initialOptionsSorted);\n\n    // add selected values to options list if they are not in it\n    const fullSelectOptions = useMemo(() => {\n      // check to see if selectOptions are grouped\n      let groupedOptions: SelectOptionsType;\n      if (selectOptions.some(opt => opt.options)) {\n        groupedOptions = selectOptions.reduce(\n          (acc, group) => [...acc, ...group.options],\n          [] as SelectOptionsType,\n        );\n      }\n      const missingValues: SelectOptionsType = ensureIsArray(selectValue)\n        .filter(\n          opt => !hasOption(getValue(opt), groupedOptions || selectOptions),\n        )\n        .map(opt =>\n          isLabeledValue(opt) ? opt : { value: opt, label: String(opt) },\n        );\n      const result =\n        missingValues.length > 0\n          ? missingValues.concat(selectOptions)\n          : selectOptions;\n      return result.slice().sort(sortSelectedFirst);\n    }, [selectOptions, selectValue, sortSelectedFirst]);\n\n    const enabledOptions = useMemo(\n      () => visibleOptions.filter(option => !option.disabled),\n      [visibleOptions],\n    );\n\n    const selectAllEligible = useMemo(\n      () =>\n        visibleOptions.filter(\n          option =>\n            (hasOption(option.value, selectValue) || !option.disabled) &&\n            !option.isNewOption,\n        ),\n      [visibleOptions, selectValue],\n    );\n\n    const selectAllEnabled = useMemo(\n      () =>\n        !isSingleMode &&\n        allowSelectAll &&\n        selectOptions.length > 0 &&\n        enabledOptions.length > 1,\n      [\n        isSingleMode,\n        allowSelectAll,\n        selectOptions.length,\n        enabledOptions.length,\n      ],\n    );\n\n    const selectAllMode = useMemo(\n      () => ensureIsArray(selectValue).length === selectAllEligible.length + 1,\n      [selectValue, selectAllEligible],\n    );\n\n    const bulkSelectCounts = useMemo(() => {\n      const selectedValuesSet = new Set(\n        ensureIsArray(selectValue).map(getValue),\n      );\n      return visibleOptions.reduce(\n        (acc, option) => {\n          const isSelected = selectedValuesSet.has(option.value);\n          const isDisabled = option.disabled;\n          const isNew = option.isNewOption;\n\n          if (\n            (!isDisabled || isSelected) &&\n            ((isNew && isSelected) || !isNew)\n          ) {\n            acc.selectable += 1;\n          }\n          if (isSelected && !isDisabled) {\n            acc.deselectable += 1;\n          }\n          return acc;\n        },\n        { selectable: 0, deselectable: 0 },\n      );\n    }, [visibleOptions, selectValue]);\n\n    const handleOnSelect: SelectProps['onSelect'] = (selectedItem, option) => {\n      if (isSingleMode) {\n        // on select is fired in single value mode if the same value is selected\n        const valueChanged = !utilsIsEqual(\n          selectedItem,\n          selectValue as RawValue | AntdLabeledValue,\n          'value',\n        );\n        setSelectValue(selectedItem);\n        if (valueChanged) {\n          fireOnChange();\n        }\n      } else {\n        setSelectValue(previousState => {\n          const array = ensureIsArray(previousState);\n          const value = getValue(selectedItem);\n          if (!hasOption(value, array)) {\n            const result = [...array, selectedItem];\n            if (\n              result.length === selectAllEligible.length &&\n              selectAllEnabled\n            ) {\n              return isLabeledValue(selectedItem)\n                ? ([...result] as AntdLabeledValue[])\n                : ([...result] as (string | number)[]);\n            }\n            return result as AntdLabeledValue[];\n          }\n          return previousState;\n        });\n        fireOnChange();\n      }\n      onSelect?.(selectedItem, option);\n    };\n\n    const clear = () => {\n      if (isSingleMode) {\n        setSelectValue(undefined);\n      } else {\n        setSelectValue(\n          fullSelectOptions\n            .filter(\n              option => option.disabled && hasOption(option.value, selectValue),\n            )\n            .map(option =>\n              labelInValue\n                ? { label: option.label, value: option.value }\n                : option.value,\n            ),\n        );\n      }\n      fireOnChange();\n    };\n\n    const handleOnDeselect: SelectProps['onDeselect'] = (value, option) => {\n      if (Array.isArray(selectValue)) {\n        const array = (selectValue as AntdLabeledValue[]).filter(\n          element => getValue(element) !== getValue(value),\n        );\n        setSelectValue(array);\n\n        // removes new option\n        if (option.isNewOption) {\n          const updatedOptions = fullSelectOptions.filter(\n            option => getValue(option.value) !== getValue(value),\n          );\n          setSelectOptions(updatedOptions);\n          setVisibleOptions(updatedOptions);\n        }\n      }\n      fireOnChange();\n      onDeselect?.(value, option);\n    };\n\n    const handleFilterOption = (search: string, option: AntdLabeledValue) =>\n      handleFilterOptionHelper(search, option, optionFilterProps, filterOption);\n\n    const handleOnSearch = debounce((search: string) => {\n      const searchValue = search.trim();\n      setIsSearching(!!searchValue);\n\n      let updatedOptions = selectOptions;\n\n      if (allowNewOptions) {\n        const newOption = searchValue &&\n          !hasOption(searchValue, fullSelectOptions, true) && {\n            label: searchValue,\n            value: searchValue,\n            isNewOption: true,\n          };\n        const cleanSelectOptions = ensureIsArray(fullSelectOptions).filter(\n          opt => !opt.isNewOption || hasOption(opt.value, selectValue),\n        );\n        updatedOptions = newOption\n          ? [newOption, ...cleanSelectOptions]\n          : cleanSelectOptions;\n        setSelectOptions(updatedOptions);\n      }\n\n      const filteredOptions = updatedOptions.filter(\n        (option: AntdLabeledValue) => handleFilterOption(search, option),\n      );\n\n      setVisibleOptions(filteredOptions);\n      setInputValue(searchValue);\n      onSearch?.(searchValue);\n    }, FAST_DEBOUNCE);\n\n    useEffect(() => () => handleOnSearch.cancel(), [handleOnSearch]);\n\n    const handleOnDropdownVisibleChange = (isDropdownVisible: boolean) => {\n      setIsDropdownVisible(isDropdownVisible);\n\n      setVisibleOptions(fullSelectOptions);\n      // if no search input value, force sort options because it won't be sorted by\n      // `filterSort`.\n      if (isDropdownVisible && !inputValue && selectOptions.length > 1) {\n        if (!isEqual(initialOptionsSorted, selectOptions)) {\n          setSelectOptions(initialOptionsSorted);\n        }\n      }\n      if (!isDropdownVisible) {\n        setSelectOptions(initialOptionsSorted);\n      }\n      if (onDropdownVisibleChange) {\n        onDropdownVisibleChange(isDropdownVisible);\n      }\n    };\n\n    const handleSelectAll = useCallback(() => {\n      if (isSingleMode) return;\n\n      const optionsToSelect = isSearching\n        ? visibleOptions.filter(option => !option.isNewOption)\n        : enabledOptions;\n\n      const currentValues = ensureIsArray(selectValue);\n      const currentValuesSet = new Set(currentValues.map(getValue));\n\n      const newValues = [...currentValues] as AntdLabeledValue[];\n      optionsToSelect.forEach(option => {\n        if (!option.disabled && !currentValuesSet.has(option.value)) {\n          if (labelInValue) {\n            newValues.push({\n              label: option.label,\n              value: option.value,\n            });\n          } else {\n            newValues.push(option.value);\n          }\n        }\n      });\n\n      setSelectValue(newValues);\n      fireOnChange();\n    }, [\n      isSingleMode,\n      isSearching,\n      visibleOptions,\n      enabledOptions,\n      selectValue,\n      labelInValue,\n      fireOnChange,\n    ]);\n\n    const handleDeselectAll = useCallback(() => {\n      if (isSingleMode) return;\n\n      const deselectionValues = new Set(enabledOptions.map(opt => opt.value));\n\n      const newValues = ensureIsArray(selectValue).filter(item => {\n        const itemValue = getValue(item);\n        return !deselectionValues.has(itemValue);\n      }) as AntdLabeledValue[];\n\n      setSelectValue(newValues);\n      fireOnChange();\n    }, [isSingleMode, enabledOptions, selectValue, fireOnChange]);\n\n    const bulkSelectComponent = useMemo(\n      () => (\n        <StyledBulkActionsContainer size={0}>\n          <Button\n            type=\"link\"\n            buttonSize=\"xsmall\"\n            disabled={bulkSelectCounts.selectable === 0}\n            onMouseDown={e => {\n              e.preventDefault();\n              e.stopPropagation();\n              handleSelectAll();\n            }}\n          >\n            {`${t('Select all')} (${bulkSelectCounts.selectable})`}\n          </Button>\n          <Button\n            type=\"link\"\n            buttonSize=\"xsmall\"\n            disabled={bulkSelectCounts.deselectable === 0}\n            onMouseDown={e => {\n              e.preventDefault();\n              e.stopPropagation();\n              handleDeselectAll();\n            }}\n          >\n            {`${t('Deselect all')} (${bulkSelectCounts.deselectable})`}\n          </Button>\n        </StyledBulkActionsContainer>\n      ),\n      [\n        handleSelectAll,\n        handleDeselectAll,\n        bulkSelectCounts.selectable,\n        bulkSelectCounts.deselectable,\n      ],\n    );\n\n    const dropdownRender = (\n      originNode: ReactElement & { ref?: RefObject<HTMLElement> },\n    ) =>\n      dropDownRenderHelper(\n        originNode,\n        isDropdownVisible,\n        isLoading,\n        fullSelectOptions.length,\n        helperText,\n        undefined,\n        selectAllEnabled ? bulkSelectComponent : undefined,\n      );\n\n    const handleClear = () => {\n      clear();\n      if (onClear) {\n        onClear();\n      }\n    };\n\n    useEffect(() => {\n      // when `options` list is updated from component prop, reset states\n      setSelectOptions(initialOptions);\n      setVisibleOptions(initialOptions);\n    }, [initialOptions]);\n\n    useEffect(() => {\n      if (loading !== undefined && loading !== isLoading) {\n        setIsLoading(loading);\n      }\n    }, [isLoading, loading]);\n\n    useEffect(() => {\n      setSelectValue(value);\n    }, [value]);\n\n    const handleOnBlur = (event: FocusEvent<HTMLElement>) => {\n      setInputValue('');\n      onBlur?.(event);\n    };\n\n    const handleOnChange = useCallback(\n      (values: any, options: any) => {\n        // intercept onChange call to handle the select all case\n        // if the \"select all\" option is selected, we want to send all options to the onChange,\n        // otherwise we want to remove\n        let newValues = values;\n        let newOptions = options;\n        if (!isSingleMode) {\n          if (\n            ensureIsArray(values).length === selectAllEligible.length &&\n            selectAllMode\n          ) {\n            const array = selectAllEligible.filter(\n              option => hasOption(option.value, selectValue) && option.disabled,\n            );\n            newValues = mapValues(array, labelInValue);\n            newOptions = mapOptions(array);\n          }\n        }\n        onChange?.(newValues, newOptions);\n      },\n      [\n        isSingleMode,\n        labelInValue,\n        onChange,\n        selectAllEligible,\n        selectAllMode,\n        selectValue,\n      ],\n    );\n\n    useEffect(() => {\n      if (onChangeCount !== previousChangeCount) {\n        const array = ensureIsArray(selectValue);\n        const set = new Set(array.map(getValue));\n        const options = mapOptions(\n          fullSelectOptions.filter(opt => set.has(opt.value)),\n        );\n        if (isSingleMode) {\n          handleOnChange(selectValue, selectValue ? options[0] : undefined);\n        } else {\n          handleOnChange(array, options);\n        }\n      }\n    }, [\n      fullSelectOptions,\n      handleOnChange,\n      isSingleMode,\n      onChange,\n      onChangeCount,\n      previousChangeCount,\n      selectValue,\n    ]);\n\n    const shouldRenderChildrenOptions = useMemo(\n      () => selectAllEnabled || hasCustomLabels(options),\n      [selectAllEnabled, options],\n    );\n\n    const omittedCount = useMemo(() => {\n      const num_selected = ensureIsArray(selectValue).length;\n      const num_shown = maxTagCount as number;\n      return num_selected - num_shown - (selectAllMode ? 1 : 0);\n    }, [maxTagCount, selectAllMode, selectValue]);\n\n    const customMaxTagPlaceholder = () =>\n      `+ ${omittedCount > 0 ? omittedCount : 1} ...`;\n\n    // We can't remove the + tag so when Select All\n    // is the only item omitted, we subtract one from maxTagCount\n    let actualMaxTagCount = maxTagCount;\n    if (\n      actualMaxTagCount !== 'responsive' &&\n      omittedCount === 0 &&\n      selectAllMode\n    ) {\n      actualMaxTagCount -= 1;\n    }\n\n    const getPastedTextValue = useCallback(\n      (text: string) => {\n        const option = getOption(text, fullSelectOptions, true);\n        if (!option && !allowNewOptions) {\n          return undefined;\n        }\n        if (labelInValue) {\n          const value: AntdLabeledValue = {\n            label: text,\n            value: text,\n          };\n          if (option) {\n            value.label = isObject(option) ? option.label : option;\n            value.value = isObject(option) ? option.value! : option;\n          }\n          return value;\n        }\n        return option ? (isObject(option) ? option.value! : option) : text;\n      },\n      [allowNewOptions, fullSelectOptions, labelInValue],\n    );\n\n    const onPaste = (e: ClipboardEvent<HTMLInputElement>) => {\n      const pastedText = e.clipboardData.getData('text');\n      if (isSingleMode) {\n        const value = getPastedTextValue(pastedText);\n        if (value) {\n          setSelectValue(value);\n        }\n      } else {\n        const token = tokenSeparators.find(token => pastedText.includes(token));\n        const array = token ? uniq(pastedText.split(token)) : [pastedText];\n\n        const newOptions: SelectOptionsType = [];\n\n        const values = array\n          .map(item => {\n            const option = getOption(item, fullSelectOptions, true);\n            if (!option && allowNewOptions) {\n              const newOption = {\n                label: item,\n                value: item,\n                isNewOption: true,\n              };\n              newOptions.push(newOption);\n            }\n            return getPastedTextValue(item);\n          })\n          .filter(item => item !== undefined);\n\n        if (newOptions.length > 0) {\n          const updatedOptions = [...fullSelectOptions, ...newOptions];\n          setSelectOptions(updatedOptions);\n          setVisibleOptions(updatedOptions);\n        }\n        if (labelInValue) {\n          setSelectValue(previous => [\n            ...((previous || []) as AntdLabeledValue[]),\n            ...(values as AntdLabeledValue[]),\n          ]);\n        } else {\n          setSelectValue(previous => [\n            ...((previous || []) as string[]),\n            ...(values as string[]),\n          ]);\n        }\n      }\n      fireOnChange();\n    };\n\n    return (\n      <StyledContainer className={className} headerPosition={headerPosition}>\n        {header && (\n          <StyledHeader headerPosition={headerPosition}>{header}</StyledHeader>\n        )}\n        <StyledSelect\n          id={name}\n          allowClear={!isLoading && allowClear}\n          aria-label={ariaLabel}\n          autoClearSearchValue={autoClearSearchValue}\n          dropdownRender={dropdownRender}\n          filterOption={handleFilterOption}\n          filterSort={sortComparatorWithSearch}\n          getPopupContainer={\n            getPopupContainer || (triggerNode => triggerNode.parentNode)\n          }\n          headerPosition={headerPosition}\n          labelInValue={labelInValue}\n          maxTagCount={actualMaxTagCount}\n          maxTagPlaceholder={customMaxTagPlaceholder}\n          mode={mappedMode}\n          notFoundContent={isLoading ? t('Loading...') : notFoundContent}\n          onBlur={handleOnBlur}\n          onDeselect={handleOnDeselect}\n          onDropdownVisibleChange={handleOnDropdownVisibleChange}\n          // @ts-ignore\n          onPaste={onPaste}\n          onPopupScroll={undefined}\n          onSearch={shouldShowSearch ? handleOnSearch : undefined}\n          onSelect={handleOnSelect}\n          onClear={handleClear}\n          placeholder={placeholder}\n          showSearch={shouldShowSearch}\n          showArrow\n          tokenSeparators={tokenSeparators}\n          value={selectValue}\n          suffixIcon={getSuffixIcon(\n            isLoading,\n            shouldShowSearch,\n            isDropdownVisible,\n          )}\n          menuItemSelectedIcon={\n            invertSelection ? (\n              <StyledStopOutlined iconSize=\"m\" aria-label=\"stop\" />\n            ) : (\n              <StyledCheckOutlined iconSize=\"m\" aria-label=\"check\" />\n            )\n          }\n          options={shouldRenderChildrenOptions ? undefined : visibleOptions}\n          oneLine={oneLine}\n          tagRender={customTagRender}\n          {...props}\n          ref={ref}\n        >\n          {shouldRenderChildrenOptions && renderSelectOptions(visibleOptions)}\n        </StyledSelect>\n      </StyledContainer>\n    );\n  },\n);\n\nexport default Select;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}