{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { toQueryString } from 'src/utils/urlUtils';\nimport { api } from './queryApi';\nimport { useSchemas } from './schemas';\nconst tableApi = api.injectEndpoints({\n  endpoints: (builder) => ({\n    tables: builder.query({\n      providesTags: ['Tables'],\n      query: ({ dbId, catalog, schema, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId != null ? dbId : 'undefined'}/tables/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          schema_name: schema ? encodeURIComponent(schema) : '',\n          ...(catalog && { catalog_name: catalog })\n        },\n        transformResponse: ({ json }) => ({\n          options: json.result,\n          hasMore: json.count > json.result.length\n        })\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, schema } }) => ({\n        dbId,\n        schema\n      })\n    }),\n    tableMetadata: builder.query({\n      providesTags: (result) => result ?\n      [\n      { type: 'TableMetadatas', id: result.name },\n      { type: 'TableMetadatas', id: 'LIST' }] :\n\n      [{ type: 'TableMetadatas', id: 'LIST' }],\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/${toQueryString({\n          name: table,\n          catalog,\n          schema\n        })}`,\n        transformResponse: ({ json }) => json\n      })\n    }),\n    tableExtendedMetadata: builder.query({\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/extra/${toQueryString({ name: table, catalog, schema })}`,\n        transformResponse: ({ json }) => json\n      }),\n      providesTags: (result, error, { table }) => [\n      { type: 'TableMetadatas', id: table }]\n\n    })\n  })\n});\nexport const { useLazyTablesQuery, useTablesQuery, useLazyTableMetadataQuery, useLazyTableExtendedMetadataQuery, useTableMetadataQuery, useTableExtendedMetadataQuery, endpoints: tableEndpoints, util: tableApiUtil } = tableApi;\nexport function useTables(options) {\n  const { dbId, catalog, schema, onSuccess, onError } = options || {};\n  const isMountedRef = useRef(false);\n  const { currentData: schemaOptions, isFetching } = useSchemas({\n    dbId,\n    catalog: catalog || undefined\n  });\n  const schemaOptionsMap = useMemo(() => new Set(schemaOptions == null ? void 0 : schemaOptions.map(({ value }) => value)), [schemaOptions]);\n  const enabled = Boolean(dbId && schema && !isFetching && schemaOptionsMap.has(schema));\n  const result = useTablesQuery({ dbId, catalog, schema, forceRefresh: false }, {\n    skip: !enabled\n  });\n  const [trigger] = useLazyTablesQuery();\n  const handleOnSuccess = useEffectEvent((data, isRefetched) => {\n    onSuccess == null ? void 0 : onSuccess(data, isRefetched);\n  });\n  const handleOnError = useEffectEvent((error) => {\n    onError == null ? void 0 : onError(error);\n  });\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, catalog, schema, forceRefresh: true }).then(({ isSuccess, isError, data, error }) => {\n        if (isSuccess && data) {\n          handleOnSuccess(data, true);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      });\n    }\n  }, [dbId, catalog, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const { requestId, isSuccess, isError, isFetching, currentData, error, originalArgs } = result;\n      if (!(originalArgs != null && originalArgs.forceRefresh) && requestId && !isFetching) {\n        if (isSuccess && currentData) {\n          handleOnSuccess(currentData, false);\n        }\n        if (isError) {\n          handleOnError(error);\n        }\n      }\n    } else\n    {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n  return {\n    ...result,\n    refetch\n  };\n}__signature__(useTables, \"useRef{isMountedRef}\\nuseSchemas{{ currentData: schemaOptions, isFetching }}\\nuseMemo{schemaOptionsMap}\\nuseTablesQuery{result}\\nuseLazyTablesQuery{[trigger]}\\nuseEffectEvent{handleOnSuccess}\\nuseEffectEvent{handleOnError}\\nuseCallback{refetch}\\nuseEffect{}\", () => [useSchemas, useTablesQuery, useLazyTablesQuery, useEffectEvent, useEffectEvent]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(tableApi, \"tableApi\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useLazyTablesQuery, \"useLazyTablesQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useTablesQuery, \"useTablesQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useLazyTableMetadataQuery, \"useLazyTableMetadataQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useLazyTableExtendedMetadataQuery, \"useLazyTableExtendedMetadataQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useTableMetadataQuery, \"useTableMetadataQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useTableExtendedMetadataQuery, \"useTableExtendedMetadataQuery\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(tableEndpoints, \"tableEndpoints\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(tableApiUtil, \"tableApiUtil\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");reactHotLoader.register(useTables, \"useTables\", \"/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useCallback","useMemo","useEffect","useRef","useEffectEvent","toQueryString","api","useSchemas","tableApi","injectEndpoints","endpoints","builder","tables","query","providesTags","dbId","catalog","schema","forceRefresh","endpoint","urlParams","force","schema_name","encodeURIComponent","catalog_name","transformResponse","json","options","result","hasMore","count","length","serializeQueryArgs","queryArgs","tableMetadata","type","id","name","table","tableExtendedMetadata","error","useLazyTablesQuery","useTablesQuery","useLazyTableMetadataQuery","useLazyTableExtendedMetadataQuery","useTableMetadataQuery","useTableExtendedMetadataQuery","tableEndpoints","util","tableApiUtil","useTables","onSuccess","onError","isMountedRef","currentData","schemaOptions","isFetching","undefined","schemaOptionsMap","Set","map","value","enabled","Boolean","has","skip","trigger","handleOnSuccess","data","isRefetched","handleOnError","refetch","then","isSuccess","isError","current","requestId","originalArgs","__signature__","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/hooks/apiResources/tables.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useCallback, useMemo, useEffect, useRef } from 'react';\nimport useEffectEvent from 'src/hooks/useEffectEvent';\nimport { toQueryString } from 'src/utils/urlUtils';\nimport { api, JsonResponse } from './queryApi';\n\nimport { useSchemas } from './schemas';\n\nexport interface Table {\n  label: string;\n  value: string;\n  type: string;\n  extra?: {\n    certification?: {\n      certified_by: string;\n      details: string;\n    };\n    warning_markdown?: string;\n  };\n}\n\ntype QueryResponse = {\n  json: {\n    count: number;\n    result: Table[];\n  };\n  response: Response;\n};\n\nexport type Data = {\n  options: Table[];\n  hasMore: boolean;\n};\n\nexport type FetchTablesQueryParams = {\n  dbId?: string | number;\n  catalog?: string | null;\n  schema?: string;\n  forceRefresh?: boolean;\n  onSuccess?: (data: Data, isRefetched: boolean) => void;\n  onError?: (error: Response) => void;\n};\n\nexport type FetchTableMetadataQueryParams = {\n  dbId: string | number;\n  catalog?: string | null;\n  schema: string;\n  table: string;\n};\n\ntype ColumnKeyTypeType = 'pk' | 'fk' | 'index';\nexport interface Column {\n  name: string;\n  keys?: { type: ColumnKeyTypeType }[];\n  type: string;\n  comment?: string;\n  longType: string;\n}\n\nexport type TableMetaData = {\n  name: string;\n  partitions?: {\n    partitionQuery: string;\n    latest: object[];\n  };\n  metadata?: Record<string, string>;\n  indexes?: object[];\n  selectStar?: string;\n  view?: string;\n  columns: Column[];\n  comment?: string;\n};\n\ntype TableMetadataResponse = {\n  json: TableMetaData;\n  response: Response;\n};\n\nexport type TableExtendedMetadata = Record<string, string>;\n\ntype Params = Omit<FetchTablesQueryParams, 'forceRefresh'>;\n\nconst tableApi = api.injectEndpoints({\n  endpoints: builder => ({\n    tables: builder.query<Data, FetchTablesQueryParams>({\n      providesTags: ['Tables'],\n      query: ({ dbId, catalog, schema, forceRefresh }) => ({\n        endpoint: `/api/v1/database/${dbId ?? 'undefined'}/tables/`,\n        // TODO: Would be nice to add pagination in a follow-up. Needs endpoint changes.\n        urlParams: {\n          force: forceRefresh,\n          schema_name: schema ? encodeURIComponent(schema) : '',\n          ...(catalog && { catalog_name: catalog }),\n        },\n        transformResponse: ({ json }: QueryResponse) => ({\n          options: json.result,\n          hasMore: json.count > json.result.length,\n        }),\n      }),\n      serializeQueryArgs: ({ queryArgs: { dbId, schema } }) => ({\n        dbId,\n        schema,\n      }),\n    }),\n    tableMetadata: builder.query<TableMetaData, FetchTableMetadataQueryParams>({\n      providesTags: result =>\n        result\n          ? [\n              { type: 'TableMetadatas', id: result.name },\n              { type: 'TableMetadatas', id: 'LIST' },\n            ]\n          : [{ type: 'TableMetadatas', id: 'LIST' }],\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/${toQueryString({\n          name: table,\n          catalog,\n          schema,\n        })}`,\n        transformResponse: ({ json }: TableMetadataResponse) => json,\n      }),\n    }),\n    tableExtendedMetadata: builder.query<\n      TableExtendedMetadata,\n      FetchTableMetadataQueryParams\n    >({\n      query: ({ dbId, catalog, schema, table }) => ({\n        endpoint: `/api/v1/database/${dbId}/table_metadata/extra/${toQueryString(\n          { name: table, catalog, schema },\n        )}`,\n        transformResponse: ({ json }: JsonResponse) => json,\n      }),\n      providesTags: (result, error, { table }) => [\n        { type: 'TableMetadatas', id: table },\n      ],\n    }),\n  }),\n});\n\nexport const {\n  useLazyTablesQuery,\n  useTablesQuery,\n  useLazyTableMetadataQuery,\n  useLazyTableExtendedMetadataQuery,\n  useTableMetadataQuery,\n  useTableExtendedMetadataQuery,\n  endpoints: tableEndpoints,\n  util: tableApiUtil,\n} = tableApi;\n\nexport function useTables(options: Params) {\n  const { dbId, catalog, schema, onSuccess, onError } = options || {};\n  const isMountedRef = useRef(false);\n  const { currentData: schemaOptions, isFetching } = useSchemas({\n    dbId,\n    catalog: catalog || undefined,\n  });\n  const schemaOptionsMap = useMemo(\n    () => new Set(schemaOptions?.map(({ value }) => value)),\n    [schemaOptions],\n  );\n\n  const enabled = Boolean(\n    dbId && schema && !isFetching && schemaOptionsMap.has(schema),\n  );\n\n  const result = useTablesQuery(\n    { dbId, catalog, schema, forceRefresh: false },\n    {\n      skip: !enabled,\n    },\n  );\n  const [trigger] = useLazyTablesQuery();\n\n  const handleOnSuccess = useEffectEvent((data: Data, isRefetched: boolean) => {\n    onSuccess?.(data, isRefetched);\n  });\n\n  const handleOnError = useEffectEvent((error: Response) => {\n    onError?.(error);\n  });\n\n  const refetch = useCallback(() => {\n    if (enabled) {\n      trigger({ dbId, catalog, schema, forceRefresh: true }).then(\n        ({ isSuccess, isError, data, error }) => {\n          if (isSuccess && data) {\n            handleOnSuccess(data, true);\n          }\n          if (isError) {\n            handleOnError(error as Response);\n          }\n        },\n      );\n    }\n  }, [dbId, catalog, schema, enabled, handleOnSuccess, handleOnError, trigger]);\n\n  useEffect(() => {\n    if (isMountedRef.current) {\n      const {\n        requestId,\n        isSuccess,\n        isError,\n        isFetching,\n        currentData,\n        error,\n        originalArgs,\n      } = result;\n      if (!originalArgs?.forceRefresh && requestId && !isFetching) {\n        if (isSuccess && currentData) {\n          handleOnSuccess(currentData, false);\n        }\n        if (isError) {\n          handleOnError(error as Response);\n        }\n      }\n    } else {\n      isMountedRef.current = true;\n    }\n  }, [result, handleOnSuccess, handleOnError]);\n\n  return {\n    ...result,\n    refetch,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}