{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, GenericDataType, getCustomFormatter, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, tooltipHtml } from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport { DEFAULT_FORM_DATA } from './types';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, extractTooltipKeys, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds, getOverMaxHiddenFormatter } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum, reorderForecastSeries } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from '../Timeseries/transformers';\nimport { TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nconst getFormatter = (customFormatters, defaultFormatter, metrics, formatterKey, forcePercentFormat) => {var _getCustomFormatter;\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (_getCustomFormatter = getCustomFormatter(customFormatters, metrics, formatterKey)) != null ? _getCustomFormatter :\n  defaultFormatter;\n};\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, formData, queriesData, hooks, filterState, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { label_map: labelMap } = queriesData[0];\n  const { label_map: labelMapB } = queriesData[1];\n  const data1 = queriesData[0].data || [];\n  const data2 = queriesData[1].data || [];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1])\n  };\n  const { area, areaB, annotationLayers, colorScheme, timeShiftColor, contributionMode, legendOrientation, legendType, logAxis, logAxisSecondary, markerEnabled, markerEnabledB, markerSize, markerSizeB, opacity, opacityB, minorSplitLine, minorTicks, seriesType, seriesTypeB, showLegend, showValue, showValueB, stack, stackB, truncateXAxis, truncateYAxis, tooltipTimeFormat, yAxisFormat, currencyFormat, yAxisFormatSecondary, currencyFormatSecondary, xAxisTimeFormat, yAxisBounds, yAxisBoundsSecondary, yAxisIndex, yAxisIndexB, yAxisTitleSecondary, zoomable, richTooltip, tooltipSortByMetric, xAxisBounds, xAxisLabelRotation, groupby, groupbyB, xAxis: xAxisOrig, xAxisForceCategorical, xAxisTitle, yAxisTitle, xAxisTitleMargin, yAxisTitleMargin, yAxisTitlePosition, sliceId, timeGrainSqla, percentageThreshold, metrics = [], metricsB = [] } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel\n  });\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const formatter = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormat,\n    currency: currencyFormat\n  }) :\n  getNumberFormatter(yAxisFormat);\n  const formatterSecondary = contributionMode ?\n  getNumberFormatter(',.0%') :\n  currencyFormatSecondary != null && currencyFormatSecondary.symbol ?\n  new CurrencyFormatter({\n    d3Format: yAxisFormatSecondary,\n    currency: currencyFormatSecondary\n  }) :\n  getNumberFormatter(yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const customFormattersSecondary = buildCustomFormatters([...ensureIsArray(metrics), ...ensureIsArray(metricsB)], currencyFormats, columnFormats, yAxisFormatSecondary, currencyFormatSecondary);\n  const primarySeries = new Set();\n  const secondarySeries = new Set();\n  const mapSeriesIdToAxis = (seriesOption, index) => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id);\n    } else\n    {\n      primarySeries.add(seriesOption.id);\n    }\n  };\n  rawSeriesA.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndex));\n  rawSeriesB.forEach((seriesOption) => mapSeriesIdToAxis(seriesOption, yAxisIndexB));\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedDataA, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  const { totalStackedValues: totalStackedValuesB, thresholdValues: thresholdValuesB } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel\n  });\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data1, xAxisLabel, xAxisType, colorScale, sliceId));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data1, annotationData, colorScale, theme, sliceId));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data1, annotationData, colorScale, sliceId));\n    }\n  });\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(parseAxisBound);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  rawSeriesA.forEach((entry) => {var _labelMap$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const seriesFormatter = getFormatter(customFormatters, formatter, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      showValue,\n      stack: Boolean(stack),\n      stackIdSuffix: '\\na',\n      yAxisIndex,\n      filterState,\n      seriesKey: entry.name,\n      sliceId,\n      queryIndex: 0,\n      formatter: seriesType === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: yAxisMax,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesA,\n      totalStackedValues,\n      thresholdValues,\n      timeShiftColor\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  rawSeriesB.forEach((entry) => {var _labelMapB$seriesName;\n    const entryName = String(entry.name || '');\n    const seriesEntry = inverted[entryName] || entryName;\n    const seriesName = `${seriesEntry} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesEntry, array);\n    const seriesFormatter = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, labelMapB == null ? void 0 : (_labelMapB$seriesName = labelMapB[seriesName]) == null ? void 0 : _labelMapB$seriesName[0], !!contributionMode);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area: areaB,\n      markerEnabled: markerEnabledB,\n      markerSize: markerSizeB,\n      areaOpacity: opacityB,\n      seriesType: seriesTypeB,\n      showValue: showValueB,\n      stack: Boolean(stackB),\n      stackIdSuffix: '\\nb',\n      yAxisIndex: yAxisIndexB,\n      filterState,\n      seriesKey: primarySeries.has(entry.name) ?\n      `${entry.name} (1)` :\n      entry.name,\n      sliceId,\n      queryIndex: 1,\n      formatter: seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      getOverMaxHiddenFormatter({\n        max: maxSecondary,\n        formatter: seriesFormatter\n      }) :\n      seriesFormatter,\n      showValueIndexes: showValueIndexesB,\n      totalStackedValues: totalStackedValuesB,\n      thresholdValues: thresholdValuesB,\n      timeShiftColor\n    });\n    if (transformedSeries)\n    series.push(transformedSeries);\n  });\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n    if (minSecondary === undefined)\n    minSecondary = 0;\n    if (maxSecondary === undefined)\n    maxSecondary = 1;\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n  const chartPadding = getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, null, addXAxisTitleOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin));\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation\n      },\n      minorTick: { show: minorTicks },\n      minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n      TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n      0,\n      ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType === EchartsTimeseriesSeriesType.Bar ||\n      seriesTypeB === EchartsTimeseriesSeriesType.Bar ?\n      EchartsTimeseriesSeriesType.Bar :\n      undefined)\n    },\n    yAxis: [\n    {\n      ...defaultYAxis,\n      type: logAxis ? 'log' : 'value',\n      min: yAxisMin,\n      max: yAxisMax,\n      minorTick: { show: minorTicks },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metrics, !!contributionMode, customFormatters, formatter, yAxisFormat)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitle,\n      nameGap: convertInteger(yAxisTitleMargin),\n      nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n      alignTicks\n    },\n    {\n      ...defaultYAxis,\n      type: logAxisSecondary ? 'log' : 'value',\n      min: minSecondary,\n      max: maxSecondary,\n      minorTick: { show: minorTicks },\n      splitLine: { show: false },\n      minorSplitLine: { show: minorSplitLine },\n      axisLabel: {\n        formatter: getYAxisFormatter(metricsB, !!contributionMode, customFormattersSecondary, formatterSecondary, yAxisFormatSecondary)\n      },\n      scale: truncateYAxis,\n      name: yAxisTitleSecondary,\n      alignTicks\n    }],\n\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {\n        const xValue = richTooltip ?\n        params[0].value[0] :\n        params.value[0];\n        const forecastValue = richTooltip ? params : [params];\n        const sortedKeys = extractTooltipKeys(forecastValue,\n        // horizontal mode is not supported in mixed series chart\n        1, richTooltip, tooltipSortByMetric);\n        const rows = [];\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue);\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys.\n        filter((key) => keys.includes(key)).\n        forEach((key) => {\n          const value = forecastValues[key];\n          // if there are no dimensions, key is a verbose name of a metric,\n          // otherwise it is a comma separated string where the first part is metric name\n          let formatterKey;\n          if (primarySeries.has(key)) {var _labelMap$key;\n            formatterKey =\n            groupby.length === 0 ? inverted[key] : (_labelMap$key = labelMap[key]) == null ? void 0 : _labelMap$key[0];\n          } else\n          {var _labelMapB$key;\n            formatterKey =\n            groupbyB.length === 0 ? inverted[key] : (_labelMapB$key = labelMapB[key]) == null ? void 0 : _labelMapB$key[0];\n          }\n          const tooltipFormatter = getFormatter(customFormatters, formatter, metrics, formatterKey, !!contributionMode);\n          const tooltipFormatterSecondary = getFormatter(customFormattersSecondary, formatterSecondary, metricsB, formatterKey, !!contributionMode);\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter: primarySeries.has(key) ?\n            tooltipFormatter :\n            tooltipFormatterSecondary\n          });\n          rows.push(row);\n          if (key === focusedSeries) {\n            focusedRow = rows.length - 1;\n          }\n        });\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable),\n      // @ts-ignore\n      data: rawSeriesA.\n      concat(rawSeriesB).\n      filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n      ForecastSeriesEnum.Observation).\n      map((entry) => entry.name || '').\n      concat(extractAnnotationLabels(annotationLayers, annotationData))\n    },\n    series: dedupSeries(reorderForecastSeries(series)),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom'\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getFormatter, \"getFormatter\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","AxisType","buildCustomFormatters","CategoricalColorNamespace","CurrencyFormatter","ensureIsArray","GenericDataType","getCustomFormatter","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","tooltipHtml","getOriginalSeries","DEFAULT_FORM_DATA","EchartsTimeseriesSeriesType","ForecastSeriesEnum","parseAxisBound","dedupSeries","extractDataTotalValues","extractSeries","extractShowValueIndexes","extractTooltipKeys","getAxisType","getColtypesMapping","getLegendProps","getMinAndMaxFromBounds","getOverMaxHiddenFormatter","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","reorderForecastSeries","convertInteger","defaultGrid","defaultYAxis","getPadding","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","TIMEGRAIN_TO_TIMESTAMP","TIMESERIES_CONSTANTS","getDefaultTooltip","getTooltipTimeFormatter","getXAxisFormatter","getYAxisFormatter","getFormatter","customFormatters","defaultFormatter","metrics","formatterKey","forcePercentFormat","_getCustomFormatter","transformProps","chartProps","_chartProps$rawFormDa","_dataTypes$xAxisLabel","_chartProps$rawFormDa2","width","height","formData","queriesData","hooks","filterState","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","currencyFormats","columnFormats","label_map","labelMap","labelMapB","data1","data","data2","annotationData","coltypeMapping","area","areaB","annotationLayers","colorScheme","timeShiftColor","contributionMode","legendOrientation","legendType","logAxis","logAxisSecondary","markerEnabled","markerEnabledB","markerSize","markerSizeB","opacity","opacityB","minorSplitLine","minorTicks","seriesType","seriesTypeB","showLegend","showValue","showValueB","stack","stackB","truncateXAxis","truncateYAxis","tooltipTimeFormat","yAxisFormat","currencyFormat","yAxisFormatSecondary","currencyFormatSecondary","xAxisTimeFormat","yAxisBounds","yAxisBoundsSecondary","yAxisIndex","yAxisIndexB","yAxisTitleSecondary","zoomable","richTooltip","tooltipSortByMetric","xAxisBounds","xAxisLabelRotation","groupby","groupbyB","xAxis","xAxisOrig","xAxisForceCategorical","xAxisTitle","yAxisTitle","xAxisTitleMargin","yAxisTitleMargin","yAxisTitlePosition","sliceId","timeGrainSqla","percentageThreshold","metricsB","refs","colorScale","getScale","xAxisLabel","rawFormData","x_axis","rebasedDataA","rawSeriesA","fillNeighborValue","rebasedDataB","rawSeriesB","dataTypes","xAxisDataType","xAxisType","series","formatter","symbol","d3Format","currency","formatterSecondary","customFormattersSecondary","primarySeries","Set","secondarySeries","mapSeriesIdToAxis","seriesOption","index","add","id","forEach","showValueIndexesA","showValueIndexesB","totalStackedValues","thresholdValues","xAxisCol","totalStackedValuesB","thresholdValuesB","Boolean","filter","layer","show","push","xAxisMin","xAxisMax","map","yAxisMin","yAxisMax","minSecondary","maxSecondary","array","time_compare","inverted","_invert","entry","_labelMap$seriesName","entryName","String","name","seriesName","colorScaleKey","seriesFormatter","transformedSeries","areaOpacity","stackIdSuffix","seriesKey","queryIndex","Bar","max","showValueIndexes","_labelMapB$seriesName","seriesEntry","has","tooltipFormatter","Temporal","xAxisFormatter","addYAxisTitleOffset","addXAxisTitleOffset","chartPadding","setDataMask","onContextMenu","alignTicks","echartOptions","useUTC","grid","type","nameGap","nameLocation","axisLabel","rotate","minorTick","minInterval","Time","yAxis","min","scale","splitLine","tooltip","trigger","params","xValue","value","forecastValue","sortedKeys","rows","forecastValues","keys","Object","focusedRow","key","includes","_labelMap$key","length","_labelMapB$key","tooltipFormatterSecondary","row","legend","concat","Observation","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","bottom","zoomBottom","onFocusedSeries","seriesBreakdown","selectedValues","xValueFormatter","label","reactHotLoader","register","leaveModule"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/MixedTimeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  AxisType,\n  buildCustomFormatters,\n  CategoricalColorNamespace,\n  CurrencyFormatter,\n  ensureIsArray,\n  GenericDataType,\n  getCustomFormatter,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  QueryFormData,\n  QueryFormMetric,\n  TimeseriesChartDataResponseResult,\n  TimeseriesDataRecord,\n  tooltipHtml,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { getOriginalSeries } from '@superset-ui/chart-controls';\nimport type { EChartsCoreOption } from 'echarts/core';\nimport type { SeriesOption } from 'echarts';\nimport {\n  DEFAULT_FORM_DATA,\n  EchartsMixedTimeseriesChartTransformedProps,\n  EchartsMixedTimeseriesFormData,\n  EchartsMixedTimeseriesProps,\n} from './types';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  Refs,\n} from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport {\n  dedupSeries,\n  extractDataTotalValues,\n  extractSeries,\n  extractShowValueIndexes,\n  extractTooltipKeys,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  getMinAndMaxFromBounds,\n  getOverMaxHiddenFormatter,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n  reorderForecastSeries,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getPadding,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from '../Timeseries/transformers';\nimport { TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport {\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  getYAxisFormatter,\n} from '../utils/formatters';\n\nconst getFormatter = (\n  customFormatters: Record<string, ValueFormatter>,\n  defaultFormatter: ValueFormatter,\n  metrics: QueryFormMetric[],\n  formatterKey: string,\n  forcePercentFormat: boolean,\n) => {\n  if (forcePercentFormat) {\n    return getNumberFormatter(',.0%');\n  }\n  return (\n    getCustomFormatter(customFormatters, metrics, formatterKey) ??\n    defaultFormatter\n  );\n};\n\nexport default function transformProps(\n  chartProps: EchartsMixedTimeseriesProps,\n): EchartsMixedTimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    currencyFormats = {},\n    columnFormats = {},\n  } = datasource;\n  const { label_map: labelMap } =\n    queriesData[0] as TimeseriesChartDataResponseResult;\n  const { label_map: labelMapB } =\n    queriesData[1] as TimeseriesChartDataResponseResult;\n  const data1 = (queriesData[0].data || []) as TimeseriesDataRecord[];\n  const data2 = (queriesData[1].data || []) as TimeseriesDataRecord[];\n  const annotationData = getAnnotationData(chartProps);\n  const coltypeMapping = {\n    ...getColtypesMapping(queriesData[0]),\n    ...getColtypesMapping(queriesData[1]),\n  };\n  const {\n    area,\n    areaB,\n    annotationLayers,\n    colorScheme,\n    timeShiftColor,\n    contributionMode,\n    legendOrientation,\n    legendType,\n    logAxis,\n    logAxisSecondary,\n    markerEnabled,\n    markerEnabledB,\n    markerSize,\n    markerSizeB,\n    opacity,\n    opacityB,\n    minorSplitLine,\n    minorTicks,\n    seriesType,\n    seriesTypeB,\n    showLegend,\n    showValue,\n    showValueB,\n    stack,\n    stackB,\n    truncateXAxis,\n    truncateYAxis,\n    tooltipTimeFormat,\n    yAxisFormat,\n    currencyFormat,\n    yAxisFormatSecondary,\n    currencyFormatSecondary,\n    xAxisTimeFormat,\n    yAxisBounds,\n    yAxisBoundsSecondary,\n    yAxisIndex,\n    yAxisIndexB,\n    yAxisTitleSecondary,\n    zoomable,\n    richTooltip,\n    tooltipSortByMetric,\n    xAxisBounds,\n    xAxisLabelRotation,\n    groupby,\n    groupbyB,\n    xAxis: xAxisOrig,\n    xAxisForceCategorical,\n    xAxisTitle,\n    yAxisTitle,\n    xAxisTitleMargin,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    sliceId,\n    timeGrainSqla,\n    percentageThreshold,\n    metrics = [],\n    metricsB = [],\n  }: EchartsMixedTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n\n  const refs: Refs = {};\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n\n  let xAxisLabel = getXAxisLabel(\n    chartProps.rawFormData as QueryFormData,\n  ) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n\n  const rebasedDataA = rebaseForecastDatum(data1, verboseMap);\n  const [rawSeriesA] = extractSeries(rebasedDataA, {\n    fillNeighborValue: stack ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n  const rebasedDataB = rebaseForecastDatum(data2, verboseMap);\n  const [rawSeriesB] = extractSeries(rebasedDataB, {\n    fillNeighborValue: stackB ? 0 : undefined,\n    xAxis: xAxisLabel,\n  });\n\n  const dataTypes = getColtypesMapping(queriesData[0]);\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series: SeriesOption[] = [];\n  const formatter = contributionMode\n    ? getNumberFormatter(',.0%')\n    : currencyFormat?.symbol\n      ? new CurrencyFormatter({\n          d3Format: yAxisFormat,\n          currency: currencyFormat,\n        })\n      : getNumberFormatter(yAxisFormat);\n  const formatterSecondary = contributionMode\n    ? getNumberFormatter(',.0%')\n    : currencyFormatSecondary?.symbol\n      ? new CurrencyFormatter({\n          d3Format: yAxisFormatSecondary,\n          currency: currencyFormatSecondary,\n        })\n      : getNumberFormatter(yAxisFormatSecondary);\n  const customFormatters = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n  const customFormattersSecondary = buildCustomFormatters(\n    [...ensureIsArray(metrics), ...ensureIsArray(metricsB)],\n    currencyFormats,\n    columnFormats,\n    yAxisFormatSecondary,\n    currencyFormatSecondary,\n  );\n\n  const primarySeries = new Set<string>();\n  const secondarySeries = new Set<string>();\n  const mapSeriesIdToAxis = (\n    seriesOption: SeriesOption,\n    index?: number,\n  ): void => {\n    if (index === 1) {\n      secondarySeries.add(seriesOption.id as string);\n    } else {\n      primarySeries.add(seriesOption.id as string);\n    }\n  };\n  rawSeriesA.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndex),\n  );\n  rawSeriesB.forEach(seriesOption =>\n    mapSeriesIdToAxis(seriesOption, yAxisIndexB),\n  );\n  const showValueIndexesA = extractShowValueIndexes(rawSeriesA, {\n    stack,\n  });\n  const showValueIndexesB = extractShowValueIndexes(rawSeriesB, {\n    stack,\n  });\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedDataA,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n    },\n  );\n  const {\n    totalStackedValues: totalStackedValuesB,\n    thresholdValues: thresholdValuesB,\n  } = extractDataTotalValues(rebasedDataB, {\n    stack: Boolean(stackB),\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n  });\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data1,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data1,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data1,\n            annotationData,\n            colorScale,\n            sliceId,\n          ),\n        );\n      }\n    });\n\n  // yAxisBounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  let [minSecondary, maxSecondary] = (yAxisBoundsSecondary || []).map(\n    parseAxisBound,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  rawSeriesA.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const seriesFormatter = getFormatter(\n      customFormatters,\n      formatter,\n      metrics,\n      labelMap?.[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        showValue,\n        stack: Boolean(stack),\n        stackIdSuffix: '\\na',\n        yAxisIndex,\n        filterState,\n        seriesKey: entry.name,\n        sliceId,\n        queryIndex: 0,\n        formatter:\n          seriesType === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max: yAxisMax,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesA,\n        totalStackedValues,\n        thresholdValues,\n        timeShiftColor,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  rawSeriesB.forEach(entry => {\n    const entryName = String(entry.name || '');\n    const seriesEntry = inverted[entryName] || entryName;\n    const seriesName = `${seriesEntry} (1)`;\n    const colorScaleKey = getOriginalSeries(seriesEntry, array);\n\n    const seriesFormatter = getFormatter(\n      customFormattersSecondary,\n      formatterSecondary,\n      metricsB,\n      labelMapB?.[seriesName]?.[0],\n      !!contributionMode,\n    );\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area: areaB,\n        markerEnabled: markerEnabledB,\n        markerSize: markerSizeB,\n        areaOpacity: opacityB,\n        seriesType: seriesTypeB,\n        showValue: showValueB,\n        stack: Boolean(stackB),\n        stackIdSuffix: '\\nb',\n        yAxisIndex: yAxisIndexB,\n        filterState,\n        seriesKey: primarySeries.has(entry.name as string)\n          ? `${entry.name} (1)`\n          : entry.name,\n        sliceId,\n        queryIndex: 1,\n        formatter:\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n            ? getOverMaxHiddenFormatter({\n                max: maxSecondary,\n                formatter: seriesFormatter,\n              })\n            : seriesFormatter,\n        showValueIndexes: showValueIndexesB,\n        totalStackedValues: totalStackedValuesB,\n        thresholdValues: thresholdValuesB,\n        timeShiftColor,\n      },\n    );\n    if (transformedSeries) series.push(transformedSeries);\n  });\n\n  // default to 0-100% range when doing row-level contribution chart\n  if (contributionMode === 'row' && stack) {\n    if (yAxisMin === undefined) yAxisMin = 0;\n    if (yAxisMax === undefined) yAxisMax = 1;\n    if (minSecondary === undefined) minSecondary = 0;\n    if (maxSecondary === undefined) maxSecondary = 1;\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const addYAxisTitleOffset = !!(yAxisTitle || yAxisTitleSecondary);\n  const addXAxisTitleOffset = !!xAxisTitle;\n\n  const chartPadding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisTitleOffset,\n    zoomable,\n    null,\n    addXAxisTitleOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const alignTicks = yAxisIndex !== yAxisIndexB;\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...chartPadding,\n    },\n    xAxis: {\n      type: xAxisType,\n      name: xAxisTitle,\n      nameGap: convertInteger(xAxisTitleMargin),\n      nameLocation: 'middle',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        rotate: xAxisLabelRotation,\n      },\n      minorTick: { show: minorTicks },\n      minInterval:\n        xAxisType === AxisType.Time && timeGrainSqla\n          ? TIMEGRAIN_TO_TIMESTAMP[\n              timeGrainSqla as keyof typeof TIMEGRAIN_TO_TIMESTAMP\n            ]\n          : 0,\n      ...getMinAndMaxFromBounds(\n        xAxisType,\n        truncateXAxis,\n        xAxisMin,\n        xAxisMax,\n        seriesType === EchartsTimeseriesSeriesType.Bar ||\n          seriesTypeB === EchartsTimeseriesSeriesType.Bar\n          ? EchartsTimeseriesSeriesType.Bar\n          : undefined,\n      ),\n    },\n    yAxis: [\n      {\n        ...defaultYAxis,\n        type: logAxis ? 'log' : 'value',\n        min: yAxisMin,\n        max: yAxisMax,\n        minorTick: { show: minorTicks },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metrics,\n            !!contributionMode,\n            customFormatters,\n            formatter,\n            yAxisFormat,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitle,\n        nameGap: convertInteger(yAxisTitleMargin),\n        nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n        alignTicks,\n      },\n      {\n        ...defaultYAxis,\n        type: logAxisSecondary ? 'log' : 'value',\n        min: minSecondary,\n        max: maxSecondary,\n        minorTick: { show: minorTicks },\n        splitLine: { show: false },\n        minorSplitLine: { show: minorSplitLine },\n        axisLabel: {\n          formatter: getYAxisFormatter(\n            metricsB,\n            !!contributionMode,\n            customFormattersSecondary,\n            formatterSecondary,\n            yAxisFormatSecondary,\n          ),\n        },\n        scale: truncateYAxis,\n        name: yAxisTitleSecondary,\n        alignTicks,\n      },\n    ],\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const xValue: number = richTooltip\n          ? params[0].value[0]\n          : params.value[0];\n        const forecastValue: any[] = richTooltip ? params : [params];\n\n        const sortedKeys = extractTooltipKeys(\n          forecastValue,\n          // horizontal mode is not supported in mixed series chart\n          1,\n          richTooltip,\n          tooltipSortByMetric,\n        );\n\n        const rows: string[][] = [];\n        const forecastValues =\n          extractForecastValuesFromTooltipParams(forecastValue);\n\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys\n          .filter(key => keys.includes(key))\n          .forEach(key => {\n            const value = forecastValues[key];\n            // if there are no dimensions, key is a verbose name of a metric,\n            // otherwise it is a comma separated string where the first part is metric name\n            let formatterKey;\n            if (primarySeries.has(key)) {\n              formatterKey =\n                groupby.length === 0 ? inverted[key] : labelMap[key]?.[0];\n            } else {\n              formatterKey =\n                groupbyB.length === 0 ? inverted[key] : labelMapB[key]?.[0];\n            }\n            const tooltipFormatter = getFormatter(\n              customFormatters,\n              formatter,\n              metrics,\n              formatterKey,\n              !!contributionMode,\n            );\n            const tooltipFormatterSecondary = getFormatter(\n              customFormattersSecondary,\n              formatterSecondary,\n              metricsB,\n              formatterKey,\n              !!contributionMode,\n            );\n            const row = formatForecastTooltipSeries({\n              ...value,\n              seriesName: key,\n              formatter: primarySeries.has(key)\n                ? tooltipFormatter\n                : tooltipFormatterSecondary,\n            });\n            rows.push(row);\n            if (key === focusedSeries) {\n              focusedRow = rows.length - 1;\n            }\n          });\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n      ),\n      // @ts-ignore\n      data: rawSeriesA\n        .concat(rawSeriesB)\n        .filter(\n          entry =>\n            extractForecastSeriesContext((entry.name || '') as string).type ===\n            ForecastSeriesEnum.Observation,\n        )\n        .map(entry => entry.name || '')\n        .concat(extractAnnotationLabels(annotationLayers, annotationData)),\n    },\n    series: dedupSeries(reorderForecastSeries(series) as SeriesOption[]),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          yAxisIndex: false,\n          title: {\n            zoom: 'zoom area',\n            back: 'restore zoom',\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap,\n    labelMapB,\n    groupby,\n    groupbyB,\n    seriesBreakdown: rawSeriesA.length,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping,\n  };\n}\n"],"mappings":"qCAAA;;;;;;;;;;;;;;;;;;AAkBA,gDAAAA,WAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAD,WAAA,GAAAE,SAAA,CAAAF,WAAA,IAAAA,WAAA,CAAAG,MAAA,WAAAC,aAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAI,OAAA,CAAAC,SAAA,aAAAC,CAAA,UAAAA,CAAA;;AAEA,SAEEC,QAAQ,EACRC,qBAAqB,EACrBC,yBAAyB,EACzBC,iBAAiB,EACjBC,aAAa,EACbC,eAAe,EACfC,kBAAkB,EAClBC,kBAAkB,EAClBC,aAAa,EACbC,SAAS,EACTC,sBAAsB,EACtBC,wBAAwB,EACxBC,yBAAyB,EACzBC,gBAAgB,EAChBC,2BAA2B,EAK3BC,WAAW,QAEN,mBAAmB;AAC1B,SAASC,iBAAiB,QAAQ,6BAA6B;AAG/D,SACEC,iBAAiB,QAIZ,SAAS;AAChB,SACEC,2BAA2B,EAC3BC,kBAAkB,QAEb,UAAU;AACjB,SAASC,cAAc,QAAQ,mBAAmB;AAClD,SACEC,WAAW,EACXC,sBAAsB,EACtBC,aAAa,EACbC,uBAAuB,EACvBC,kBAAkB,EAClBC,WAAW,EACXC,kBAAkB,EAClBC,cAAc,EACdC,sBAAsB,EACtBC,yBAAyB,QACpB,iBAAiB;AACxB,SACEC,uBAAuB,EACvBC,iBAAiB,QACZ,qBAAqB;AAC5B,SACEC,4BAA4B,EAC5BC,sCAAsC,EACtCC,2BAA2B,EAC3BC,mBAAmB,EACnBC,qBAAqB,QAChB,mBAAmB;AAC1B,SAASC,cAAc,QAAQ,yBAAyB;AACxD,SAASC,WAAW,EAAEC,YAAY,QAAQ,aAAa;AACvD,SACEC,UAAU,EACVC,wBAAwB,EACxBC,0BAA0B,EAC1BC,2BAA2B,EAC3BC,eAAe,EACfC,6BAA6B,QACxB,4BAA4B;AACnC,SAASC,sBAAsB,EAAEC,oBAAoB,QAAQ,cAAc;AAC3E,SAASC,iBAAiB,QAAQ,kBAAkB;AACpD,SACEC,uBAAuB,EACvBC,iBAAiB,EACjBC,iBAAiB,QACZ,qBAAqB;AAE5B,MAAMC,YAAY,GAAGA,CACnBC,gBAAgD,EAChDC,gBAAgC,EAChCC,OAA0B,EAC1BC,YAAoB,EACpBC,kBAA2B,KACzB,KAAAC,mBAAA;EACF,IAAID,kBAAkB,EAAE;IACtB,OAAOnD,kBAAkB,CAAC,MAAM,CAAC;;EAEnC,QAAAoD,mBAAA,GACErD,kBAAkB,CAACgD,gBAAgB,EAAEE,OAAO,EAAEC,YAAY,CAAC,YAAAE,mBAAA;EAC3DJ,gBAAgB;AAEpB,CAAC;AAED,eAAc,SAAUK,cAAcA,CACpCC,UAAuC,OAAAC,qBAAA,EAAAC,qBAAA,EAAAC,sBAAA;EAEvC,MAAM,EACJC,KAAK,EACLC,MAAM,EACNC,QAAQ,EACRC,WAAW,EACXC,KAAK,EACLC,WAAW,EACXC,UAAU,EACVC,KAAK,EACLC,aAAa,EACbC,gBAAgB,EACjB,GAAGb,UAAU;EAEd,IAAIc,aAAa,GAAkB,IAAI;EAEvC,MAAM,EACJC,UAAU,GAAG,EAAE,EACfC,eAAe,GAAG,EAAE,EACpBC,aAAa,GAAG,EAAE,EACnB,GAAGP,UAAU;EACd,MAAM,EAAEQ,SAAS,EAAEC,QAAQ,EAAE,GAC3BZ,WAAW,CAAC,CAAC,CAAsC;EACrD,MAAM,EAAEW,SAAS,EAAEE,SAAS,EAAE,GAC5Bb,WAAW,CAAC,CAAC,CAAsC;EACrD,MAAMc,KAAK,GAAId,WAAW,CAAC,CAAC,CAAC,CAACe,IAAI,IAAI,EAA6B;EACnE,MAAMC,KAAK,GAAIhB,WAAW,CAAC,CAAC,CAAC,CAACe,IAAI,IAAI,EAA6B;EACnE,MAAME,cAAc,GAAGrD,iBAAiB,CAAC6B,UAAU,CAAC;EACpD,MAAMyB,cAAc,GAAG;IACrB,GAAG3D,kBAAkB,CAACyC,WAAW,CAAC,CAAC,CAAC,CAAC;IACrC,GAAGzC,kBAAkB,CAACyC,WAAW,CAAC,CAAC,CAAC;GACrC;EACD,MAAM,EACJmB,IAAI,EACJC,KAAK,EACLC,gBAAgB,EAChBC,WAAW,EACXC,cAAc,EACdC,gBAAgB,EAChBC,iBAAiB,EACjBC,UAAU,EACVC,OAAO,EACPC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,EACdC,UAAU,EACVC,WAAW,EACXC,OAAO,EACPC,QAAQ,EACRC,cAAc,EACdC,UAAU,EACVC,UAAU,EACVC,WAAW,EACXC,UAAU,EACVC,SAAS,EACTC,UAAU,EACVC,KAAK,EACLC,MAAM,EACNC,aAAa,EACbC,aAAa,EACbC,iBAAiB,EACjBC,WAAW,EACXC,cAAc,EACdC,oBAAoB,EACpBC,uBAAuB,EACvBC,eAAe,EACfC,WAAW,EACXC,oBAAoB,EACpBC,UAAU,EACVC,WAAW,EACXC,mBAAmB,EACnBC,QAAQ,EACRC,WAAW,EACXC,mBAAmB,EACnBC,WAAW,EACXC,kBAAkB,EAClBC,OAAO,EACPC,QAAQ,EACRC,KAAK,EAAEC,SAAS,EAChBC,qBAAqB,EACrBC,UAAU,EACVC,UAAU,EACVC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,EAClBC,OAAO,EACPC,aAAa,EACbC,mBAAmB,EACnBtF,OAAO,GAAG,EAAE,EACZuF,QAAQ,GAAG,EAAE,EACd,GAAmC,EAAE,GAAG9H,iBAAiB,EAAE,GAAGkD,QAAQ,EAAE;EAEzE,MAAM6E,IAAI,GAAS,EAAE;EACrB,MAAMC,UAAU,GAAG/I,yBAAyB,CAACgJ,QAAQ,CAACxD,WAAqB,CAAC;EAE5E,IAAIyD,UAAU,GAAG3I,aAAa,CAC5BqD,UAAU,CAACuF,WAA4B,CAC9B;EACX,IACEvI,gBAAgB,EAAAiD,qBAAA,GAACD,UAAU,CAACuF,WAAW,qBAAtBtF,qBAAA,CAAwBuF,MAAM,CAAC;EAChD5I,SAAS,CAACmE,UAAU,CAACuE,UAAU,CAAC,CAAC,EACjC;IACAA,UAAU,GAAGvE,UAAU,CAACuE,UAAU,CAAC;;EAGrC,MAAMG,YAAY,GAAGlH,mBAAmB,CAAC8C,KAAK,EAAEN,UAAU,CAAC;EAC3D,MAAM,CAAC2E,UAAU,CAAC,GAAGhI,aAAa,CAAC+H,YAAY,EAAE;IAC/CE,iBAAiB,EAAE1C,KAAK,GAAG,CAAC,GAAGpH,SAAS;IACxC0I,KAAK,EAAEe;GACR,CAAC;EACF,MAAMM,YAAY,GAAGrH,mBAAmB,CAACgD,KAAK,EAAER,UAAU,CAAC;EAC3D,MAAM,CAAC8E,UAAU,CAAC,GAAGnI,aAAa,CAACkI,YAAY,EAAE;IAC/CD,iBAAiB,EAAEzC,MAAM,GAAG,CAAC,GAAGrH,SAAS;IACzC0I,KAAK,EAAEe;GACR,CAAC;EAEF,MAAMQ,SAAS,GAAGhI,kBAAkB,CAACyC,WAAW,CAAC,CAAC,CAAC,CAAC;EACpD,MAAMwF,aAAa,IAAA7F,qBAAA,GAAG4F,SAAS,oBAATA,SAAS,CAAGR,UAAU,CAAC,YAAApF,qBAAA,GAAI4F,SAAS,oBAATA,SAAS,CAAGtB,SAAS,CAAC;EACvE,MAAMwB,SAAS,GAAGnI,WAAW,CAACoF,KAAK,EAAEwB,qBAAqB,EAAEsB,aAAa,CAAC;EAC1E,MAAME,MAAM,GAAmB,EAAE;EACjC,MAAMC,SAAS,GAAGnE,gBAAgB;EAC9BrF,kBAAkB,CAAC,MAAM,CAAC;EAC1B6G,cAAc,YAAdA,cAAc,CAAE4C,MAAM;EACpB,IAAI7J,iBAAiB,CAAC;IACpB8J,QAAQ,EAAE9C,WAAW;IACrB+C,QAAQ,EAAE9C;GACX,CAAC;EACF7G,kBAAkB,CAAC4G,WAAW,CAAC;EACrC,MAAMgD,kBAAkB,GAAGvE,gBAAgB;EACvCrF,kBAAkB,CAAC,MAAM,CAAC;EAC1B+G,uBAAuB,YAAvBA,uBAAuB,CAAE0C,MAAM;EAC7B,IAAI7J,iBAAiB,CAAC;IACpB8J,QAAQ,EAAE5C,oBAAoB;IAC9B6C,QAAQ,EAAE5C;GACX,CAAC;EACF/G,kBAAkB,CAAC8G,oBAAoB,CAAC;EAC9C,MAAM/D,gBAAgB,GAAGrD,qBAAqB,CAC5C,CAAC,GAAGG,aAAa,CAACoD,OAAO,CAAC,EAAE,GAAGpD,aAAa,CAAC2I,QAAQ,CAAC,CAAC,EACvDlE,eAAe,EACfC,aAAa,EACbqC,WAAW,EACXC,cAAc,CACf;EACD,MAAMgD,yBAAyB,GAAGnK,qBAAqB,CACrD,CAAC,GAAGG,aAAa,CAACoD,OAAO,CAAC,EAAE,GAAGpD,aAAa,CAAC2I,QAAQ,CAAC,CAAC,EACvDlE,eAAe,EACfC,aAAa,EACbuC,oBAAoB,EACpBC,uBAAuB,CACxB;EAED,MAAM+C,aAAa,GAAG,IAAIC,GAAG,EAAU;EACvC,MAAMC,eAAe,GAAG,IAAID,GAAG,EAAU;EACzC,MAAME,iBAAiB,GAAGA,CACxBC,YAA0B,EAC1BC,KAAc,KACN;IACR,IAAIA,KAAK,KAAK,CAAC,EAAE;MACfH,eAAe,CAACI,GAAG,CAACF,YAAY,CAACG,EAAY,CAAC;KAC/C;IAAM;MACLP,aAAa,CAACM,GAAG,CAACF,YAAY,CAACG,EAAY,CAAC;;EAEhD,CAAC;EACDrB,UAAU,CAACsB,OAAO,CAAC,CAAAJ,YAAY,KAC7BD,iBAAiB,CAACC,YAAY,EAAE/C,UAAU,CAAC,CAC5C;EACDgC,UAAU,CAACmB,OAAO,CAAC,CAAAJ,YAAY,KAC7BD,iBAAiB,CAACC,YAAY,EAAE9C,WAAW,CAAC,CAC7C;EACD,MAAMmD,iBAAiB,GAAGtJ,uBAAuB,CAAC+H,UAAU,EAAE;IAC5DzC;GACD,CAAC;EACF,MAAMiE,iBAAiB,GAAGvJ,uBAAuB,CAACkI,UAAU,EAAE;IAC5D5C;GACD,CAAC;EACF,MAAM,EAAEkE,kBAAkB,EAAEC,eAAe,EAAE,GAAG3J,sBAAsB,CACpEgI,YAAY,EACZ;IACExC,KAAK;IACLgC,mBAAmB;IACnBoC,QAAQ,EAAE/B;GACX,CACF;EACD,MAAM,EACJ6B,kBAAkB,EAAEG,mBAAmB,EACvCF,eAAe,EAAEG,gBAAgB,EAClC,GAAG9J,sBAAsB,CAACmI,YAAY,EAAE;IACvC3C,KAAK,EAAEuE,OAAO,CAACtE,MAAM,CAAC;IACtB+B,mBAAmB;IACnBoC,QAAQ,EAAE/B;GACX,CAAC;EAEF1D,gBAAgB;EACb6F,MAAM,CAAC,CAACC,KAAsB,KAAKA,KAAK,CAACC,IAAI,CAAC;EAC9CX,OAAO,CAAC,CAACU,KAAsB,KAAI;IAClC,IAAI5K,wBAAwB,CAAC4K,KAAK,CAAC;IACjCzB,MAAM,CAAC2B,IAAI,CACT9I,0BAA0B,CACxB4I,KAAK,EACLrG,KAAK,EACLiE,UAAU,EACVU,SAAS,EACTZ,UAAU,EACVL,OAAO,CACR,CACF,CAAC;IACC,IAAIhI,yBAAyB,CAAC2K,KAAK,CAAC,EAAE;MACzCzB,MAAM,CAAC2B,IAAI,CACT,GAAG7I,2BAA2B,CAC5B2I,KAAK,EACLrG,KAAK,EACLG,cAAc,EACd4D,UAAU,EACVzE,KAAK,EACLoE,OAAO,CACR,CACF;KACF;IAAM,IAAIlI,sBAAsB,CAAC6K,KAAK,CAAC,EAAE;MACxCzB,MAAM,CAAC2B,IAAI,CACT,GAAG/I,wBAAwB,CACzB6I,KAAK,EACLrG,KAAK,EACLG,cAAc,EACd4D,UAAU,EACVzE,KAAK,EACLoE,OAAO,CACR,CACF;KACF;IAAM,IAAI9H,2BAA2B,CAACyK,KAAK,CAAC,EAAE;MAC7CzB,MAAM,CAAC2B,IAAI,CACT,GAAG3I,6BAA6B,CAC9ByI,KAAK,EACLpF,UAAU,EACVjB,KAAK,EACLG,cAAc,EACd4D,UAAU,EACVL,OAAO,CACR,CACF;;EAEL,CAAC,CAAC;EAEJ;EACA,MAAM,CAAC8C,QAAQ,EAAEC,QAAQ,CAAC,GAAG,CAAC3D,WAAW,IAAI,EAAE,EAAE4D,GAAG,CAACxK,cAAc,CAAC;EACpE,IAAI,CAACyK,QAAQ,EAAEC,QAAQ,CAAC,GAAG,CAACtE,WAAW,IAAI,EAAE,EAAEoE,GAAG,CAACxK,cAAc,CAAC;EAClE,IAAI,CAAC2K,YAAY,EAAEC,YAAY,CAAC,GAAG,CAACvE,oBAAoB,IAAI,EAAE,EAAEmE,GAAG,CACjExK,cAAc,CACf;EAED,MAAM6K,KAAK,GAAG7L,aAAa,EAAA4D,sBAAA,GAACH,UAAU,CAACuF,WAAW,qBAAtBpF,sBAAA,CAAwBkI,YAAY,CAAC;EACjE,MAAMC,QAAQ,GAAGC,OAAA,CAAOxH,UAAU,CAAC;EAEnC2E,UAAU,CAACsB,OAAO,CAAC,CAAAwB,KAAK,KAAG,KAAAC,oBAAA;IACzB,MAAMC,SAAS,GAAGC,MAAM,CAACH,KAAK,CAACI,IAAI,IAAI,EAAE,CAAC;IAC1C,MAAMC,UAAU,GAAGP,QAAQ,CAACI,SAAS,CAAC,IAAIA,SAAS;IACnD,MAAMI,aAAa,GAAG3L,iBAAiB,CAAC0L,UAAU,EAAET,KAAK,CAAC;IAE1D,MAAMW,eAAe,GAAGvJ,YAAY,CAClCC,gBAAgB,EAChByG,SAAS,EACTvG,OAAO,EACPwB,QAAQ,qBAAAsH,oBAAA,GAARtH,QAAQ,CAAG0H,UAAU,CAAC,qBAAtBJ,oBAAA,CAAyB,CAAC,CAAC,EAC3B,CAAC,CAAC1G,gBAAgB,CACnB;IAED,MAAMiH,iBAAiB,GAAGhK,eAAe,CACvCwJ,KAAK,EACLpD,UAAU,EACV0D,aAAa,EACb;MACEpH,IAAI;MACJU,aAAa;MACbE,UAAU;MACV2G,WAAW,EAAEzG,OAAO;MACpBI,UAAU;MACVG,SAAS;MACTE,KAAK,EAAEuE,OAAO,CAACvE,KAAK,CAAC;MACrBiG,aAAa,EAAE,KAAK;MACpBrF,UAAU;MACVpD,WAAW;MACX0I,SAAS,EAAEX,KAAK,CAACI,IAAI;MACrB7D,OAAO;MACPqE,UAAU,EAAE,CAAC;MACblD,SAAS,EACPtD,UAAU,KAAKvF,2BAA2B,CAACgM,GAAG;MAC1CpL,yBAAyB,CAAC;QACxBqL,GAAG,EAAErB,QAAQ;QACb/B,SAAS,EAAE6C;OACZ,CAAC;MACFA,eAAe;MACrBQ,gBAAgB,EAAEtC,iBAAiB;MACnCE,kBAAkB;MAClBC,eAAe;MACftF;KACD,CACF;IACD,IAAIkH,iBAAiB;IAAE/C,MAAM,CAAC2B,IAAI,CAACoB,iBAAiB,CAAC;EACvD,CAAC,CAAC;EAEFnD,UAAU,CAACmB,OAAO,CAAC,CAAAwB,KAAK,KAAG,KAAAgB,qBAAA;IACzB,MAAMd,SAAS,GAAGC,MAAM,CAACH,KAAK,CAACI,IAAI,IAAI,EAAE,CAAC;IAC1C,MAAMa,WAAW,GAAGnB,QAAQ,CAACI,SAAS,CAAC,IAAIA,SAAS;IACpD,MAAMG,UAAU,GAAG,GAAGY,WAAW,MAAM;IACvC,MAAMX,aAAa,GAAG3L,iBAAiB,CAACsM,WAAW,EAAErB,KAAK,CAAC;IAE3D,MAAMW,eAAe,GAAGvJ,YAAY,CAClC+G,yBAAyB,EACzBD,kBAAkB,EAClBpB,QAAQ,EACR9D,SAAS,qBAAAoI,qBAAA,GAATpI,SAAS,CAAGyH,UAAU,CAAC,qBAAvBW,qBAAA,CAA0B,CAAC,CAAC,EAC5B,CAAC,CAACzH,gBAAgB,CACnB;IAED,MAAMiH,iBAAiB,GAAGhK,eAAe,CACvCwJ,KAAK,EACLpD,UAAU,EACV0D,aAAa,EACb;MACEpH,IAAI,EAAEC,KAAK;MACXS,aAAa,EAAEC,cAAc;MAC7BC,UAAU,EAAEC,WAAW;MACvB0G,WAAW,EAAExG,QAAQ;MACrBG,UAAU,EAAEC,WAAW;MACvBE,SAAS,EAAEC,UAAU;MACrBC,KAAK,EAAEuE,OAAO,CAACtE,MAAM,CAAC;MACtBgG,aAAa,EAAE,KAAK;MACpBrF,UAAU,EAAEC,WAAW;MACvBrD,WAAW;MACX0I,SAAS,EAAE3C,aAAa,CAACkD,GAAG,CAAClB,KAAK,CAACI,IAAc,CAAC;MAC9C,GAAGJ,KAAK,CAACI,IAAI,MAAM;MACnBJ,KAAK,CAACI,IAAI;MACd7D,OAAO;MACPqE,UAAU,EAAE,CAAC;MACblD,SAAS,EACPrD,WAAW,KAAKxF,2BAA2B,CAACgM,GAAG;MAC3CpL,yBAAyB,CAAC;QACxBqL,GAAG,EAAEnB,YAAY;QACjBjC,SAAS,EAAE6C;OACZ,CAAC;MACFA,eAAe;MACrBQ,gBAAgB,EAAErC,iBAAiB;MACnCC,kBAAkB,EAAEG,mBAAmB;MACvCF,eAAe,EAAEG,gBAAgB;MACjCzF;KACD,CACF;IACD,IAAIkH,iBAAiB;IAAE/C,MAAM,CAAC2B,IAAI,CAACoB,iBAAiB,CAAC;EACvD,CAAC,CAAC;EAEF;EACA,IAAIjH,gBAAgB,KAAK,KAAK,IAAIkB,KAAK,EAAE;IACvC,IAAI+E,QAAQ,KAAKnM,SAAS;IAAEmM,QAAQ,GAAG,CAAC;IACxC,IAAIC,QAAQ,KAAKpM,SAAS;IAAEoM,QAAQ,GAAG,CAAC;IACxC,IAAIC,YAAY,KAAKrM,SAAS;IAAEqM,YAAY,GAAG,CAAC;IAChD,IAAIC,YAAY,KAAKtM,SAAS;IAAEsM,YAAY,GAAG,CAAC;;EAGlD,MAAMwB,gBAAgB,GACpB5D,aAAa,KAAKvJ,eAAe,CAACoN,QAAQ;EACtCvK,uBAAuB,CAACgE,iBAAiB,CAAC;EAC1CsF,MAAM;EACZ,MAAMkB,cAAc,GAClB9D,aAAa,KAAKvJ,eAAe,CAACoN,QAAQ;EACtCtK,iBAAiB,CAACoE,eAAe,CAAC;EAClCiF,MAAM;EAEZ,MAAMmB,mBAAmB,GAAG,CAAC,EAAEnF,UAAU,IAAIZ,mBAAmB,CAAC;EACjE,MAAMgG,mBAAmB,GAAG,CAAC,CAACrF,UAAU;EAExC,MAAMsF,YAAY,GAAGpL,UAAU,CAC7BkE,UAAU,EACVd,iBAAiB,EACjB8H,mBAAmB,EACnB9F,QAAQ,EACR,IAAI,EACJ+F,mBAAmB,EACnBjF,kBAAkB,EAClBrG,cAAc,CAACoG,gBAAgB,CAAC,EAChCpG,cAAc,CAACmG,gBAAgB,CAAC,CACjC;EAED,MAAM,EAAEqF,WAAW,GAAGA,CAAA,KAAK,CAAE,CAAC,EAAEC,aAAa,EAAE,GAAG1J,KAAK;EACvD,MAAM2J,UAAU,GAAGtG,UAAU,KAAKC,WAAW;EAE7C,MAAMsG,aAAa,GAAsB;IACvCC,MAAM,EAAE,IAAI;IACZC,IAAI,EAAE;MACJ,GAAG5L,WAAW;MACd,GAAGsL;KACJ;IACDzF,KAAK,EAAE;MACLgG,IAAI,EAAEvE,SAAS;MACf4C,IAAI,EAAElE,UAAU;MAChB8F,OAAO,EAAE/L,cAAc,CAACmG,gBAAgB,CAAC;MACzC6F,YAAY,EAAE,QAAQ;MACtBC,SAAS,EAAE;QACTxE,SAAS,EAAE2D,cAAc;QACzBc,MAAM,EAAEvG;OACT;MACDwG,SAAS,EAAE,EAAEjD,IAAI,EAAEhF,UAAU,EAAE;MAC/BkI,WAAW,EACT7E,SAAS,KAAK7J,QAAQ,CAAC2O,IAAI,IAAI9F,aAAa;MACxC9F,sBAAsB,CACpB8F,aAAoD,CACrD;MACD,CAAC;MACP,GAAGhH,sBAAsB,CACvBgI,SAAS,EACT7C,aAAa,EACb0E,QAAQ,EACRC,QAAQ,EACRlF,UAAU,KAAKvF,2BAA2B,CAACgM,GAAG;MAC5CxG,WAAW,KAAKxF,2BAA2B,CAACgM,GAAG;MAC7ChM,2BAA2B,CAACgM,GAAG;MAC/BxN,SAAS;KAEhB;IACDkP,KAAK,EAAE;IACL;MACE,GAAGpM,YAAY;MACf4L,IAAI,EAAErI,OAAO,GAAG,KAAK,GAAG,OAAO;MAC/B8I,GAAG,EAAEhD,QAAQ;MACbsB,GAAG,EAAErB,QAAQ;MACb2C,SAAS,EAAE,EAAEjD,IAAI,EAAEhF,UAAU,EAAE;MAC/BD,cAAc,EAAE,EAAEiF,IAAI,EAAEjF,cAAc,EAAE;MACxCgI,SAAS,EAAE;QACTxE,SAAS,EAAE3G,iBAAiB,CAC1BI,OAAO,EACP,CAAC,CAACoC,gBAAgB,EAClBtC,gBAAgB,EAChByG,SAAS,EACT5C,WAAW;OAEd;MACD2H,KAAK,EAAE7H,aAAa;MACpBwF,IAAI,EAAEjE,UAAU;MAChB6F,OAAO,EAAE/L,cAAc,CAACoG,gBAAgB,CAAC;MACzC4F,YAAY,EAAE3F,kBAAkB,KAAK,MAAM,GAAG,QAAQ,GAAG,KAAK;MAC9DqF;KACD;IACD;MACE,GAAGxL,YAAY;MACf4L,IAAI,EAAEpI,gBAAgB,GAAG,KAAK,GAAG,OAAO;MACxC6I,GAAG,EAAE9C,YAAY;MACjBoB,GAAG,EAAEnB,YAAY;MACjByC,SAAS,EAAE,EAAEjD,IAAI,EAAEhF,UAAU,EAAE;MAC/BuI,SAAS,EAAE,EAAEvD,IAAI,EAAE,KAAK,EAAE;MAC1BjF,cAAc,EAAE,EAAEiF,IAAI,EAAEjF,cAAc,EAAE;MACxCgI,SAAS,EAAE;QACTxE,SAAS,EAAE3G,iBAAiB,CAC1B2F,QAAQ,EACR,CAAC,CAACnD,gBAAgB,EAClBwE,yBAAyB,EACzBD,kBAAkB,EAClB9C,oBAAoB;OAEvB;MACDyH,KAAK,EAAE7H,aAAa;MACpBwF,IAAI,EAAE7E,mBAAmB;MACzBoG;KACD,CACF;;IACDgB,OAAO,EAAE;MACP,GAAG/L,iBAAiB,CAAC+F,IAAI,CAAC;MAC1BwC,IAAI,EAAE,CAAC/G,aAAa;MACpBwK,OAAO,EAAEnH,WAAW,GAAG,MAAM,GAAG,MAAM;MACtCiC,SAAS,EAAEA,CAACmF,MAAW,KAAI;QACzB,MAAMC,MAAM,GAAWrH,WAAW;QAC9BoH,MAAM,CAAC,CAAC,CAAC,CAACE,KAAK,CAAC,CAAC,CAAC;QAClBF,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC;QACnB,MAAMC,aAAa,GAAUvH,WAAW,GAAGoH,MAAM,GAAG,CAACA,MAAM,CAAC;QAE5D,MAAMI,UAAU,GAAG7N,kBAAkB,CACnC4N,aAAa;QACb;QACA,CAAC,EACDvH,WAAW,EACXC,mBAAmB,CACpB;QAED,MAAMwH,IAAI,GAAe,EAAE;QAC3B,MAAMC,cAAc,GAClBtN,sCAAsC,CAACmN,aAAa,CAAC;QAEvD,MAAMI,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACD,cAAc,CAAC;QACxC,IAAIG,UAAU;QACdL,UAAU;QACPhE,MAAM,CAAC,CAAAsE,GAAG,KAAIH,IAAI,CAACI,QAAQ,CAACD,GAAG,CAAC,CAAC;QACjC/E,OAAO,CAAC,CAAA+E,GAAG,KAAG;UACb,MAAMR,KAAK,GAAGI,cAAc,CAACI,GAAG,CAAC;UACjC;UACA;UACA,IAAInM,YAAY;UAChB,IAAI4G,aAAa,CAACkD,GAAG,CAACqC,GAAG,CAAC,EAAE,KAAAE,aAAA;YAC1BrM,YAAY;YACVyE,OAAO,CAAC6H,MAAM,KAAK,CAAC,GAAG5D,QAAQ,CAACyD,GAAG,CAAC,IAAAE,aAAA,GAAG9K,QAAQ,CAAC4K,GAAG,CAAC,qBAAbE,aAAA,CAAgB,CAAC,CAAC;WAC5D;UAAM,KAAAE,cAAA;YACLvM,YAAY;YACV0E,QAAQ,CAAC4H,MAAM,KAAK,CAAC,GAAG5D,QAAQ,CAACyD,GAAG,CAAC,IAAAI,cAAA,GAAG/K,SAAS,CAAC2K,GAAG,CAAC,qBAAdI,cAAA,CAAiB,CAAC,CAAC;;UAE/D,MAAMxC,gBAAgB,GAAGnK,YAAY,CACnCC,gBAAgB,EAChByG,SAAS,EACTvG,OAAO,EACPC,YAAY,EACZ,CAAC,CAACmC,gBAAgB,CACnB;UACD,MAAMqK,yBAAyB,GAAG5M,YAAY,CAC5C+G,yBAAyB,EACzBD,kBAAkB,EAClBpB,QAAQ,EACRtF,YAAY,EACZ,CAAC,CAACmC,gBAAgB,CACnB;UACD,MAAMsK,GAAG,GAAG/N,2BAA2B,CAAC;YACtC,GAAGiN,KAAK;YACR1C,UAAU,EAAEkD,GAAG;YACf7F,SAAS,EAAEM,aAAa,CAACkD,GAAG,CAACqC,GAAG,CAAC;YAC7BpC,gBAAgB;YAChByC;WACL,CAAC;UACFV,IAAI,CAAC9D,IAAI,CAACyE,GAAG,CAAC;UACd,IAAIN,GAAG,KAAKjL,aAAa,EAAE;YACzBgL,UAAU,GAAGJ,IAAI,CAACQ,MAAM,GAAG,CAAC;;QAEhC,CAAC,CAAC;QACJ,OAAOhP,WAAW,CAACwO,IAAI,EAAE/B,gBAAgB,CAAC2B,MAAM,CAAC,EAAEQ,UAAU,CAAC;MAChE;KACD;IACDQ,MAAM,EAAE;MACN,GAAGvO,cAAc,CACfkE,UAAU,EACVD,iBAAiB,EACjBc,UAAU,EACVnC,KAAK,EACLqD,QAAQ,CACT;MACD;MACA1C,IAAI,EAAEoE,UAAU;MACb6G,MAAM,CAAC1G,UAAU,CAAC;MAClB4B,MAAM,CACL,CAAAe,KAAK,KACHpK,4BAA4B,CAAEoK,KAAK,CAACI,IAAI,IAAI,EAAa,CAAC,CAAC2B,IAAI;MAC/DjN,kBAAkB,CAACkP,WAAW,CACjC;MACAzE,GAAG,CAAC,CAAAS,KAAK,KAAIA,KAAK,CAACI,IAAI,IAAI,EAAE,CAAC;MAC9B2D,MAAM,CAACrO,uBAAuB,CAAC0D,gBAAgB,EAAEJ,cAAc,CAAC;KACpE;IACDyE,MAAM,EAAEzI,WAAW,CAACgB,qBAAqB,CAACyH,MAAM,CAAmB,CAAC;IACpEwG,OAAO,EAAE;MACP9E,IAAI,EAAE3D,QAAQ;MACd0I,GAAG,EAAEvN,oBAAoB,CAACwN,UAAU;MACpCC,KAAK,EAAEzN,oBAAoB,CAAC0N,YAAY;MACxCC,OAAO,EAAE;QACPC,QAAQ,EAAE;UACRlJ,UAAU,EAAE,KAAK;UACjBmJ,KAAK,EAAE;YACLC,IAAI,EAAE,WAAW;YACjBC,IAAI,EAAE;;;;KAIb;IACDH,QAAQ,EAAE/I,QAAQ;IACd;IACE;MACEuG,IAAI,EAAE,QAAQ;MACd4C,KAAK,EAAEhO,oBAAoB,CAACiO,aAAa;MACzCC,GAAG,EAAElO,oBAAoB,CAACmO,WAAW;MACrCC,MAAM,EAAEpO,oBAAoB,CAACqO;KAC9B,CACF;;IACD;GACL;EAED,MAAMC,eAAe,GAAGA,CAAC5E,UAAyB,KAAI;IACpD/H,aAAa,GAAG+H,UAAU;EAC5B,CAAC;EAED,OAAO;IACLvI,QAAQ;IACRF,KAAK;IACLC,MAAM;IACN+J,aAAa;IACbH,WAAW;IACXpJ,gBAAgB;IAChBM,QAAQ;IACRC,SAAS;IACTiD,OAAO;IACPC,QAAQ;IACRoJ,eAAe,EAAEhI,UAAU,CAACwG,MAAM;IAClCyB,cAAc,EAAElN,WAAW,CAACkN,cAAc,IAAI,EAAE;IAChDzD,aAAa;IACbuD,eAAe;IACfG,eAAe,EAAEjE,gBAAgB;IACjCpF,KAAK,EAAE;MACLsJ,KAAK,EAAEvI,UAAU;MACjBiF,IAAI,EAAEvE;KACP;IACDb,IAAI;IACJ1D;GACD;AACH,CAAC,mBAAAqM,cAAA,UAAAlS,oBAAA,mBAAAA,oBAAA,CAAAI,OAAA,GAAAH,SAAA,MAAAiS,cAAA,WAAAA,cAAA,CAAAC,QAAA,CA5mBKvO,YAAY,mIAAAsO,cAAA,CAAAC,QAAA,CAgBMhO,cAAc,6JAAAiO,WAAA,UAAApS,oBAAA,mBAAAA,oBAAA,CAAAoS,WAAA,GAAAnS,SAAA,CAAAmS,WAAA,IAAAA,WAAA,CAAAlS,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}