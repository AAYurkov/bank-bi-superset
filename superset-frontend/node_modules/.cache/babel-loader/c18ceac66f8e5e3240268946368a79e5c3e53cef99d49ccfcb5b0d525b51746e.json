{"ast":null,"code":"import _range from \"lodash/range\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getMetricLabel, getColumnLabel, getValueFormatter, tooltipHtml } from '@superset-ui/core';\n\nimport { parseNumbersList } from '../utils/controls';\nimport { DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA } from './types';\nimport { defaultGaugeSeriesOption, INTERVAL_GAUGE_SERIES_OPTION, OFFSETS, FONT_SIZE_MULTIPLIERS } from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getColtypesMapping } from '../utils/series';\nexport const getIntervalBoundsAndColors = (intervals, intervalColorIndices, colorFn, min, max) => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  }\n  catch (error) {\n    intervalBoundsNonNormalized = [];\n    intervalColorIndicesArray = [];\n  }\n  const intervalBounds = intervalBoundsNonNormalized.map((bound) => (bound - min) / (max - min));\n  const intervalColors = intervalColorIndicesArray.map((ind) => colorFn.colors[(ind - 1) % colorFn.colors.length]);\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\nconst calculateAxisLineWidth = (data, fontSize, overlap) => overlap ? fontSize : data.length * fontSize;\nconst calculateMin = (data) => 2 * Math.min(...data.map((d) => d.value).concat([0]));\nconst calculateMax = (data) => 2 * Math.max(...data.map((d) => d.value).concat([0]));\nexport default function transformProps(chartProps) {var _queriesData$, _gaugeSeriesOptions$s, _gaugeSeriesOptions$s2, _gaugeSeriesOptions$a, _gaugeSeriesOptions$a2, _gaugeSeriesOptions$a3, _gaugeSeriesOptions$a4, _gaugeSeriesOptions$d;\n  const { width, height, formData, queriesData, hooks, filterState, theme, emitCrossFilters, datasource } = chartProps;\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const { verboseMap = {}, currencyFormats = {}, columnFormats = {} } = datasource;\n  const { groupby, metric, minVal, maxVal, colorScheme, fontSize, numberFormat, currencyFormat, animation, showProgress, overlap, roundCap, showAxisTick, showSplitLine, splitNumber, startAngle, endAngle, showPointer, intervals, intervalColorIndices, valueFormatter, sliceId } = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs = {};\n  const data = ((_queriesData$ = queriesData[0]) == null ? void 0 : _queriesData$.data) || [];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value) => valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle = FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle = FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const transformedData = data.map((data_point, index) => {\n    const name = groupbyLabels.\n    map((column) => `${verboseMap[column] || column}: ${data_point[column]}`).\n    join(', ');\n    const colorLabel = groupbyLabels.map((col) => data_point[col]);\n    columnsLabelMap.set(name, groupbyLabels.map((col) => data_point[col]));\n    let item = {\n      value: data_point[metricLabel],\n      name,\n      itemStyle: {\n        color: colorFn(colorLabel, sliceId)\n      },\n      title: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`],\n\n        fontSize\n      },\n      detail: {\n        offsetCenter: [\n        '0%',\n        `${index * titleOffsetFromTitle +\n        OFFSETS.titleFromCenter +\n        detailOffsetFromTitle}%`],\n\n        fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize\n      }\n    };\n    if (filterState.selectedValues &&\n    !filterState.selectedValues.includes(name)) {\n      item = {\n        ...item,\n        itemStyle: {\n          color: colorFn(index, sliceId),\n          opacity: OpacityEnum.SemiTransparent\n        },\n        detail: {\n          show: false\n        },\n        title: {\n          show: false\n        }\n      };\n    }\n    return item;\n  });\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const min = minVal != null ? minVal : calculateMin(transformedData);\n  const max = maxVal != null ? maxVal : calculateMax(transformedData);\n  const axisLabels = _range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(...axisLabels.map((label) => numberFormatter(label).length).concat([1]));\n  const intervalBoundsAndColors = getIntervalBoundsAndColors(intervals, intervalColorIndices, colorFn, min, max);\n  const splitLineDistance = axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance = FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n  fontSize *\n  FONT_SIZE_MULTIPLIERS.axisLabelLength *\n  axisLabelLength + (\n  showSplitLine ? splitLineLength : 0) + (\n  showAxisTick ? axisTickLength : 0) +\n  OFFSETS.ticksFromLine -\n  axisLineWidth;\n  const axisTickDistance = axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize\n  };\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: (_gaugeSeriesOptions$s = gaugeSeriesOptions.splitLine) == null ? void 0 : (_gaugeSeriesOptions$s2 = _gaugeSeriesOptions$s.lineStyle) == null ? void 0 : _gaugeSeriesOptions$s2.color\n    }\n  };\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: (_gaugeSeriesOptions$a = gaugeSeriesOptions.axisLine) == null ? void 0 : (_gaugeSeriesOptions$a2 = _gaugeSeriesOptions$a.lineStyle) == null ? void 0 : _gaugeSeriesOptions$a2.color\n    }\n  };\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: (_gaugeSeriesOptions$a3 = gaugeSeriesOptions.axisLabel) == null ? void 0 : _gaugeSeriesOptions$a3.color\n  };\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: (_gaugeSeriesOptions$a4 = gaugeSeriesOptions.axisTick) == null ? void 0 : _gaugeSeriesOptions$a4.lineStyle\n  };\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value) => formatValue(value),\n    color: (_gaugeSeriesOptions$d = gaugeSeriesOptions.detail) == null ? void 0 : _gaugeSeriesOptions$d.color\n  };\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params) => {\n      const { name, value } = params;\n      return tooltipHtml([[metricLabel, formatValue(value)]], name);\n    }\n  };\n  let pointer;\n  if (intervalBoundsAndColors.length) {var _INTERVAL_GAUGE_SERIE, _INTERVAL_GAUGE_SERIE2, _INTERVAL_GAUGE_SERIE3, _INTERVAL_GAUGE_SERIE4, _INTERVAL_GAUGE_SERIE5, _INTERVAL_GAUGE_SERIE6;\n    splitLine.lineStyle.color = (_INTERVAL_GAUGE_SERIE =\n    INTERVAL_GAUGE_SERIES_OPTION.splitLine) == null ? void 0 : (_INTERVAL_GAUGE_SERIE2 = _INTERVAL_GAUGE_SERIE.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE2.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION == null ? void 0 : (_INTERVAL_GAUGE_SERIE3 = INTERVAL_GAUGE_SERIES_OPTION.axisTick) == null ? void 0 : (_INTERVAL_GAUGE_SERIE4 = _INTERVAL_GAUGE_SERIE3.lineStyle) == null ? void 0 : _INTERVAL_GAUGE_SERIE4.\n    color;\n    axisLabel.color = (_INTERVAL_GAUGE_SERIE5 = INTERVAL_GAUGE_SERIES_OPTION.axisLabel) == null ? void 0 : _INTERVAL_GAUGE_SERIE5.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: (_INTERVAL_GAUGE_SERIE6 = INTERVAL_GAUGE_SERIES_OPTION.pointer) == null ? void 0 : _INTERVAL_GAUGE_SERIE6.itemStyle\n    };\n  } else\n  {\n    pointer = {\n      show: showPointer,\n      showAbove: false\n    };\n  }\n  const series = [\n  {\n    type: 'gauge',\n    startAngle,\n    endAngle,\n    min,\n    max,\n    progress,\n    animation,\n    axisLine: axisLine,\n    splitLine,\n    splitNumber,\n    axisLabel,\n    axisTick,\n    pointer,\n    detail,\n    // @ts-ignore\n    tooltip,\n    radius: Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n    center: ['50%', '55%'],\n    data: transformedData\n  }];\n\n  const echartOptions = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item'\n    },\n    series\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getIntervalBoundsAndColors, \"getIntervalBoundsAndColors\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateAxisLineWidth, \"calculateAxisLineWidth\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateMin, \"calculateMin\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(calculateMax, \"calculateMax\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CategoricalColorNamespace","getMetricLabel","getColumnLabel","getValueFormatter","tooltipHtml","parseNumbersList","DEFAULT_FORM_DATA","DEFAULT_GAUGE_FORM_DATA","defaultGaugeSeriesOption","INTERVAL_GAUGE_SERIES_OPTION","OFFSETS","FONT_SIZE_MULTIPLIERS","OpacityEnum","getDefaultTooltip","getColtypesMapping","getIntervalBoundsAndColors","intervals","intervalColorIndices","colorFn","min","max","intervalBoundsNonNormalized","intervalColorIndicesArray","error","intervalBounds","map","bound","intervalColors","ind","colors","length","val","idx","color","calculateAxisLineWidth","data","fontSize","overlap","calculateMin","Math","d","value","concat","calculateMax","transformProps","chartProps","_queriesData$","_gaugeSeriesOptions$s","_gaugeSeriesOptions$s2","_gaugeSeriesOptions$a","_gaugeSeriesOptions$a2","_gaugeSeriesOptions$a3","_gaugeSeriesOptions$a4","_gaugeSeriesOptions$d","width","height","formData","queriesData","hooks","filterState","theme","emitCrossFilters","datasource","gaugeSeriesOptions","verboseMap","currencyFormats","columnFormats","groupby","metric","minVal","maxVal","colorScheme","numberFormat","currencyFormat","animation","showProgress","roundCap","showAxisTick","showSplitLine","splitNumber","startAngle","endAngle","showPointer","valueFormatter","sliceId","refs","coltypeMapping","numberFormatter","getScale","axisLineWidth","groupbyLabels","formatValue","replace","axisTickLength","splitLineLength","titleOffsetFromTitle","detailOffsetFromTitle","columnsLabelMap","Map","metricLabel","transformedData","data_point","index","name","column","join","colorLabel","col","set","item","itemStyle","title","offsetCenter","titleFromCenter","detail","detailFontSize","selectedValues","includes","opacity","SemiTransparent","show","setDataMask","onContextMenu","axisLabels","_range","axisLabelLength","label","intervalBoundsAndColors","splitLineDistance","ticksFromLine","axisLabelDistance","axisTickDistance","progress","splitLine","distance","lineStyle","splitLineWidth","axisLine","axisLabel","formatter","axisTick","valueAnimation","tooltip","params","pointer","_INTERVAL_GAUGE_SERIE","_INTERVAL_GAUGE_SERIE2","_INTERVAL_GAUGE_SERIE3","_INTERVAL_GAUGE_SERIE4","_INTERVAL_GAUGE_SERIE5","_INTERVAL_GAUGE_SERIE6","showAbove","series","type","radius","center","echartOptions","trigger","labelMap","Object","fromEntries","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Gauge/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  QueryFormMetric,\n  CategoricalColorNamespace,\n  CategoricalColorScale,\n  DataRecord,\n  getMetricLabel,\n  getColumnLabel,\n  getValueFormatter,\n  tooltipHtml,\n} from '@superset-ui/core';\nimport type { EChartsCoreOption } from 'echarts/core';\nimport type { GaugeSeriesOption } from 'echarts/charts';\nimport type { GaugeDataItemOption } from 'echarts/types/src/chart/gauge/GaugeSeries';\nimport type { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { range } from 'lodash';\nimport { parseNumbersList } from '../utils/controls';\nimport {\n  DEFAULT_FORM_DATA as DEFAULT_GAUGE_FORM_DATA,\n  EchartsGaugeFormData,\n  AxisTickLineStyle,\n  GaugeChartTransformedProps,\n  EchartsGaugeChartProps,\n} from './types';\nimport {\n  defaultGaugeSeriesOption,\n  INTERVAL_GAUGE_SERIES_OPTION,\n  OFFSETS,\n  FONT_SIZE_MULTIPLIERS,\n} from './constants';\nimport { OpacityEnum } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\nimport { getColtypesMapping } from '../utils/series';\n\nexport const getIntervalBoundsAndColors = (\n  intervals: string,\n  intervalColorIndices: string,\n  colorFn: CategoricalColorScale,\n  min: number,\n  max: number,\n): Array<[number, string]> => {\n  let intervalBoundsNonNormalized;\n  let intervalColorIndicesArray;\n  try {\n    intervalBoundsNonNormalized = parseNumbersList(intervals, ',');\n    intervalColorIndicesArray = parseNumbersList(intervalColorIndices, ',');\n  } catch (error) {\n    intervalBoundsNonNormalized = [] as number[];\n    intervalColorIndicesArray = [] as number[];\n  }\n\n  const intervalBounds = intervalBoundsNonNormalized.map(\n    bound => (bound - min) / (max - min),\n  );\n  const intervalColors = intervalColorIndicesArray.map(\n    ind => colorFn.colors[(ind - 1) % colorFn.colors.length],\n  );\n\n  return intervalBounds.map((val, idx) => {\n    const color = intervalColors[idx];\n    return [val, color || colorFn.colors[idx]];\n  });\n};\n\nconst calculateAxisLineWidth = (\n  data: DataRecord[],\n  fontSize: number,\n  overlap: boolean,\n): number => (overlap ? fontSize : data.length * fontSize);\n\nconst calculateMin = (data: GaugeDataItemOption[]) =>\n  2 * Math.min(...data.map(d => d.value as number).concat([0]));\n\nconst calculateMax = (data: GaugeDataItemOption[]) =>\n  2 * Math.max(...data.map(d => d.value as number).concat([0]));\n\nexport default function transformProps(\n  chartProps: EchartsGaugeChartProps,\n): GaugeChartTransformedProps {\n  const {\n    width,\n    height,\n    formData,\n    queriesData,\n    hooks,\n    filterState,\n    theme,\n    emitCrossFilters,\n    datasource,\n  } = chartProps;\n\n  const gaugeSeriesOptions = defaultGaugeSeriesOption(theme);\n  const {\n    verboseMap = {},\n    currencyFormats = {},\n    columnFormats = {},\n  } = datasource;\n  const {\n    groupby,\n    metric,\n    minVal,\n    maxVal,\n    colorScheme,\n    fontSize,\n    numberFormat,\n    currencyFormat,\n    animation,\n    showProgress,\n    overlap,\n    roundCap,\n    showAxisTick,\n    showSplitLine,\n    splitNumber,\n    startAngle,\n    endAngle,\n    showPointer,\n    intervals,\n    intervalColorIndices,\n    valueFormatter,\n    sliceId,\n  }: EchartsGaugeFormData = { ...DEFAULT_GAUGE_FORM_DATA, ...formData };\n  const refs: Refs = {};\n  const data = (queriesData[0]?.data || []) as DataRecord[];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const numberFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    numberFormat,\n    currencyFormat,\n  );\n  const colorFn = CategoricalColorNamespace.getScale(colorScheme as string);\n  const axisLineWidth = calculateAxisLineWidth(data, fontSize, overlap);\n  const groupbyLabels = groupby.map(getColumnLabel);\n  const formatValue = (value: number) =>\n    valueFormatter.replace('{value}', numberFormatter(value));\n  const axisTickLength = FONT_SIZE_MULTIPLIERS.axisTickLength * fontSize;\n  const splitLineLength = FONT_SIZE_MULTIPLIERS.splitLineLength * fontSize;\n  const titleOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.titleOffsetFromTitle * fontSize;\n  const detailOffsetFromTitle =\n    FONT_SIZE_MULTIPLIERS.detailOffsetFromTitle * fontSize;\n  const columnsLabelMap = new Map<string, string[]>();\n  const metricLabel = getMetricLabel(metric as QueryFormMetric);\n\n  const transformedData: GaugeDataItemOption[] = data.map(\n    (data_point, index) => {\n      const name = groupbyLabels\n        .map(column => `${verboseMap[column] || column}: ${data_point[column]}`)\n        .join(', ');\n      const colorLabel = groupbyLabels.map(col => data_point[col] as string);\n      columnsLabelMap.set(\n        name,\n        groupbyLabels.map(col => data_point[col] as string),\n      );\n      let item: GaugeDataItemOption = {\n        value: data_point[metricLabel] as number,\n        name,\n        itemStyle: {\n          color: colorFn(colorLabel, sliceId),\n        },\n        title: {\n          offsetCenter: [\n            '0%',\n            `${index * titleOffsetFromTitle + OFFSETS.titleFromCenter}%`,\n          ],\n          fontSize,\n        },\n        detail: {\n          offsetCenter: [\n            '0%',\n            `${\n              index * titleOffsetFromTitle +\n              OFFSETS.titleFromCenter +\n              detailOffsetFromTitle\n            }%`,\n          ],\n          fontSize: FONT_SIZE_MULTIPLIERS.detailFontSize * fontSize,\n        },\n      };\n      if (\n        filterState.selectedValues &&\n        !filterState.selectedValues.includes(name)\n      ) {\n        item = {\n          ...item,\n          itemStyle: {\n            color: colorFn(index, sliceId),\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          detail: {\n            show: false,\n          },\n          title: {\n            show: false,\n          },\n        };\n      }\n      return item;\n    },\n  );\n\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n\n  const min = minVal ?? calculateMin(transformedData);\n  const max = maxVal ?? calculateMax(transformedData);\n  const axisLabels = range(min, max, (max - min) / splitNumber);\n  const axisLabelLength = Math.max(\n    ...axisLabels.map(label => numberFormatter(label).length).concat([1]),\n  );\n  const intervalBoundsAndColors = getIntervalBoundsAndColors(\n    intervals,\n    intervalColorIndices,\n    colorFn,\n    min,\n    max,\n  );\n  const splitLineDistance =\n    axisLineWidth + splitLineLength + OFFSETS.ticksFromLine;\n  const axisLabelDistance =\n    FONT_SIZE_MULTIPLIERS.axisLabelDistance *\n      fontSize *\n      FONT_SIZE_MULTIPLIERS.axisLabelLength *\n      axisLabelLength +\n    (showSplitLine ? splitLineLength : 0) +\n    (showAxisTick ? axisTickLength : 0) +\n    OFFSETS.ticksFromLine -\n    axisLineWidth;\n  const axisTickDistance =\n    axisLineWidth + axisTickLength + OFFSETS.ticksFromLine;\n\n  const progress = {\n    show: showProgress,\n    overlap,\n    roundCap,\n    width: fontSize,\n  };\n  const splitLine = {\n    show: showSplitLine,\n    distance: -splitLineDistance,\n    length: splitLineLength,\n    lineStyle: {\n      width: FONT_SIZE_MULTIPLIERS.splitLineWidth * fontSize,\n      color: gaugeSeriesOptions.splitLine?.lineStyle?.color,\n    },\n  };\n  const axisLine = {\n    roundCap,\n    lineStyle: {\n      width: axisLineWidth,\n      color: gaugeSeriesOptions.axisLine?.lineStyle?.color,\n    },\n  };\n  const axisLabel = {\n    distance: -axisLabelDistance,\n    fontSize,\n    formatter: numberFormatter,\n    color: gaugeSeriesOptions.axisLabel?.color,\n  };\n  const axisTick = {\n    show: showAxisTick,\n    distance: -axisTickDistance,\n    length: axisTickLength,\n    lineStyle: gaugeSeriesOptions.axisTick?.lineStyle as AxisTickLineStyle,\n  };\n  const detail = {\n    valueAnimation: animation,\n    formatter: (value: number) => formatValue(value),\n    color: gaugeSeriesOptions.detail?.color,\n  };\n  const tooltip = {\n    ...getDefaultTooltip(refs),\n    formatter: (params: CallbackDataParams) => {\n      const { name, value } = params;\n      return tooltipHtml([[metricLabel, formatValue(value as number)]], name);\n    },\n  };\n\n  let pointer;\n  if (intervalBoundsAndColors.length) {\n    splitLine.lineStyle.color =\n      INTERVAL_GAUGE_SERIES_OPTION.splitLine?.lineStyle?.color;\n    axisTick.lineStyle.color = INTERVAL_GAUGE_SERIES_OPTION?.axisTick?.lineStyle\n      ?.color as string;\n    axisLabel.color = INTERVAL_GAUGE_SERIES_OPTION.axisLabel?.color;\n    axisLine.lineStyle.color = intervalBoundsAndColors;\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n      itemStyle: INTERVAL_GAUGE_SERIES_OPTION.pointer?.itemStyle,\n    };\n  } else {\n    pointer = {\n      show: showPointer,\n      showAbove: false,\n    };\n  }\n\n  const series: GaugeSeriesOption[] = [\n    {\n      type: 'gauge',\n      startAngle,\n      endAngle,\n      min,\n      max,\n      progress,\n      animation,\n      axisLine: axisLine as GaugeSeriesOption['axisLine'],\n      splitLine,\n      splitNumber,\n      axisLabel,\n      axisTick,\n      pointer,\n      detail,\n      // @ts-ignore\n      tooltip,\n      radius:\n        Math.min(width, height) / 2 - axisLabelDistance - axisTickDistance,\n      center: ['50%', '55%'],\n      data: transformedData,\n    },\n  ];\n\n  const echartOptions: EChartsCoreOption = {\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      trigger: 'item',\n    },\n    series,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}