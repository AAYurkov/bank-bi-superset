{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataMaskType, ensureIsArray, getColumnLabel, NativeFilterType, NO_TIME_RANGE } from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { areObjectsEqual } from 'src/reduxUtils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\nexport const extractLabel = (filter) => {var _filter$label;\n  if (filter != null && filter.label && !(filter != null && (_filter$label = filter.label) != null && _filter$label.includes(undefined))) {\n    return filter.label;\n  }\n  if (filter != null && filter.value) {\n    return ensureIsArray(filter == null ? void 0 : filter.value).join(', ');\n  }\n  return null;\n};\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = ((columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).reduce((map, [key, value]) => ({\n      ...map,\n      [key]: value\n    }), {});\n    return arrValues.map((value) => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return Object.keys(filter.columns).\n  filter((column) => getChartIdsInFilterScope({\n    filterScope: filter.scopes[column]\n  }).includes(chartId)).\n  map((column) => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter\n  }));\n};\nconst getAppliedColumns = (chart) => {var _chart$queriesRespons, _chart$queriesRespons2;return new Set(((chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).map((filter) => filter.column));};\nconst getRejectedColumns = (chart) => {var _chart$queriesRespons3, _chart$queriesRespons4;return new Set(((chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).map((filter) => getColumnLabel(filter.column)));};\nexport const getCrossFilterIndicator = (chartId, dataMask, chartLayoutItems) => {var _dataMask$extraFormDa, _filters$, _chartLayoutItem$meta, _chartLayoutItem$meta2, _chartLayoutItem$pare;\n  const filterState = dataMask == null ? void 0 : dataMask.filterState;\n  const filters = dataMask == null ? void 0 : (_dataMask$extraFormDa = dataMask.extraFormData) == null ? void 0 : _dataMask$extraFormDa.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState == null ? void 0 : filterState.filters;\n  const column = (filters == null ? void 0 : (_filters$ = filters[0]) == null ? void 0 : _filters$.col) || filtersState && Object.keys(filtersState)[0];\n  const chartLayoutItem = chartLayoutItems.find((layoutItem) => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartId;});\n  const filterObject = {\n    column,\n    name: (chartLayoutItem == null ? void 0 : (_chartLayoutItem$meta = chartLayoutItem.meta) == null ? void 0 : _chartLayoutItem$meta.sliceNameOverride) || (\n    chartLayoutItem == null ? void 0 : (_chartLayoutItem$meta2 = chartLayoutItem.meta) == null ? void 0 : _chartLayoutItem$meta2.sliceName) ||\n    '',\n    path: [...((_chartLayoutItem$pare = chartLayoutItem == null ? void 0 : chartLayoutItem.parents) != null ? _chartLayoutItem$pare : []), (chartLayoutItem == null ? void 0 : chartLayoutItem.id) || ''],\n    value: label\n  };\n  return filterObject;\n};\nconst cachedIndicatorsForChart = {};\nconst cachedDashboardFilterDataForChart = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, chart) => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter((filter) => filter.chartId !== chartId);\n  const matchingDatasources = Object.entries(datasources).\n  filter(([key]) => matchingFilters.find((filter) => filter.datasourceId === key)).\n  map(([, datasource]) => datasource);\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (cachedIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData.rejectedColumns, rejectedColumns) &&\n  areObjectsEqual(cachedFilterData.matchingFilters, matchingFilters) &&\n  areObjectsEqual(cachedFilterData.matchingDatasources, matchingDatasources)) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce((acc, filter) => acc.concat(selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources\n  };\n  return indicators;\n};\nconst getStatus = ({ label, column, type = DataMaskType.NativeFilters, rejectedColumns, appliedColumns }) => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS = type === DataMaskType.CrossFilters ?\n  IndicatorStatus.CrossFilterApplied :\n  IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns != null && rejectedColumns.has(column))\n  return IndicatorStatus.Incompatible;\n  if (column && appliedColumns != null && appliedColumns.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (dataMask, chartId, chartLayoutItems, chartConfiguration = defaultChartConfig, appliedColumns, rejectedColumns, filterEmitter = false) => {\n  let crossFilterIndicators = [];\n  crossFilterIndicators = Object.values(chartConfiguration).\n  filter((chartConfig) => {var _chartConfig$crossFil, _chartConfig$crossFil2;\n    const inScope = (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : (_chartConfig$crossFil2 = _chartConfig$crossFil.chartsInScope) == null ? void 0 : _chartConfig$crossFil2.includes(chartId);\n    if (!filterEmitter && inScope) {\n      return true;\n    }\n    if (filterEmitter && !inScope) {\n      return true;\n    }\n    return false;\n  }).\n  map((chartConfig) => {\n    const filterIndicator = getCrossFilterIndicator(Number(chartConfig.id), dataMask[chartConfig.id], chartLayoutItems);\n    const filterStatus = getStatus({\n      label: filterIndicator.value,\n      column: filterIndicator.column ?\n      getColumnLabel(filterIndicator.column) :\n      undefined,\n      type: DataMaskType.CrossFilters,\n      appliedColumns,\n      rejectedColumns\n    });\n    return { ...filterIndicator, status: filterStatus };\n  }).\n  filter((filter) => filter.status === IndicatorStatus.CrossFilterApplied);\n  return crossFilterIndicators;\n};\nconst cachedNativeIndicatorsForChart = {};\nconst cachedNativeFilterDataForChart = {};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, chart, chartLayoutItems, chartConfiguration = defaultChartConfig) => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (cachedNativeIndicatorsForChart[chartId] &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.appliedColumns, appliedColumns) &&\n  areObjectsEqual(cachedFilterData == null ? void 0 : cachedFilterData.rejectedColumns, rejectedColumns) &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.nativeFilters) === nativeFilters &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartLayoutItems) === chartLayoutItems &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.chartConfiguration) === chartConfiguration &&\n  (cachedFilterData == null ? void 0 : cachedFilterData.dataMask) === dataMask) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n  const nativeFilterIndicators = nativeFilters &&\n  Object.values(nativeFilters).\n  filter((nativeFilter) => {var _nativeFilter$chartsI;return nativeFilter.type === NativeFilterType.NativeFilter && ((_nativeFilter$chartsI =\n    nativeFilter.chartsInScope) == null ? void 0 : _nativeFilter$chartsI.includes(chartId));}).\n  map((nativeFilter) => {var _nativeFilter$targets, _nativeFilter$targets2, _nativeFilter$targets3, _dataMask$nativeFilte;\n    const column = (_nativeFilter$targets = nativeFilter.targets) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets[0]) == null ? void 0 : (_nativeFilter$targets3 = _nativeFilter$targets2.column) == null ? void 0 : _nativeFilter$targets3.name;\n    const filterState = (_dataMask$nativeFilte = dataMask[nativeFilter.id]) == null ? void 0 : _dataMask$nativeFilte.filterState;\n    const label = extractLabel(filterState);\n    return {\n      column,\n      name: nativeFilter.name,\n      path: [nativeFilter.id],\n      status: getStatus({\n        label,\n        column,\n        rejectedColumns,\n        appliedColumns\n      }),\n      value: label\n    };\n  });\n  let crossFilterIndicators = [];\n  crossFilterIndicators = selectChartCrossFilters(dataMask, chartId, chartLayoutItems, chartConfiguration, appliedColumns, rejectedColumns);\n  const indicators = crossFilterIndicators.concat(nativeFilterIndicators);\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    chartLayoutItems,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns\n  };\n  return indicators;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(extractLabel, \"extractLabel\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getAppliedColumns, \"getAppliedColumns\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getRejectedColumns, \"getRejectedColumns\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getCrossFilterIndicator, \"getCrossFilterIndicator\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedIndicatorsForChart, \"cachedIndicatorsForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedDashboardFilterDataForChart, \"cachedDashboardFilterDataForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(getStatus, \"getStatus\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(defaultChartConfig, \"defaultChartConfig\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectChartCrossFilters, \"selectChartCrossFilters\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedNativeIndicatorsForChart, \"cachedNativeIndicatorsForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(cachedNativeFilterDataForChart, \"cachedNativeFilterDataForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");reactHotLoader.register(selectNativeIndicatorsForChart, \"selectNativeIndicatorsForChart\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["DataMaskType","ensureIsArray","getColumnLabel","NativeFilterType","NO_TIME_RANGE","TIME_FILTER_MAP","getChartIdsInFilterScope","areObjectsEqual","IndicatorStatus","TIME_GRANULARITY_FIELDS","Set","Object","values","extractLabel","filter","_filter$label","label","includes","undefined","value","join","selectIndicatorValue","columnKey","datasource","columns","arrValues","Array","isArray","isDateFilter","length","has","timeGranularityMap","time_grain_sqla","granularity","reduce","map","key","selectIndicatorsForChartFromFilter","chartId","filterDataSource","appliedColumns","rejectedColumns","getStatus","column","Applied","Incompatible","Unset","keys","filterScope","scopes","name","labels","status","path","directPathToFilter","getAppliedColumns","chart","_chart$queriesRespons","_chart$queriesRespons2","queriesResponse","applied_filters","getRejectedColumns","_chart$queriesRespons3","_chart$queriesRespons4","rejected_filters","getCrossFilterIndicator","dataMask","chartLayoutItems","_dataMask$extraFormDa","_filters$","_chartLayoutItem$meta","_chartLayoutItem$meta2","_chartLayoutItem$pare","filterState","filters","extraFormData","filtersState","col","chartLayoutItem","find","layoutItem","_layoutItem$meta","meta","filterObject","sliceNameOverride","sliceName","parents","id","cachedIndicatorsForChart","cachedDashboardFilterDataForChart","selectIndicatorsForChart","datasources","matchingFilters","matchingDatasources","entries","datasourceId","cachedFilterData","indicators","acc","concat","sort","a","b","localeCompare","type","NativeFilters","hasValue","APPLIED_STATUS","CrossFilters","CrossFilterApplied","defaultChartConfig","selectChartCrossFilters","chartConfiguration","filterEmitter","crossFilterIndicators","chartConfig","_chartConfig$crossFil","_chartConfig$crossFil2","inScope","crossFilters","chartsInScope","filterIndicator","Number","filterStatus","cachedNativeIndicatorsForChart","cachedNativeFilterDataForChart","selectNativeIndicatorsForChart","nativeFilters","nativeFilterIndicators","nativeFilter","_nativeFilter$chartsI","NativeFilter","_nativeFilter$targets","_nativeFilter$targets2","_nativeFilter$targets3","_dataMask$nativeFilte","targets","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/dashboard/components/nativeFilters/selectors.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DataMask,\n  DataMaskStateWithId,\n  DataMaskType,\n  ensureIsArray,\n  Filters,\n  FilterState,\n  getColumnLabel,\n  NativeFilterType,\n  NO_TIME_RANGE,\n  QueryFormColumn,\n} from '@superset-ui/core';\nimport { TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { ChartConfiguration, LayoutItem } from 'src/dashboard/types';\nimport { areObjectsEqual } from 'src/reduxUtils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the Dataset type in superset-ui is incorrect.\n// Should patch it here until the Dataset type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n  verbose_map?: Record<string, string>;\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nexport const extractLabel = (filter?: FilterState): string | null => {\n  if (filter?.label && !filter?.label?.includes(undefined)) {\n    return filter.label;\n  }\n  if (filter?.value) {\n    return ensureIsArray(filter?.value).join(', ');\n  }\n  return null;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === NO_TIME_RANGE) ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce<Record<string, string>>(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map((filter: any) =>\n      getColumnLabel(filter.column),\n    ),\n  );\n\nexport type Indicator = {\n  column?: QueryFormColumn;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\nexport type CrossFilterIndicator = Indicator & { emitterId: number };\n\nexport const getCrossFilterIndicator = (\n  chartId: number,\n  dataMask: DataMask,\n  chartLayoutItems: LayoutItem[],\n) => {\n  const filterState = dataMask?.filterState;\n  const filters = dataMask?.extraFormData?.filters;\n  const label = extractLabel(filterState);\n  const filtersState = filterState?.filters;\n  const column =\n    filters?.[0]?.col || (filtersState && Object.keys(filtersState)[0]);\n\n  const chartLayoutItem = chartLayoutItems.find(\n    layoutItem => layoutItem?.meta?.chartId === chartId,\n  );\n\n  const filterObject: Indicator = {\n    column,\n    name:\n      chartLayoutItem?.meta?.sliceNameOverride ||\n      chartLayoutItem?.meta?.sliceName ||\n      '',\n    path: [...(chartLayoutItem?.parents ?? []), chartLayoutItem?.id || ''],\n    value: label,\n  };\n  return filterObject;\n};\n\nconst cachedIndicatorsForChart: Record<number, Indicator[]> = {};\nconst cachedDashboardFilterDataForChart: Record<\n  string,\n  {\n    appliedColumns: Set<string>;\n    rejectedColumns: Set<string>;\n    matchingFilters: Filter[];\n    matchingDatasources: Datasource[];\n  }\n> = {};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  chart: any,\n): Indicator[] => {\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const matchingFilters = Object.values(filters).filter(\n    filter => filter.chartId !== chartId,\n  );\n  const matchingDatasources = Object.entries(datasources)\n    .filter(([key]) =>\n      matchingFilters.find(filter => filter.datasourceId === key),\n    )\n    .map(([, datasource]) => datasource);\n\n  const cachedFilterData = cachedDashboardFilterDataForChart[chartId];\n  if (\n    cachedIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData.rejectedColumns, rejectedColumns) &&\n    areObjectsEqual(cachedFilterData.matchingFilters, matchingFilters) &&\n    areObjectsEqual(cachedFilterData.matchingDatasources, matchingDatasources)\n  ) {\n    return cachedIndicatorsForChart[chartId];\n  }\n  const indicators = matchingFilters.reduce(\n    (acc, filter) =>\n      acc.concat(\n        selectIndicatorsForChartFromFilter(\n          chartId,\n          filter,\n          datasources[filter.datasourceId] || {},\n          appliedColumns,\n          rejectedColumns,\n        ),\n      ),\n    [] as Indicator[],\n  );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  cachedIndicatorsForChart[chartId] = indicators;\n  cachedDashboardFilterDataForChart[chartId] = {\n    appliedColumns,\n    rejectedColumns,\n    matchingFilters,\n    matchingDatasources,\n  };\n  return indicators;\n};\n\nconst getStatus = ({\n  label,\n  column,\n  type = DataMaskType.NativeFilters,\n  rejectedColumns,\n  appliedColumns,\n}: {\n  label: string | null;\n  column?: string;\n  type?: DataMaskType;\n  rejectedColumns?: Set<string>;\n  appliedColumns?: Set<string>;\n}): IndicatorStatus => {\n  // a filter is only considered unset if it's value is null\n  const hasValue = label !== null;\n  const APPLIED_STATUS =\n    type === DataMaskType.CrossFilters\n      ? IndicatorStatus.CrossFilterApplied\n      : IndicatorStatus.Applied;\n  if (!column && hasValue) {\n    // Filter without datasource\n    return APPLIED_STATUS;\n  }\n  if (column && rejectedColumns?.has(column))\n    return IndicatorStatus.Incompatible;\n  if (column && appliedColumns?.has(column) && hasValue) {\n    return APPLIED_STATUS;\n  }\n  return IndicatorStatus.Unset;\n};\n\nconst defaultChartConfig = {};\nexport const selectChartCrossFilters = (\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  chartLayoutItems: LayoutItem[],\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n  filterEmitter = false,\n): Indicator[] | CrossFilterIndicator[] => {\n  let crossFilterIndicators: Indicator[] | CrossFilterIndicator[] = [];\n  crossFilterIndicators = Object.values(chartConfiguration)\n    .filter(chartConfig => {\n      const inScope =\n        chartConfig.crossFilters?.chartsInScope?.includes(chartId);\n      if (!filterEmitter && inScope) {\n        return true;\n      }\n      if (filterEmitter && !inScope) {\n        return true;\n      }\n      return false;\n    })\n    .map(chartConfig => {\n      const filterIndicator = getCrossFilterIndicator(\n        Number(chartConfig.id),\n        dataMask[chartConfig.id],\n        chartLayoutItems,\n      );\n      const filterStatus = getStatus({\n        label: filterIndicator.value,\n        column: filterIndicator.column\n          ? getColumnLabel(filterIndicator.column)\n          : undefined,\n        type: DataMaskType.CrossFilters,\n        appliedColumns,\n        rejectedColumns,\n      });\n\n      return { ...filterIndicator, status: filterStatus };\n    })\n    .filter(filter => filter.status === IndicatorStatus.CrossFilterApplied);\n\n  return crossFilterIndicators;\n};\n\nconst cachedNativeIndicatorsForChart: Record<number, any> = {};\nconst cachedNativeFilterDataForChart: Record<\n  number,\n  {\n    nativeFilters: Filters;\n    chartLayoutItems: LayoutItem[];\n    chartConfiguration: ChartConfiguration;\n    dataMask: DataMaskStateWithId;\n    appliedColumns: Set<string>;\n    rejectedColumns: Set<string>;\n  }\n> = {};\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: Filters,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  chart: any,\n  chartLayoutItems: LayoutItem[],\n  chartConfiguration: ChartConfiguration = defaultChartConfig,\n): Indicator[] => {\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const cachedFilterData = cachedNativeFilterDataForChart[chartId];\n  if (\n    cachedNativeIndicatorsForChart[chartId] &&\n    areObjectsEqual(cachedFilterData?.appliedColumns, appliedColumns) &&\n    areObjectsEqual(cachedFilterData?.rejectedColumns, rejectedColumns) &&\n    cachedFilterData?.nativeFilters === nativeFilters &&\n    cachedFilterData?.chartLayoutItems === chartLayoutItems &&\n    cachedFilterData?.chartConfiguration === chartConfiguration &&\n    cachedFilterData?.dataMask === dataMask\n  ) {\n    return cachedNativeIndicatorsForChart[chartId];\n  }\n\n  const nativeFilterIndicators =\n    nativeFilters &&\n    Object.values(nativeFilters)\n      .filter(\n        nativeFilter =>\n          nativeFilter.type === NativeFilterType.NativeFilter &&\n          nativeFilter.chartsInScope?.includes(chartId),\n      )\n      .map(nativeFilter => {\n        const column = nativeFilter.targets?.[0]?.column?.name;\n        const filterState = dataMask[nativeFilter.id]?.filterState;\n        const label = extractLabel(filterState);\n        return {\n          column,\n          name: nativeFilter.name,\n          path: [nativeFilter.id],\n          status: getStatus({\n            label,\n            column,\n            rejectedColumns,\n            appliedColumns,\n          }),\n          value: label,\n        };\n      });\n\n  let crossFilterIndicators: (Indicator | CrossFilterIndicator)[] = [];\n  crossFilterIndicators = selectChartCrossFilters(\n    dataMask,\n    chartId,\n    chartLayoutItems,\n    chartConfiguration,\n    appliedColumns,\n    rejectedColumns,\n  );\n  const indicators = crossFilterIndicators.concat(\n    nativeFilterIndicators as Indicator[],\n  );\n  cachedNativeIndicatorsForChart[chartId] = indicators;\n  cachedNativeFilterDataForChart[chartId] = {\n    nativeFilters,\n    chartLayoutItems,\n    chartConfiguration,\n    dataMask,\n    appliedColumns,\n    rejectedColumns,\n  };\n  return indicators;\n};\n"],"mappings":"wSAAA;;;;;;;;;;;;;;;;;;AAkBA,SAGEA,YAAY,EACZC,aAAa,EAGbC,cAAc,EACdC,gBAAgB,EAChBC,aAAa,QAER,mBAAmB;AAC1B,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,wBAAwB,QAAQ,2CAA2C;AAEpF,SAASC,eAAe,QAAQ,gBAAgB;AAEhD,WAAYC,eAKX;AALD,WAAYA,eAAe;EACzBA,eAAA,mBAAe;EACfA,eAAA,uBAAmB;EACnBA,eAAA,iCAA6B;EAC7BA,eAAA,+CAA2C;AAC7C,CAAC,EALWA,eAAe,KAAfA,eAAe;AAO3B,MAAMC,uBAAuB,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,MAAM,CAACP,eAAe,CAAC,CAAC;AAoBvE,OAAO,MAAMQ,YAAY,GAAGA,CAACC,MAAoB,KAAmB,KAAAC,aAAA;EAClE,IAAID,MAAM,YAANA,MAAM,CAAEE,KAAK,IAAI,EAACF,MAAM,aAAAC,aAAA,GAAND,MAAM,CAAEE,KAAK,aAAbD,aAAA,CAAeE,QAAQ,CAACC,SAAS,CAAC,GAAE;IACxD,OAAOJ,MAAM,CAACE,KAAK;;EAErB,IAAIF,MAAM,YAANA,MAAM,CAAEK,KAAK,EAAE;IACjB,OAAOlB,aAAa,CAACa,MAAM,oBAANA,MAAM,CAAEK,KAAK,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;;EAEhD,OAAO,IAAI;AACb,CAAC;AAED,MAAMC,oBAAoB,GAAGA,CAC3BC,SAAiB,EACjBR,MAAc,EACdS,UAAsB,KACf;EACP,MAAMX,MAAM,GAAGE,MAAM,CAACU,OAAO,CAACF,SAAS,CAAC;EACxC,MAAMG,SAAS,GAAGC,KAAK,CAACC,OAAO,CAACf,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;EAE3D,IACEA,MAAM,IAAI,IAAI;EACbE,MAAM,CAACc,YAAY,IAAIhB,MAAM,KAAKR,aAAc;EACjDqB,SAAS,CAACI,MAAM,KAAK,CAAC,EACtB;IACA,OAAO,EAAE;;EAGX,IAAIf,MAAM,CAACc,YAAY,IAAInB,uBAAuB,CAACqB,GAAG,CAACR,SAAS,CAAC,EAAE;IACjE,MAAMS,kBAAkB,GAAG,CACzB,CAACT,SAAS,KAAKjB,eAAe,CAAC2B,eAAe;IAC1CT,UAAU,CAACS,eAAe;IAC1BT,UAAU,CAACU,WAAW,KAAK,EAAE,EACjCC,MAAM,CACN,CAACC,GAAG,EAAE,CAACC,GAAG,EAAEjB,KAAK,CAAC,MAAM;MACtB,GAAGgB,GAAG;MACN,CAACC,GAAG,GAAGjB;KACR,CAAC,EACF,EAAE,CACH;IAED,OAAOM,SAAS,CAACU,GAAG,CAAC,CAAAhB,KAAK,KAAIY,kBAAkB,CAACZ,KAAK,CAAC,IAAIA,KAAK,CAAC;;EAGnE,OAAOM,SAAS;AAClB,CAAC;AAED,MAAMY,kCAAkC,GAAGA,CACzCC,OAAe,EACfxB,MAAc,EACdyB,gBAA4B,EAC5BC,cAA2B,EAC3BC,eAA4B,KACb;EACf;EACA;EACA;EACA,MAAMC,SAAS,GAAGA,CAACC,MAAc,EAAE7B,MAAc,KAAI;IACnD,IAAI0B,cAAc,CAACV,GAAG,CAACa,MAAM,CAAC,IAAI7B,MAAM,CAACU,OAAO,CAACmB,MAAM,CAAC;IACtD,OAAOnC,eAAe,CAACoC,OAAO;IAChC,IAAIH,eAAe,CAACX,GAAG,CAACa,MAAM,CAAC;IAAE,OAAOnC,eAAe,CAACqC,YAAY;IACpE,OAAOrC,eAAe,CAACsC,KAAK;EAC9B,CAAC;EAED,OAAOnC,MAAM,CAACoC,IAAI,CAACjC,MAAM,CAACU,OAAO,CAAC;EAC/BV,MAAM,CAAC,CAAA6B,MAAM,KACZrC,wBAAwB,CAAC;IACvB0C,WAAW,EAAElC,MAAM,CAACmC,MAAM,CAACN,MAAM;GAClC,CAAC,CAAC1B,QAAQ,CAACqB,OAAO,CAAC,CACrB;EACAH,GAAG,CAAC,CAAAQ,MAAM,MAAK;IACdA,MAAM;IACNO,IAAI,EAAEpC,MAAM,CAACqC,MAAM,CAACR,MAAM,CAAC,IAAIA,MAAM;IACrCxB,KAAK,EAAEE,oBAAoB,CAACsB,MAAM,EAAE7B,MAAM,EAAEyB,gBAAgB,CAAC;IAC7Da,MAAM,EAAEV,SAAS,CAACC,MAAM,EAAE7B,MAAM,CAAC;IACjCuC,IAAI,EAAEvC,MAAM,CAACwC;GACd,CAAC,CAAC;AACP,CAAC;AAED,MAAMC,iBAAiB,GAAGA,CAACC,KAAU,UAAAC,qBAAA,EAAAC,sBAAA,QACnC,IAAIhD,GAAG,CACL,CAAC,CAAA8C,KAAK,qBAAAC,qBAAA,GAALD,KAAK,CAAEG,eAAe,sBAAAD,sBAAA,GAAtBD,qBAAA,CAAyB,CAAC,CAAC,qBAA3BC,sBAAA,CAA6BE,eAAe,KAAI,EAAE,EAAEzB,GAAG,CACtD,CAACrB,MAAW,KAAKA,MAAM,CAAC6B,MAAM,CAC/B,CACF;AAEH,MAAMkB,kBAAkB,GAAGA,CAACL,KAAU,UAAAM,sBAAA,EAAAC,sBAAA,QACpC,IAAIrD,GAAG,CACL,CAAC,CAAA8C,KAAK,qBAAAM,sBAAA,GAALN,KAAK,CAAEG,eAAe,sBAAAI,sBAAA,GAAtBD,sBAAA,CAAyB,CAAC,CAAC,qBAA3BC,sBAAA,CAA6BC,gBAAgB,KAAI,EAAE,EAAE7B,GAAG,CAAC,CAACrB,MAAW,KACpEZ,cAAc,CAACY,MAAM,CAAC6B,MAAM,CAAC,CAC9B,CACF;AAYH,OAAO,MAAMsB,uBAAuB,GAAGA,CACrC3B,OAAe,EACf4B,QAAkB,EAClBC,gBAA8B,KAC5B,KAAAC,qBAAA,EAAAC,SAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,qBAAA;EACF,MAAMC,WAAW,GAAGP,QAAQ,oBAARA,QAAQ,CAAEO,WAAW;EACzC,MAAMC,OAAO,GAAGR,QAAQ,qBAAAE,qBAAA,GAARF,QAAQ,CAAES,aAAa,qBAAvBP,qBAAA,CAAyBM,OAAO;EAChD,MAAM1D,KAAK,GAAGH,YAAY,CAAC4D,WAAW,CAAC;EACvC,MAAMG,YAAY,GAAGH,WAAW,oBAAXA,WAAW,CAAEC,OAAO;EACzC,MAAM/B,MAAM,GACV,CAAA+B,OAAO,qBAAAL,SAAA,GAAPK,OAAO,CAAG,CAAC,CAAC,qBAAZL,SAAA,CAAcQ,GAAG,KAAKD,YAAY,IAAIjE,MAAM,CAACoC,IAAI,CAAC6B,YAAY,CAAC,CAAC,CAAC,CAAE;EAErE,MAAME,eAAe,GAAGX,gBAAgB,CAACY,IAAI,CAC3C,CAAAC,UAAU,UAAAC,gBAAA,QAAI,CAAAD,UAAU,qBAAAC,gBAAA,GAAVD,UAAU,CAAEE,IAAI,qBAAhBD,gBAAA,CAAkB3C,OAAO,MAAKA,OAAO,GACpD;EAED,MAAM6C,YAAY,GAAc;IAC9BxC,MAAM;IACNO,IAAI,EACF,CAAA4B,eAAe,qBAAAR,qBAAA,GAAfQ,eAAe,CAAEI,IAAI,qBAArBZ,qBAAA,CAAuBc,iBAAiB;IACxCN,eAAe,qBAAAP,sBAAA,GAAfO,eAAe,CAAEI,IAAI,qBAArBX,sBAAA,CAAuBc,SAAS;IAChC,EAAE;IACJhC,IAAI,EAAE,CAAC,KAAAmB,qBAAA,GAAIM,eAAe,oBAAfA,eAAe,CAAEQ,OAAO,YAAAd,qBAAA,GAAI,EAAE,CAAC,EAAE,CAAAM,eAAe,oBAAfA,eAAe,CAAES,EAAE,KAAI,EAAE,CAAC;IACtEpE,KAAK,EAAEH;GACR;EACD,OAAOmE,YAAY;AACrB,CAAC;AAED,MAAMK,wBAAwB,GAAgC,EAAE;AAChE,MAAMC,iCAAiC,GAQnC,EAAE;AACN;AACA,OAAO,MAAMC,wBAAwB,GAAGA,CACtCpD,OAAe,EACfoC,OAAkC,EAClCiB,WAA0C,EAC1CnC,KAAU,KACK;EACf;EACA;EACA,MAAMhB,cAAc,GAAGe,iBAAiB,CAACC,KAAK,CAAC;EAC/C,MAAMf,eAAe,GAAGoB,kBAAkB,CAACL,KAAK,CAAC;EACjD,MAAMoC,eAAe,GAAGjF,MAAM,CAACC,MAAM,CAAC8D,OAAO,CAAC,CAAC5D,MAAM,CACnD,CAAAA,MAAM,KAAIA,MAAM,CAACwB,OAAO,KAAKA,OAAO,CACrC;EACD,MAAMuD,mBAAmB,GAAGlF,MAAM,CAACmF,OAAO,CAACH,WAAW,CAAC;EACpD7E,MAAM,CAAC,CAAC,CAACsB,GAAG,CAAC,KACZwD,eAAe,CAACb,IAAI,CAAC,CAAAjE,MAAM,KAAIA,MAAM,CAACiF,YAAY,KAAK3D,GAAG,CAAC,CAC5D;EACAD,GAAG,CAAC,CAAC,GAAGZ,UAAU,CAAC,KAAKA,UAAU,CAAC;EAEtC,MAAMyE,gBAAgB,GAAGP,iCAAiC,CAACnD,OAAO,CAAC;EACnE,IACEkD,wBAAwB,CAAClD,OAAO,CAAC;EACjC/B,eAAe,CAACyF,gBAAgB,CAACxD,cAAc,EAAEA,cAAc,CAAC;EAChEjC,eAAe,CAACyF,gBAAgB,CAACvD,eAAe,EAAEA,eAAe,CAAC;EAClElC,eAAe,CAACyF,gBAAgB,CAACJ,eAAe,EAAEA,eAAe,CAAC;EAClErF,eAAe,CAACyF,gBAAgB,CAACH,mBAAmB,EAAEA,mBAAmB,CAAC,EAC1E;IACA,OAAOL,wBAAwB,CAAClD,OAAO,CAAC;;EAE1C,MAAM2D,UAAU,GAAGL,eAAe,CAAC1D,MAAM,CACvC,CAACgE,GAAG,EAAEpF,MAAM,KACVoF,GAAG,CAACC,MAAM,CACR9D,kCAAkC,CAChCC,OAAO,EACPxB,MAAM,EACN6E,WAAW,CAAC7E,MAAM,CAACiF,YAAY,CAAC,IAAI,EAAE,EACtCvD,cAAc,EACdC,eAAe,CAChB,CACF,EACH,EAAiB,CAClB;EACDwD,UAAU,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACnD,IAAI,CAACqD,aAAa,CAACD,CAAC,CAACpD,IAAI,CAAC,CAAC;EACvDsC,wBAAwB,CAAClD,OAAO,CAAC,GAAG2D,UAAU;EAC9CR,iCAAiC,CAACnD,OAAO,CAAC,GAAG;IAC3CE,cAAc;IACdC,eAAe;IACfmD,eAAe;IACfC;GACD;EACD,OAAOI,UAAU;AACnB,CAAC;AAED,MAAMvD,SAAS,GAAGA,CAAC,EACjB1B,KAAK,EACL2B,MAAM,EACN6D,IAAI,GAAGxG,YAAY,CAACyG,aAAa,EACjChE,eAAe,EACfD,cAAc,EAOf,KAAqB;EACpB;EACA,MAAMkE,QAAQ,GAAG1F,KAAK,KAAK,IAAI;EAC/B,MAAM2F,cAAc,GAClBH,IAAI,KAAKxG,YAAY,CAAC4G,YAAY;EAC9BpG,eAAe,CAACqG,kBAAkB;EAClCrG,eAAe,CAACoC,OAAO;EAC7B,IAAI,CAACD,MAAM,IAAI+D,QAAQ,EAAE;IACvB;IACA,OAAOC,cAAc;;EAEvB,IAAIhE,MAAM,IAAIF,eAAe,YAAfA,eAAe,CAAEX,GAAG,CAACa,MAAM,CAAC;EACxC,OAAOnC,eAAe,CAACqC,YAAY;EACrC,IAAIF,MAAM,IAAIH,cAAc,YAAdA,cAAc,CAAEV,GAAG,CAACa,MAAM,CAAC,IAAI+D,QAAQ,EAAE;IACrD,OAAOC,cAAc;;EAEvB,OAAOnG,eAAe,CAACsC,KAAK;AAC9B,CAAC;AAED,MAAMgE,kBAAkB,GAAG,EAAE;AAC7B,OAAO,MAAMC,uBAAuB,GAAGA,CACrC7C,QAA6B,EAC7B5B,OAAe,EACf6B,gBAA8B,EAC9B6C,kBAAA,GAAyCF,kBAAkB,EAC3DtE,cAA2B,EAC3BC,eAA4B,EAC5BwE,aAAa,GAAG,KAAK,KACmB;EACxC,IAAIC,qBAAqB,GAAyC,EAAE;EACpEA,qBAAqB,GAAGvG,MAAM,CAACC,MAAM,CAACoG,kBAAkB,CAAC;EACtDlG,MAAM,CAAC,CAAAqG,WAAW,KAAG,KAAAC,qBAAA,EAAAC,sBAAA;IACpB,MAAMC,OAAO,IAAAF,qBAAA,GACXD,WAAW,CAACI,YAAY,sBAAAF,sBAAA,GAAxBD,qBAAA,CAA0BI,aAAa,qBAAvCH,sBAAA,CAAyCpG,QAAQ,CAACqB,OAAO,CAAC;IAC5D,IAAI,CAAC2E,aAAa,IAAIK,OAAO,EAAE;MAC7B,OAAO,IAAI;;IAEb,IAAIL,aAAa,IAAI,CAACK,OAAO,EAAE;MAC7B,OAAO,IAAI;;IAEb,OAAO,KAAK;EACd,CAAC,CAAC;EACDnF,GAAG,CAAC,CAAAgF,WAAW,KAAG;IACjB,MAAMM,eAAe,GAAGxD,uBAAuB,CAC7CyD,MAAM,CAACP,WAAW,CAAC5B,EAAE,CAAC,EACtBrB,QAAQ,CAACiD,WAAW,CAAC5B,EAAE,CAAC,EACxBpB,gBAAgB,CACjB;IACD,MAAMwD,YAAY,GAAGjF,SAAS,CAAC;MAC7B1B,KAAK,EAAEyG,eAAe,CAACtG,KAAK;MAC5BwB,MAAM,EAAE8E,eAAe,CAAC9E,MAAM;MAC1BzC,cAAc,CAACuH,eAAe,CAAC9E,MAAM,CAAC;MACtCzB,SAAS;MACbsF,IAAI,EAAExG,YAAY,CAAC4G,YAAY;MAC/BpE,cAAc;MACdC;KACD,CAAC;IAEF,OAAO,EAAE,GAAGgF,eAAe,EAAErE,MAAM,EAAEuE,YAAY,EAAE;EACrD,CAAC,CAAC;EACD7G,MAAM,CAAC,CAAAA,MAAM,KAAIA,MAAM,CAACsC,MAAM,KAAK5C,eAAe,CAACqG,kBAAkB,CAAC;EAEzE,OAAOK,qBAAqB;AAC9B,CAAC;AAED,MAAMU,8BAA8B,GAAwB,EAAE;AAC9D,MAAMC,8BAA8B,GAUhC,EAAE;AACN,OAAO,MAAMC,8BAA8B,GAAGA,CAC5CC,aAAsB,EACtB7D,QAA6B,EAC7B5B,OAAe,EACfkB,KAAU,EACVW,gBAA8B,EAC9B6C,kBAAA,GAAyCF,kBAAkB,KAC5C;EACf,MAAMtE,cAAc,GAAGe,iBAAiB,CAACC,KAAK,CAAC;EAC/C,MAAMf,eAAe,GAAGoB,kBAAkB,CAACL,KAAK,CAAC;EAEjD,MAAMwC,gBAAgB,GAAG6B,8BAA8B,CAACvF,OAAO,CAAC;EAChE,IACEsF,8BAA8B,CAACtF,OAAO,CAAC;EACvC/B,eAAe,CAACyF,gBAAgB,oBAAhBA,gBAAgB,CAAExD,cAAc,EAAEA,cAAc,CAAC;EACjEjC,eAAe,CAACyF,gBAAgB,oBAAhBA,gBAAgB,CAAEvD,eAAe,EAAEA,eAAe,CAAC;EACnE,CAAAuD,gBAAgB,oBAAhBA,gBAAgB,CAAE+B,aAAa,MAAKA,aAAa;EACjD,CAAA/B,gBAAgB,oBAAhBA,gBAAgB,CAAE7B,gBAAgB,MAAKA,gBAAgB;EACvD,CAAA6B,gBAAgB,oBAAhBA,gBAAgB,CAAEgB,kBAAkB,MAAKA,kBAAkB;EAC3D,CAAAhB,gBAAgB,oBAAhBA,gBAAgB,CAAE9B,QAAQ,MAAKA,QAAQ,EACvC;IACA,OAAO0D,8BAA8B,CAACtF,OAAO,CAAC;;EAGhD,MAAM0F,sBAAsB,GAC1BD,aAAa;EACbpH,MAAM,CAACC,MAAM,CAACmH,aAAa,CAAC;EACzBjH,MAAM,CACL,CAAAmH,YAAY,UAAAC,qBAAA,QACVD,YAAY,CAACzB,IAAI,KAAKrG,gBAAgB,CAACgI,YAAY,MAAAD,qBAAA;IACnDD,YAAY,CAACT,aAAa,qBAA1BU,qBAAA,CAA4BjH,QAAQ,CAACqB,OAAO,CAAC,IAChD;EACAH,GAAG,CAAC,CAAA8F,YAAY,KAAG,KAAAG,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,EAAAC,qBAAA;IAClB,MAAM5F,MAAM,IAAAyF,qBAAA,GAAGH,YAAY,CAACO,OAAO,sBAAAH,sBAAA,GAApBD,qBAAA,CAAuB,CAAC,CAAC,sBAAAE,sBAAA,GAAzBD,sBAAA,CAA2B1F,MAAM,qBAAjC2F,sBAAA,CAAmCpF,IAAI;IACtD,MAAMuB,WAAW,IAAA8D,qBAAA,GAAGrE,QAAQ,CAAC+D,YAAY,CAAC1C,EAAE,CAAC,qBAAzBgD,qBAAA,CAA2B9D,WAAW;IAC1D,MAAMzD,KAAK,GAAGH,YAAY,CAAC4D,WAAW,CAAC;IACvC,OAAO;MACL9B,MAAM;MACNO,IAAI,EAAE+E,YAAY,CAAC/E,IAAI;MACvBG,IAAI,EAAE,CAAC4E,YAAY,CAAC1C,EAAE,CAAC;MACvBnC,MAAM,EAAEV,SAAS,CAAC;QAChB1B,KAAK;QACL2B,MAAM;QACNF,eAAe;QACfD;OACD,CAAC;MACFrB,KAAK,EAAEH;KACR;EACH,CAAC,CAAC;EAEN,IAAIkG,qBAAqB,GAAyC,EAAE;EACpEA,qBAAqB,GAAGH,uBAAuB,CAC7C7C,QAAQ,EACR5B,OAAO,EACP6B,gBAAgB,EAChB6C,kBAAkB,EAClBxE,cAAc,EACdC,eAAe,CAChB;EACD,MAAMwD,UAAU,GAAGiB,qBAAqB,CAACf,MAAM,CAC7C6B,sBAAqC,CACtC;EACDJ,8BAA8B,CAACtF,OAAO,CAAC,GAAG2D,UAAU;EACpD4B,8BAA8B,CAACvF,OAAO,CAAC,GAAG;IACxCyF,aAAa;IACb5D,gBAAgB;IAChB6C,kBAAkB;IAClB9C,QAAQ;IACR1B,cAAc;IACdC;GACD;EACD,OAAOwD,UAAU;AACnB,CAAC,CAAC,mBAAAwC,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAzH,SAAA,MAAAuH,cAAA,WAAAA,cAAA,CAAAG,QAAA,CA7XUpI,eAKX,uHAAAiI,cAAA,CAAAG,QAAA,CAEKnI,uBAAuB,+HAAAgI,cAAA,CAAAG,QAAA,CAoBhB/H,YAAY,oHAAA4H,cAAA,CAAAG,QAAA,CAUnBvH,oBAAoB,4HAAAoH,cAAA,CAAAG,QAAA,CAmCpBvG,kCAAkC,0IAAAoG,cAAA,CAAAG,QAAA,CAgClCrF,iBAAiB,yHAAAkF,cAAA,CAAAG,QAAA,CAOjB/E,kBAAkB,0HAAA4E,cAAA,CAAAG,QAAA,CAiBX3E,uBAAuB,+HAAAwE,cAAA,CAAAG,QAAA,CA4B9BpD,wBAAwB,gIAAAiD,cAAA,CAAAG,QAAA,CACxBnD,iCAAiC,yIAAAgD,cAAA,CAAAG,QAAA,CAU1BlD,wBAAwB,gIAAA+C,cAAA,CAAAG,QAAA,CAqD/BlG,SAAS,iHAAA+F,cAAA,CAAAG,QAAA,CA+BT9B,kBAAkB,0HAAA2B,cAAA,CAAAG,QAAA,CACX7B,uBAAuB,+HAAA0B,cAAA,CAAAG,QAAA,CA6C9BhB,8BAA8B,sIAAAa,cAAA,CAAAG,QAAA,CAC9Bf,8BAA8B,sIAAAY,cAAA,CAAAG,QAAA,CAWvBd,8BAA8B,8JAAAe,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAA3H,SAAA,CAAA2H,WAAA,IAAAA,WAAA,CAAAC,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}