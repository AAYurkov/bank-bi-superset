{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DTTM_ALIAS } from '@superset-ui/core';\nimport { ForecastSeriesEnum } from '../types';\nimport { sanitizeHtml } from './series';\nconst seriesTypeRegex = new RegExp(`(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`);\nexport const extractForecastSeriesContext = (seriesName) => {\n  const name = seriesName;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch)\n  return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2]\n  };\n};\nexport const extractForecastSeriesContexts = (seriesNames) => seriesNames.reduce((agg, name) => {\n  const context = extractForecastSeriesContext(name);\n  const currentContexts = agg[context.name] || [];\n  currentContexts.push(context.type);\n  return { ...agg, [context.name]: currentContexts };\n}, {});\nexport const extractForecastValuesFromTooltipParams = (params, isHorizontal = false) => {\n  const values = {};\n  params.forEach((param) => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (typeof numericValue === 'number') {\n      if (!(context.name in values))\n      values[context.name] = {\n        marker: marker || ''\n      };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n      forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n      forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n      forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n      forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\nexport const formatForecastTooltipSeries = ({ seriesName, observation, forecastTrend, forecastLower, forecastUpper, marker, formatter }) => {\n  const name = `${marker}${sanitizeHtml(seriesName)}`;\n  let value = typeof observation === 'number' ? formatter(observation) : '';\n  if (forecastTrend || forecastLower || forecastUpper) {\n    // forecast values take the form of \"20, y = 30 (10, 40)\"\n    // where the first part is the observation, the second part is the forecast trend\n    // and the third part is the lower and upper bounds\n    if (forecastTrend) {\n      if (value)\n      value += ', ';\n      value += `ŷ = ${formatter(forecastTrend)}`;\n    }\n    if (forecastLower && forecastUpper) {\n      if (value)\n      value += ' ';\n      // the lower bound needs to be added to the upper bound\n      value += `(${formatter(forecastLower)}, ${formatter(forecastLower + forecastUpper)})`;\n    }\n  }\n  return [name, value];\n};\nexport function rebaseForecastDatum(data, verboseMap = {}) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n  return data.map((row) => {\n    const newRow = {};\n    keys.forEach((key) => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey = key !== DTTM_ALIAS && verboseMap[forecastContext.name] ?\n      `${verboseMap[forecastContext.name]}${forecastContext.type}` :\n      key;\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key];\n      if (forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n      keys.includes(lowerForecastKey) &&\n      value !== null &&\n      row[lowerForecastKey] !== null) {\n        value -= row[lowerForecastKey];\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}\n// For Confidence Bands, forecast series on mixed charts require the series sent in the following sortOrder:\nexport function reorderForecastSeries(row) {\n  const sortOrder = {\n    [ForecastSeriesEnum.ForecastLower]: 1,\n    [ForecastSeriesEnum.ForecastUpper]: 2,\n    [ForecastSeriesEnum.ForecastTrend]: 3,\n    [ForecastSeriesEnum.Observation]: 4\n  };\n  // Check if any item needs reordering\n  if (!row.some((item) => item.id &&\n  sortOrder.hasOwnProperty(extractForecastSeriesContext(item.id).type))) {\n    return row;\n  }\n  return row.sort((a, b) => {var _sortOrder$extractFor, _a$id, _sortOrder$extractFor2, _b$id;\n    const aOrder = (_sortOrder$extractFor = sortOrder[extractForecastSeriesContext((_a$id = a.id) != null ? _a$id : '').type]) != null ? _sortOrder$extractFor :\n    Number.MAX_SAFE_INTEGER;\n    const bOrder = (_sortOrder$extractFor2 = sortOrder[extractForecastSeriesContext((_b$id = b.id) != null ? _b$id : '').type]) != null ? _sortOrder$extractFor2 :\n    Number.MAX_SAFE_INTEGER;\n    return aOrder - bOrder;\n  });\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(seriesTypeRegex, \"seriesTypeRegex\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastSeriesContext, \"extractForecastSeriesContext\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastSeriesContexts, \"extractForecastSeriesContexts\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(extractForecastValuesFromTooltipParams, \"extractForecastValuesFromTooltipParams\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(formatForecastTooltipSeries, \"formatForecastTooltipSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(rebaseForecastDatum, \"rebaseForecastDatum\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");reactHotLoader.register(reorderForecastSeries, \"reorderForecastSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["DTTM_ALIAS","ForecastSeriesEnum","sanitizeHtml","seriesTypeRegex","RegExp","ForecastLower","ForecastTrend","ForecastUpper","extractForecastSeriesContext","seriesName","name","regexMatch","exec","type","Observation","extractForecastSeriesContexts","seriesNames","reduce","agg","context","currentContexts","push","extractForecastValuesFromTooltipParams","params","isHorizontal","values","forEach","param","marker","seriesId","value","numericValue","forecastValues","observation","forecastTrend","forecastLower","forecastUpper","formatForecastTooltipSeries","formatter","rebaseForecastDatum","data","verboseMap","keys","length","Object","map","row","newRow","key","forecastContext","verboseKey","lowerForecastKey","includes","reorderForecastSeries","sortOrder","some","item","id","hasOwnProperty","sort","a","b","_sortOrder$extractFor","_a$id","_sortOrder$extractFor2","_b$id","aOrder","Number","MAX_SAFE_INTEGER","bOrder","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/forecast.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataRecord, DTTM_ALIAS, ValueFormatter } from '@superset-ui/core';\nimport type { OptionName, SeriesOption } from 'echarts/types/src/util/types';\nimport type { TooltipMarker } from 'echarts/types/src/util/format';\nimport {\n  ForecastSeriesContext,\n  ForecastSeriesEnum,\n  ForecastValue,\n} from '../types';\nimport { sanitizeHtml } from './series';\n\nconst seriesTypeRegex = new RegExp(\n  `(.+)(${ForecastSeriesEnum.ForecastLower}|${ForecastSeriesEnum.ForecastTrend}|${ForecastSeriesEnum.ForecastUpper})$`,\n);\nexport const extractForecastSeriesContext = (\n  seriesName: OptionName,\n): ForecastSeriesContext => {\n  const name = seriesName as string;\n  const regexMatch = seriesTypeRegex.exec(name);\n  if (!regexMatch) return { name, type: ForecastSeriesEnum.Observation };\n  return {\n    name: regexMatch[1],\n    type: regexMatch[2] as ForecastSeriesEnum,\n  };\n};\n\nexport const extractForecastSeriesContexts = (\n  seriesNames: string[],\n): { [key: string]: ForecastSeriesEnum[] } =>\n  seriesNames.reduce(\n    (agg, name) => {\n      const context = extractForecastSeriesContext(name);\n      const currentContexts = agg[context.name] || [];\n      currentContexts.push(context.type);\n      return { ...agg, [context.name]: currentContexts };\n    },\n    {} as { [key: string]: ForecastSeriesEnum[] },\n  );\n\nexport const extractForecastValuesFromTooltipParams = (\n  params: any[],\n  isHorizontal = false,\n): Record<string, ForecastValue> => {\n  const values: Record<string, ForecastValue> = {};\n  params.forEach(param => {\n    const { marker, seriesId, value } = param;\n    const context = extractForecastSeriesContext(seriesId);\n    const numericValue = isHorizontal ? value[0] : value[1];\n    if (typeof numericValue === 'number') {\n      if (!(context.name in values))\n        values[context.name] = {\n          marker: marker || '',\n        };\n      const forecastValues = values[context.name];\n      if (context.type === ForecastSeriesEnum.Observation)\n        forecastValues.observation = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastTrend)\n        forecastValues.forecastTrend = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastLower)\n        forecastValues.forecastLower = numericValue;\n      if (context.type === ForecastSeriesEnum.ForecastUpper)\n        forecastValues.forecastUpper = numericValue;\n    }\n  });\n  return values;\n};\n\nexport const formatForecastTooltipSeries = ({\n  seriesName,\n  observation,\n  forecastTrend,\n  forecastLower,\n  forecastUpper,\n  marker,\n  formatter,\n}: ForecastValue & {\n  seriesName: string;\n  marker: TooltipMarker;\n  formatter: ValueFormatter;\n}): string[] => {\n  const name = `${marker}${sanitizeHtml(seriesName)}`;\n  let value = typeof observation === 'number' ? formatter(observation) : '';\n  if (forecastTrend || forecastLower || forecastUpper) {\n    // forecast values take the form of \"20, y = 30 (10, 40)\"\n    // where the first part is the observation, the second part is the forecast trend\n    // and the third part is the lower and upper bounds\n    if (forecastTrend) {\n      if (value) value += ', ';\n      value += `ŷ = ${formatter(forecastTrend)}`;\n    }\n    if (forecastLower && forecastUpper) {\n      if (value) value += ' ';\n      // the lower bound needs to be added to the upper bound\n      value += `(${formatter(forecastLower)}, ${formatter(\n        forecastLower + forecastUpper,\n      )})`;\n    }\n  }\n  return [name, value];\n};\n\nexport function rebaseForecastDatum(\n  data: DataRecord[],\n  verboseMap: Record<string, string> = {},\n) {\n  const keys = data.length ? Object.keys(data[0]) : [];\n\n  return data.map(row => {\n    const newRow: DataRecord = {};\n    keys.forEach(key => {\n      const forecastContext = extractForecastSeriesContext(key);\n      const verboseKey =\n        key !== DTTM_ALIAS && verboseMap[forecastContext.name]\n          ? `${verboseMap[forecastContext.name]}${forecastContext.type}`\n          : key;\n\n      // check if key is equal to lower confidence level. If so, extract it\n      // from the upper bound\n      const lowerForecastKey = `${forecastContext.name}${ForecastSeriesEnum.ForecastLower}`;\n      let value = row[key] as number | null;\n      if (\n        forecastContext.type === ForecastSeriesEnum.ForecastUpper &&\n        keys.includes(lowerForecastKey) &&\n        value !== null &&\n        row[lowerForecastKey] !== null\n      ) {\n        value -= row[lowerForecastKey] as number;\n      }\n      newRow[verboseKey] = value;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return newRow;\n  });\n}\n\n// For Confidence Bands, forecast series on mixed charts require the series sent in the following sortOrder:\nexport function reorderForecastSeries(row: SeriesOption[]): SeriesOption[] {\n  const sortOrder = {\n    [ForecastSeriesEnum.ForecastLower]: 1,\n    [ForecastSeriesEnum.ForecastUpper]: 2,\n    [ForecastSeriesEnum.ForecastTrend]: 3,\n    [ForecastSeriesEnum.Observation]: 4,\n  };\n\n  // Check if any item needs reordering\n  if (\n    !row.some(\n      item =>\n        item.id &&\n        sortOrder.hasOwnProperty(extractForecastSeriesContext(item.id).type),\n    )\n  ) {\n    return row;\n  }\n\n  return row.sort((a, b) => {\n    const aOrder =\n      sortOrder[extractForecastSeriesContext(a.id ?? '').type] ??\n      Number.MAX_SAFE_INTEGER;\n    const bOrder =\n      sortOrder[extractForecastSeriesContext(b.id ?? '').type] ??\n      Number.MAX_SAFE_INTEGER;\n    return aOrder - bOrder;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}