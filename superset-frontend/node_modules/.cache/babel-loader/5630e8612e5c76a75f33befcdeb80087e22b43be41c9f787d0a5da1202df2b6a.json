{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport callApiAndParseWithTimeout from './callApi/callApiAndParseWithTimeout';\nimport { DEFAULT_FETCH_RETRY_OPTIONS, DEFAULT_APP_ROOT } from './constants';\nconst defaultUnauthorizedHandlerForPrefix = (appRoot) => () => {\n  if (!window.location.pathname.startsWith(`${appRoot}/login`)) {\n    window.location.href = `${appRoot}/login?next=${window.location.href}`;\n  }\n};\nexport default class SupersetClientClass {\n\n\n\n\n\n\n\n\n\n\n\n\n\n  constructor({ host, protocol, appRoot = DEFAULT_APP_ROOT, headers = {}, fetchRetryOptions = {}, mode = 'same-origin', timeout, credentials = undefined, csrfToken = undefined, guestToken = undefined, guestTokenHeaderName = 'X-GuestToken', unauthorizedHandler = undefined } = {}) {this.credentials = void 0;this.csrfToken = void 0;this.csrfPromise = void 0;this.guestToken = void 0;this.guestTokenHeaderName = void 0;this.fetchRetryOptions = void 0;this.appRoot = void 0;this.protocol = void 0;this.host = void 0;this.headers = void 0;this.mode = void 0;this.timeout = void 0;this.handleUnauthorized = void 0;\n    const url = new URL(`${protocol || 'https:'}//${host || 'localhost'}`);\n    this.appRoot = appRoot;\n    this.host = url.host;\n    this.protocol = url.protocol;\n    this.headers = { Accept: 'application/json', ...headers }; // defaulting accept to json\n    this.mode = mode;\n    this.timeout = timeout;\n    this.credentials = credentials;\n    this.csrfToken = csrfToken;\n    this.guestToken = guestToken;\n    this.guestTokenHeaderName = guestTokenHeaderName;\n    this.fetchRetryOptions = {\n      ...DEFAULT_FETCH_RETRY_OPTIONS,\n      ...fetchRetryOptions\n    };\n    if (typeof this.csrfToken === 'string') {\n      this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n      this.csrfPromise = Promise.resolve(this.csrfToken);\n    }\n    if (guestToken) {\n      this.headers[guestTokenHeaderName] = guestToken;\n    }\n    this.handleUnauthorized =\n    unauthorizedHandler !== undefined ?\n    unauthorizedHandler :\n    defaultUnauthorizedHandlerForPrefix(this.appRoot);\n  }\n  async init(force = false) {\n    if (this.isAuthenticated() && !force) {\n      return this.csrfPromise;\n    }\n    return this.getCSRFToken();\n  }\n  async postForm(url, payload, target = '_blank') {\n    if (url) {\n      await this.ensureAuth();\n      const hiddenForm = document.createElement('form');\n      hiddenForm.action = url;\n      hiddenForm.method = 'POST';\n      hiddenForm.target = target;\n      const payloadWithToken = {\n        ...payload,\n        csrf_token: this.csrfToken\n      };\n      if (this.guestToken) {\n        payloadWithToken.guest_token = this.guestToken;\n      }\n      Object.entries(payloadWithToken).forEach(([key, value]) => {\n        const data = document.createElement('input');\n        data.type = 'hidden';\n        data.name = key;\n        data.value = value;\n        hiddenForm.appendChild(data);\n      });\n      document.body.appendChild(hiddenForm);\n      hiddenForm.submit();\n      document.body.removeChild(hiddenForm);\n    }\n  }\n  async reAuthenticate() {\n    return this.init(true);\n  }\n  isAuthenticated() {\n    // if CSRF protection is disabled in the Superset app, the token may be an empty string\n    return this.csrfToken !== null && this.csrfToken !== undefined;\n  }\n  getGuestToken() {\n    return this.guestToken;\n  }\n  async get(requestConfig) {\n    return this.request({ ...requestConfig, method: 'GET' });\n  }\n  async delete(requestConfig) {\n    return this.request({ ...requestConfig, method: 'DELETE' });\n  }\n  async put(requestConfig) {\n    return this.request({ ...requestConfig, method: 'PUT' });\n  }\n  async post(requestConfig) {\n    return this.request({ ...requestConfig, method: 'POST' });\n  }\n  async request({ credentials, mode, endpoint, host, url, headers, timeout, fetchRetryOptions, ignoreUnauthorized = false, ...rest }) {\n    await this.ensureAuth();\n    return callApiAndParseWithTimeout({\n      ...rest,\n      credentials: credentials != null ? credentials : this.credentials,\n      mode: mode != null ? mode : this.mode,\n      url: this.getUrl({ endpoint, host, url }),\n      headers: { ...this.headers, ...headers },\n      timeout: timeout != null ? timeout : this.timeout,\n      fetchRetryOptions: fetchRetryOptions != null ? fetchRetryOptions : this.fetchRetryOptions\n    }).catch((res) => {\n      if ((res == null ? void 0 : res.status) === 401 && !ignoreUnauthorized) {\n        this.handleUnauthorized();\n      }\n      return Promise.reject(res);\n    });\n  }\n  async ensureAuth() {var _this$csrfPromise;\n    return (_this$csrfPromise = this.csrfPromise) != null ? _this$csrfPromise :\n    // eslint-disable-next-line prefer-promise-reject-errors\n    Promise.reject({\n      error: `SupersetClient has not been provided a CSRF token, ensure it is\n        initialized with \\`client.getCSRFToken()\\` or try logging in at\n        ${this.getUrl({ endpoint: '/login' })}`\n    });\n  }\n  async getCSRFToken() {\n    this.csrfToken = undefined;\n    // If we can request this resource successfully, it means that the user has\n    // authenticated. If not we throw an error prompting to authenticate.\n    this.csrfPromise = callApiAndParseWithTimeout({\n      credentials: this.credentials,\n      headers: {\n        ...this.headers\n      },\n      method: 'GET',\n      mode: this.mode,\n      timeout: this.timeout,\n      url: this.getUrl({ endpoint: '/api/v1/security/csrf_token/' }),\n      parseMethod: 'json'\n    }).then(({ json }) => {\n      if (typeof json === 'object') {\n        this.csrfToken = json.result;\n        if (typeof this.csrfToken === 'string') {\n          this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n        }\n      }\n      if (this.isAuthenticated()) {\n        return this.csrfToken;\n      }\n      // eslint-disable-next-line prefer-promise-reject-errors\n      return Promise.reject({ error: 'Failed to fetch CSRF token' });\n    });\n    return this.csrfPromise;\n  }\n  getUrl({ host: inputHost, endpoint = '', url } = {}) {\n    if (typeof url === 'string')\n    return url;\n    const host = inputHost != null ? inputHost : this.host;\n    const cleanHost = host.slice(-1) === '/' ? host.slice(0, -1) : host; // no backslash\n    return `${this.protocol}//${cleanHost}${this.appRoot}/${endpoint[0] === '/' ? endpoint.slice(1) : endpoint}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(defaultUnauthorizedHandlerForPrefix, \"defaultUnauthorizedHandlerForPrefix\", \"/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/connection/SupersetClientClass.ts\");reactHotLoader.register(SupersetClientClass, \"SupersetClientClass\", \"/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/connection/SupersetClientClass.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["callApiAndParseWithTimeout","DEFAULT_FETCH_RETRY_OPTIONS","DEFAULT_APP_ROOT","defaultUnauthorizedHandlerForPrefix","appRoot","window","location","pathname","startsWith","href","SupersetClientClass","constructor","host","protocol","headers","fetchRetryOptions","mode","timeout","credentials","undefined","csrfToken","guestToken","guestTokenHeaderName","unauthorizedHandler","csrfPromise","handleUnauthorized","url","URL","Accept","Promise","resolve","init","force","isAuthenticated","getCSRFToken","postForm","payload","target","ensureAuth","hiddenForm","document","createElement","action","method","payloadWithToken","csrf_token","guest_token","Object","entries","forEach","key","value","data","type","name","appendChild","body","submit","removeChild","reAuthenticate","getGuestToken","get","requestConfig","request","delete","put","post","endpoint","ignoreUnauthorized","rest","getUrl","catch","res","status","reject","_this$csrfPromise","error","parseMethod","then","json","result","inputHost","cleanHost","slice","__reactstandin__regenerateByEval","code","eval","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/connection/SupersetClientClass.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport callApiAndParseWithTimeout from './callApi/callApiAndParseWithTimeout';\nimport {\n  ClientConfig,\n  ClientTimeout,\n  Credentials,\n  CsrfPromise,\n  CsrfToken,\n  FetchRetryOptions,\n  Headers,\n  Host,\n  Mode,\n  Protocol,\n  RequestConfig,\n  ParseMethod,\n} from './types';\nimport { DEFAULT_FETCH_RETRY_OPTIONS, DEFAULT_APP_ROOT } from './constants';\n\nconst defaultUnauthorizedHandlerForPrefix = (appRoot: string) => () => {\n  if (!window.location.pathname.startsWith(`${appRoot}/login`)) {\n    window.location.href = `${appRoot}/login?next=${window.location.href}`;\n  }\n};\n\nexport default class SupersetClientClass {\n  credentials: Credentials;\n\n  csrfToken?: CsrfToken;\n\n  csrfPromise?: CsrfPromise;\n\n  guestToken?: string;\n\n  guestTokenHeaderName: string;\n\n  fetchRetryOptions?: FetchRetryOptions;\n\n  appRoot?: string;\n\n  protocol: Protocol;\n\n  host: Host;\n\n  headers: Headers;\n\n  mode: Mode;\n\n  timeout: ClientTimeout;\n\n  handleUnauthorized: () => void;\n\n  constructor({\n    host,\n    protocol,\n    appRoot = DEFAULT_APP_ROOT,\n    headers = {},\n    fetchRetryOptions = {},\n    mode = 'same-origin',\n    timeout,\n    credentials = undefined,\n    csrfToken = undefined,\n    guestToken = undefined,\n    guestTokenHeaderName = 'X-GuestToken',\n    unauthorizedHandler = undefined,\n  }: ClientConfig = {}) {\n    const url = new URL(`${protocol || 'https:'}//${host || 'localhost'}`);\n    this.appRoot = appRoot;\n    this.host = url.host;\n    this.protocol = url.protocol as Protocol;\n    this.headers = { Accept: 'application/json', ...headers }; // defaulting accept to json\n    this.mode = mode;\n    this.timeout = timeout;\n    this.credentials = credentials;\n    this.csrfToken = csrfToken;\n    this.guestToken = guestToken;\n    this.guestTokenHeaderName = guestTokenHeaderName;\n    this.fetchRetryOptions = {\n      ...DEFAULT_FETCH_RETRY_OPTIONS,\n      ...fetchRetryOptions,\n    };\n    if (typeof this.csrfToken === 'string') {\n      this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n      this.csrfPromise = Promise.resolve(this.csrfToken);\n    }\n    if (guestToken) {\n      this.headers[guestTokenHeaderName] = guestToken;\n    }\n    this.handleUnauthorized =\n      unauthorizedHandler !== undefined\n        ? unauthorizedHandler\n        : defaultUnauthorizedHandlerForPrefix(this.appRoot);\n  }\n\n  async init(force = false): CsrfPromise {\n    if (this.isAuthenticated() && !force) {\n      return this.csrfPromise as CsrfPromise;\n    }\n    return this.getCSRFToken();\n  }\n\n  async postForm(url: string, payload: Record<string, any>, target = '_blank') {\n    if (url) {\n      await this.ensureAuth();\n      const hiddenForm = document.createElement('form');\n      hiddenForm.action = url;\n      hiddenForm.method = 'POST';\n      hiddenForm.target = target;\n      const payloadWithToken: Record<string, any> = {\n        ...payload,\n        csrf_token: this.csrfToken!,\n      };\n\n      if (this.guestToken) {\n        payloadWithToken.guest_token = this.guestToken;\n      }\n\n      Object.entries(payloadWithToken).forEach(([key, value]) => {\n        const data = document.createElement('input');\n        data.type = 'hidden';\n        data.name = key;\n        data.value = value;\n        hiddenForm.appendChild(data);\n      });\n\n      document.body.appendChild(hiddenForm);\n      hiddenForm.submit();\n      document.body.removeChild(hiddenForm);\n    }\n  }\n\n  async reAuthenticate() {\n    return this.init(true);\n  }\n\n  isAuthenticated(): boolean {\n    // if CSRF protection is disabled in the Superset app, the token may be an empty string\n    return this.csrfToken !== null && this.csrfToken !== undefined;\n  }\n\n  getGuestToken() {\n    return this.guestToken;\n  }\n\n  async get<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'GET' });\n  }\n\n  async delete<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'DELETE' });\n  }\n\n  async put<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'PUT' });\n  }\n\n  async post<T extends ParseMethod = 'json'>(\n    requestConfig: RequestConfig & { parseMethod?: T },\n  ) {\n    return this.request({ ...requestConfig, method: 'POST' });\n  }\n\n  async request<T extends ParseMethod = 'json'>({\n    credentials,\n    mode,\n    endpoint,\n    host,\n    url,\n    headers,\n    timeout,\n    fetchRetryOptions,\n    ignoreUnauthorized = false,\n    ...rest\n  }: RequestConfig & { parseMethod?: T }) {\n    await this.ensureAuth();\n    return callApiAndParseWithTimeout({\n      ...rest,\n      credentials: credentials ?? this.credentials,\n      mode: mode ?? this.mode,\n      url: this.getUrl({ endpoint, host, url }),\n      headers: { ...this.headers, ...headers },\n      timeout: timeout ?? this.timeout,\n      fetchRetryOptions: fetchRetryOptions ?? this.fetchRetryOptions,\n    }).catch(res => {\n      if (res?.status === 401 && !ignoreUnauthorized) {\n        this.handleUnauthorized();\n      }\n      return Promise.reject(res);\n    });\n  }\n\n  async ensureAuth(): CsrfPromise {\n    return (\n      this.csrfPromise ??\n      // eslint-disable-next-line prefer-promise-reject-errors\n      Promise.reject({\n        error: `SupersetClient has not been provided a CSRF token, ensure it is\n        initialized with \\`client.getCSRFToken()\\` or try logging in at\n        ${this.getUrl({ endpoint: '/login' })}`,\n      })\n    );\n  }\n\n  async getCSRFToken() {\n    this.csrfToken = undefined;\n    // If we can request this resource successfully, it means that the user has\n    // authenticated. If not we throw an error prompting to authenticate.\n    this.csrfPromise = callApiAndParseWithTimeout({\n      credentials: this.credentials,\n      headers: {\n        ...this.headers,\n      },\n      method: 'GET',\n      mode: this.mode,\n      timeout: this.timeout,\n      url: this.getUrl({ endpoint: '/api/v1/security/csrf_token/' }),\n      parseMethod: 'json',\n    }).then(({ json }) => {\n      if (typeof json === 'object') {\n        this.csrfToken = json.result as string;\n        if (typeof this.csrfToken === 'string') {\n          this.headers = { ...this.headers, 'X-CSRFToken': this.csrfToken };\n        }\n      }\n      if (this.isAuthenticated()) {\n        return this.csrfToken;\n      }\n      // eslint-disable-next-line prefer-promise-reject-errors\n      return Promise.reject({ error: 'Failed to fetch CSRF token' });\n    });\n    return this.csrfPromise;\n  }\n\n  getUrl({\n    host: inputHost,\n    endpoint = '',\n    url,\n  }: {\n    endpoint?: string;\n    host?: Host;\n    url?: string;\n  } = {}) {\n    if (typeof url === 'string') return url;\n\n    const host = inputHost ?? this.host;\n    const cleanHost = host.slice(-1) === '/' ? host.slice(0, -1) : host; // no backslash\n\n    return `${this.protocol}//${cleanHost}${this.appRoot}/${\n      endpoint[0] === '/' ? endpoint.slice(1) : endpoint\n    }`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}