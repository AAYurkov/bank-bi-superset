{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ActionCreators as UndoActionCreators } from 'redux-undo';\nimport rison from 'rison';\nimport {\n  ensureIsArray,\n  isFeatureEnabled,\n  FeatureFlag,\n  getLabelsColorMap,\n  SupersetClient,\n  t,\n  getClientErrorObject,\n  getCategoricalSchemeRegistry,\n  promiseTimeout } from\n'@superset-ui/core';\nimport {\n  addChart,\n  removeChart,\n  refreshChart } from\n'src/components/Chart/chartAction';\nimport { chart as initChart } from 'src/components/Chart/chartReducer';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport {\n  SAVE_TYPE_OVERWRITE,\n  SAVE_TYPE_OVERWRITE_CONFIRMED } from\n'src/dashboard/util/constants';\nimport {\n  getCrossFiltersConfiguration,\n  isCrossFiltersEnabled } from\n'src/dashboard/util/crossFilters';\nimport {\n  addSuccessToast,\n  addWarningToast,\n  addDangerToast } from\n'src/components/MessageToasts/actions';\nimport serializeActiveFilterValues from 'src/dashboard/util/serializeActiveFilterValues';\nimport serializeFilterScopes from 'src/dashboard/util/serializeFilterScopes';\nimport { getActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { logEvent } from 'src/logger/actions';\nimport { LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA } from 'src/logger/LogUtils';\n\nimport { navigateWithState } from 'src/utils/navigationUtils';\nimport { UPDATE_COMPONENTS_PARENTS_LIST } from './dashboardLayout';\nimport {\n  saveChartConfiguration,\n  dashboardInfoChanged,\n  SAVE_CHART_CONFIG_COMPLETE } from\n'./dashboardInfo';\nimport { fetchDatasourceMetadata, setDatasources } from './datasources';\nimport { updateDirectPathToFilter } from './dashboardFilters';\nimport { SET_IN_SCOPE_STATUS_OF_FILTERS } from './nativeFilters';\nimport getOverwriteItems from '../util/getOverwriteItems';\nimport {\n  applyColors,\n  enforceSharedLabelsColorsArray,\n  isLabelsColorMapSynced,\n  getColorSchemeDomain,\n  getColorNamespace,\n  getFreshLabelsColorMapEntries,\n  getFreshSharedLabels,\n  getDynamicLabelsColors } from\n'../../utils/colorScheme';\n\nexport const SET_UNSAVED_CHANGES = 'SET_UNSAVED_CHANGES';\nexport function setUnsavedChanges(hasUnsavedChanges) {\n  return { type: SET_UNSAVED_CHANGES, payload: { hasUnsavedChanges } };\n}\n\nexport const ADD_SLICE = 'ADD_SLICE';\nexport function addSlice(slice) {\n  return { type: ADD_SLICE, slice };\n}\n\nexport const REMOVE_SLICE = 'REMOVE_SLICE';\nexport function removeSlice(sliceId) {\n  return { type: REMOVE_SLICE, sliceId };\n}\n\nexport const TOGGLE_FAVE_STAR = 'TOGGLE_FAVE_STAR';\nexport function toggleFaveStar(isStarred) {\n  return { type: TOGGLE_FAVE_STAR, isStarred };\n}\n\nexport function fetchFaveStar(id) {\n  return function fetchFaveStarThunk(dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/dashboard/favorite_status/?q=${rison.encode([id])}`\n    }).\n    then(({ json }) => {var _json$result, _json$result$;\n      dispatch(toggleFaveStar(!!(json != null && (_json$result = json.result) != null && (_json$result$ = _json$result[0]) != null && _json$result$.value)));\n    }).\n    catch(() =>\n    dispatch(\n      addDangerToast(\n        t(\n          'There was an issue fetching the favorite status of this dashboard.'\n        )\n      )\n    )\n    );\n  };\n}\n\nexport function saveFaveStar(id, isStarred) {\n  return function saveFaveStarThunk(dispatch) {\n    const endpoint = `/api/v1/dashboard/${id}/favorites/`;\n    const apiCall = isStarred ?\n    SupersetClient.delete({\n      endpoint\n    }) :\n    SupersetClient.post({ endpoint });\n\n    return apiCall.\n    then(() => {\n      dispatch(toggleFaveStar(!isStarred));\n    }).\n    catch(() =>\n    dispatch(\n      addDangerToast(t('There was an issue favoriting this dashboard.'))\n    )\n    );\n  };\n}\n\nexport const TOGGLE_PUBLISHED = 'TOGGLE_PUBLISHED';\nexport function togglePublished(isPublished) {\n  return { type: TOGGLE_PUBLISHED, isPublished };\n}\n\nexport function savePublished(id, isPublished) {\n  return function savePublishedThunk(dispatch) {\n    return SupersetClient.put({\n      endpoint: `/api/v1/dashboard/${id}`,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        published: isPublished\n      })\n    }).\n    then(() => {\n      dispatch(\n        addSuccessToast(\n          isPublished ?\n          t('This dashboard is now published') :\n          t('This dashboard is now hidden')\n        )\n      );\n      dispatch(togglePublished(isPublished));\n    }).\n    catch(() => {\n      dispatch(\n        addDangerToast(\n          t('You do not have permissions to edit this dashboard.')\n        )\n      );\n    });\n  };\n}\n\nexport const TOGGLE_EXPAND_SLICE = 'TOGGLE_EXPAND_SLICE';\nexport function toggleExpandSlice(sliceId) {\n  return { type: TOGGLE_EXPAND_SLICE, sliceId };\n}\n\nexport const UPDATE_CSS = 'UPDATE_CSS';\nexport function updateCss(css) {\n  return { type: UPDATE_CSS, css };\n}\n\nexport const SET_EDIT_MODE = 'SET_EDIT_MODE';\nexport function setEditMode(editMode) {\n  return { type: SET_EDIT_MODE, editMode };\n}\n\nexport const ON_CHANGE = 'ON_CHANGE';\nexport function onChange() {\n  return { type: ON_CHANGE };\n}\n\nexport const ON_SAVE = 'ON_SAVE';\nexport function onSave(lastModifiedTime) {\n  return { type: ON_SAVE, lastModifiedTime };\n}\n\nexport const SET_REFRESH_FREQUENCY = 'SET_REFRESH_FREQUENCY';\nexport function setRefreshFrequency(refreshFrequency, isPersistent = false) {\n  return { type: SET_REFRESH_FREQUENCY, refreshFrequency, isPersistent };\n}\n\nexport function saveDashboardRequestSuccess(lastModifiedTime) {\n  return (dispatch) => {\n    dispatch(onSave(lastModifiedTime));\n    // clear layout undo history\n    dispatch(UndoActionCreators.clearHistory());\n  };\n}\n\nexport const SET_OVERRIDE_CONFIRM = 'SET_OVERRIDE_CONFIRM';\nexport function setOverrideConfirm(overwriteConfirmMetadata) {\n  return {\n    type: SET_OVERRIDE_CONFIRM,\n    overwriteConfirmMetadata\n  };\n}\n\nexport const SAVE_DASHBOARD_STARTED = 'SAVE_DASHBOARD_STARTED';\nexport function saveDashboardStarted() {\n  return { type: SAVE_DASHBOARD_STARTED };\n}\n\nexport const SAVE_DASHBOARD_FINISHED = 'SAVE_DASHBOARD_FINISHED';\nexport function saveDashboardFinished() {\n  return { type: SAVE_DASHBOARD_FINISHED };\n}\n\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE =\n'SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE';\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCED =\n'SET_DASHBOARD_LABELS_COLORMAP_SYNCED';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE =\n'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED =\n'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED';\n\nexport function setDashboardLabelsColorMapSync() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE };\n}\n\nexport function setDashboardLabelsColorMapSynced() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCED };\n}\n\nexport function setDashboardSharedLabelsColorsSync() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE };\n}\n\nexport function setDashboardSharedLabelsColorsSynced() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED };\n}\n\nexport const setDashboardMetadata =\n(updatedMetadata) => async (dispatch, getState) => {\n  const { dashboardInfo } = getState();\n  dispatch(\n    dashboardInfoChanged({\n      metadata: {\n        ...((dashboardInfo == null ? void 0 : dashboardInfo.metadata) || {}),\n        ...updatedMetadata\n      }\n    })\n  );\n};\n\nexport function saveDashboardRequest(data, id, saveType) {\n  return (dispatch, getState) => {var _data$metadata, _data$metadata2, _data$metadata3, _data$metadata4, _data$metadata5, _data$metadata6, _data$metadata7, _data$metadata8;\n    dispatch({ type: UPDATE_COMPONENTS_PARENTS_LIST });\n    dispatch(saveDashboardStarted());\n\n    const { dashboardFilters, dashboardLayout } = getState();\n    const layout = dashboardLayout.present;\n    Object.values(dashboardFilters).forEach((filter) => {var _layout$componentId;\n      const { chartId } = filter;\n      const componentId = filter.directPathToFilter.slice().pop();\n      const directPathToFilter = (((_layout$componentId = layout[componentId]) == null ? void 0 : _layout$componentId.parents) || []).slice();\n      directPathToFilter.push(componentId);\n      dispatch(updateDirectPathToFilter(chartId, directPathToFilter));\n    });\n    // serialize selected values for each filter field, grouped by filter id\n    const serializedFilters = serializeActiveFilterValues(getActiveFilters());\n    // serialize filter scope for each filter field, grouped by filter id\n    const serializedFilterScopes = serializeFilterScopes(dashboardFilters);\n    const {\n      certified_by,\n      certification_details,\n      css,\n      dashboard_title,\n      owners,\n      roles,\n      slug\n    } = data;\n\n    const hasId = (item) => item.id !== undefined;\n    const metadataCrossFiltersEnabled = (_data$metadata = data.metadata) == null ? void 0 : _data$metadata.cross_filters_enabled;\n    const colorScheme = (_data$metadata2 = data.metadata) == null ? void 0 : _data$metadata2.color_scheme;\n    const customLabelsColor = ((_data$metadata3 = data.metadata) == null ? void 0 : _data$metadata3.label_colors) || {};\n    const sharedLabelsColor = enforceSharedLabelsColorsArray((_data$metadata4 =\n    data.metadata) == null ? void 0 : _data$metadata4.shared_label_colors\n    );\n    const cleanedData = {\n      ...data,\n      certified_by: certified_by || '',\n      certification_details:\n      certified_by && certification_details ? certification_details : '',\n      css: css || '',\n      dashboard_title: dashboard_title || t('[ untitled dashboard ]'),\n      owners: ensureIsArray(owners).map((o) => hasId(o) ? o.id : o),\n      roles: !isFeatureEnabled(FeatureFlag.DashboardRbac) ?\n      undefined :\n      ensureIsArray(roles).map((r) => hasId(r) ? r.id : r),\n      slug: slug || null,\n      metadata: {\n        ...data.metadata,\n        color_namespace: getColorNamespace((_data$metadata5 = data.metadata) == null ? void 0 : _data$metadata5.color_namespace),\n        color_scheme: colorScheme || '',\n        color_scheme_domain: colorScheme ?\n        getColorSchemeDomain(colorScheme) :\n        [],\n        expanded_slices: ((_data$metadata6 = data.metadata) == null ? void 0 : _data$metadata6.expanded_slices) || {},\n        label_colors: customLabelsColor,\n        shared_label_colors: getFreshSharedLabels(sharedLabelsColor),\n        map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor),\n        refresh_frequency: ((_data$metadata7 = data.metadata) == null ? void 0 : _data$metadata7.refresh_frequency) || 0,\n        timed_refresh_immune_slices:\n        ((_data$metadata8 = data.metadata) == null ? void 0 : _data$metadata8.timed_refresh_immune_slices) || [],\n        // cross-filters should be enabled by default\n        cross_filters_enabled: isCrossFiltersEnabled(\n          metadataCrossFiltersEnabled\n        )\n      }\n    };\n\n    const handleChartConfiguration = () => {\n      const {\n        dashboardLayout,\n        charts,\n        dashboardInfo: { metadata }\n      } = getState();\n      return getCrossFiltersConfiguration(\n        dashboardLayout.present,\n        metadata,\n        charts\n      );\n    };\n\n    const onCopySuccess = (response) => {\n      const lastModifiedTime = response.json.result.last_modified_time;\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      const { chartConfiguration, globalChartConfiguration } =\n      handleChartConfiguration();\n      dispatch(\n        saveChartConfiguration({\n          chartConfiguration,\n          globalChartConfiguration\n        })\n      );\n      dispatch(saveDashboardFinished());\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      return response;\n    };\n\n    const onUpdateSuccess = (response) => {\n      const updatedDashboard = response.json.result;\n      const lastModifiedTime = response.json.last_modified_time;\n      // syncing with the backend transformations of the metadata\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(setDashboardMetadata(metadata));\n        if (metadata.chart_configuration) {\n          dispatch({\n            type: SAVE_CHART_CONFIG_COMPLETE,\n            chartConfiguration: metadata.chart_configuration\n          });\n        }\n        if (metadata.native_filter_configuration) {\n          dispatch({\n            type: SET_IN_SCOPE_STATUS_OF_FILTERS,\n            filterConfig: metadata.native_filter_configuration\n          });\n        }\n\n        // fetch datasets to make sure they are up to date\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}/datasets`,\n          headers: { 'Content-Type': 'application/json' }\n        }).then(({ json }) => {var _json$result2;\n          const datasources = (_json$result2 = json == null ? void 0 : json.result) != null ? _json$result2 : [];\n          if (datasources.length) {\n            dispatch(setDatasources(datasources));\n          }\n        });\n      }\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      dispatch(saveDashboardFinished());\n      // redirect to the new slug or id\n      navigateWithState(`/superset/dashboard/${slug || id}/`, {\n        event: 'dashboard_properties_changed'\n      });\n\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      dispatch(setOverrideConfirm(undefined));\n      return response;\n    };\n\n    const onError = async (response) => {\n      const { error, message } = await getClientErrorObject(response);\n      let errorText = t('Sorry, an unknown error occurred');\n\n      if (error) {\n        errorText = t(\n          'Sorry, there was an error saving this dashboard: %s',\n          error\n        );\n      }\n      if (typeof message === 'string' && message === 'Forbidden') {\n        errorText = t('You do not have permission to edit this dashboard');\n      }\n      dispatch(saveDashboardFinished());\n      dispatch(addDangerToast(errorText));\n    };\n\n    if (\n    [SAVE_TYPE_OVERWRITE, SAVE_TYPE_OVERWRITE_CONFIRMED].includes(saveType))\n    {\n      const { chartConfiguration, globalChartConfiguration } =\n      handleChartConfiguration();\n      const updatedDashboard =\n      saveType === SAVE_TYPE_OVERWRITE_CONFIRMED ?\n      data :\n      {\n        certified_by: cleanedData.certified_by,\n        certification_details: cleanedData.certification_details,\n        css: cleanedData.css,\n        dashboard_title: cleanedData.dashboard_title,\n        slug: cleanedData.slug,\n        owners: cleanedData.owners,\n        roles: cleanedData.roles,\n        json_metadata: safeStringify({\n          ...((cleanedData == null ? void 0 : cleanedData.metadata) || {}),\n          default_filters: safeStringify(serializedFilters),\n          filter_scopes: serializedFilterScopes,\n          chart_configuration: chartConfiguration,\n          global_chart_configuration: globalChartConfiguration\n        })\n      };\n\n      const updateDashboard = () =>\n      SupersetClient.put({\n        endpoint: `/api/v1/dashboard/${id}`,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(updatedDashboard)\n      }).\n      then((response) => onUpdateSuccess(response)).\n      catch((response) => onError(response));\n      return new Promise((resolve, reject) => {\n        if (\n        !isFeatureEnabled(FeatureFlag.ConfirmDashboardDiff) ||\n        saveType === SAVE_TYPE_OVERWRITE_CONFIRMED)\n        {\n          // skip overwrite precheck\n          resolve();\n          return;\n        }\n\n        // precheck for overwrite items\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}`\n        }).then((response) => {\n          const dashboard = response.json.result;\n          const overwriteConfirmItems = getOverwriteItems(\n            dashboard,\n            updatedDashboard\n          );\n          if (overwriteConfirmItems.length > 0) {\n            dispatch(\n              setOverrideConfirm({\n                updatedAt: dashboard.changed_on,\n                updatedBy: dashboard.changed_by_name,\n                overwriteConfirmItems,\n                dashboardId: id,\n                data: updatedDashboard\n              })\n            );\n            return reject(overwriteConfirmItems);\n          }\n          return resolve();\n        });\n      }).\n      then(updateDashboard).\n      catch((overwriteConfirmItems) => {\n        const errorText = t('Please confirm the overwrite values.');\n        dispatch(\n          logEvent(LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA, {\n            dashboard_id: id,\n            items: overwriteConfirmItems\n          })\n        );\n        dispatch(addDangerToast(errorText));\n      });\n    }\n    // changing the data as the endpoint requires\n    if ('positions' in cleanedData && !('positions' in cleanedData.metadata)) {\n      cleanedData.metadata.positions = cleanedData.positions;\n    }\n    cleanedData.metadata.default_filters = safeStringify(serializedFilters);\n    cleanedData.metadata.filter_scopes = serializedFilterScopes;\n    const copyPayload = {\n      dashboard_title: cleanedData.dashboard_title,\n      css: cleanedData.css,\n      duplicate_slices: cleanedData.duplicate_slices,\n      json_metadata: JSON.stringify(cleanedData.metadata)\n    };\n\n    return SupersetClient.post({\n      endpoint: `/api/v1/dashboard/${id}/copy/`,\n      jsonPayload: copyPayload\n    }).\n    then((response) => onCopySuccess(response)).\n    catch((response) => onError(response));\n  };\n}\n\nexport function fetchCharts(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch, getState) => {\n    if (!interval) {\n      chartList.forEach((chartKey) =>\n      dispatch(refreshChart(chartKey, force, dashboardId))\n      );\n      return;\n    }\n\n    const { metadata: meta } = getState().dashboardInfo;\n    const refreshTime = Math.max(interval, meta.stagger_time || 5000); // default 5 seconds\n    if (typeof meta.stagger_refresh !== 'boolean') {\n      meta.stagger_refresh =\n      meta.stagger_refresh === undefined ?\n      true :\n      meta.stagger_refresh === 'true';\n    }\n    const delay = meta.stagger_refresh ?\n    refreshTime / (chartList.length - 1) :\n    0;\n    chartList.forEach((chartKey, i) => {\n      setTimeout(\n        () => dispatch(refreshChart(chartKey, force, dashboardId)),\n        delay * i\n      );\n    });\n  };\n}\n\nconst refreshCharts = (chartList, force, interval, dashboardId, dispatch) =>\nnew Promise((resolve) => {\n  dispatch(fetchCharts(chartList, force, interval, dashboardId));\n  resolve();\n});\n\nexport const ON_FILTERS_REFRESH = 'ON_FILTERS_REFRESH';\nexport function onFiltersRefresh() {\n  return { type: ON_FILTERS_REFRESH };\n}\n\nexport const ON_FILTERS_REFRESH_SUCCESS = 'ON_FILTERS_REFRESH_SUCCESS';\nexport function onFiltersRefreshSuccess() {\n  return { type: ON_FILTERS_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH_SUCCESS = 'ON_REFRESH_SUCCESS';\nexport function onRefreshSuccess() {\n  return { type: ON_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH = 'ON_REFRESH';\nexport function onRefresh(\nchartList = [],\nforce = false,\ninterval = 0,\ndashboardId)\n{\n  return (dispatch) => {\n    dispatch({ type: ON_REFRESH });\n    refreshCharts(chartList, force, interval, dashboardId, dispatch).then(\n      () => {\n        dispatch(onRefreshSuccess());\n        dispatch(onFiltersRefresh());\n      }\n    );\n  };\n}\n\nexport const SHOW_BUILDER_PANE = 'SHOW_BUILDER_PANE';\nexport function showBuilderPane() {\n  return { type: SHOW_BUILDER_PANE };\n}\n\nexport function addSliceToDashboard(id) {\n  return (dispatch, getState) => {\n    const { sliceEntities } = getState();\n    const selectedSlice = sliceEntities.slices[id];\n    if (!selectedSlice) {\n      return dispatch(\n        addWarningToast(\n          'Sorry, there is no chart definition associated with the chart trying to be added.'\n        )\n      );\n    }\n    const form_data = {\n      ...selectedSlice.form_data,\n      slice_id: selectedSlice.slice_id\n    };\n    const newChart = {\n      ...initChart,\n      id,\n      form_data: applyDefaultFormData(form_data)\n    };\n\n    return Promise.all([\n    dispatch(addChart(newChart, id)),\n    dispatch(fetchDatasourceMetadata(form_data.datasource))]\n    ).then(() => {\n      dispatch(addSlice(selectedSlice));\n    });\n  };\n}\n\nexport function removeSliceFromDashboard(id) {\n  return (dispatch) => {\n    dispatch(removeSlice(id));\n    dispatch(removeChart(id));\n    getLabelsColorMap().removeSlice(id);\n  };\n}\n\nexport const SET_COLOR_SCHEME = 'SET_COLOR_SCHEME';\nexport function setColorScheme(colorScheme) {\n  return { type: SET_COLOR_SCHEME, colorScheme };\n}\n\nexport const SET_DIRECT_PATH = 'SET_DIRECT_PATH';\nexport function setDirectPathToChild(path) {\n  return { type: SET_DIRECT_PATH, path };\n}\n\nexport const SET_ACTIVE_TAB = 'SET_ACTIVE_TAB';\n\nfunction findTabsToRestore(tabId, prevTabId, dashboardState, dashboardLayout) {\n  const { activeTabs: prevActiveTabs, inactiveTabs: prevInactiveTabs } =\n  dashboardState;\n  const { present: currentLayout } = dashboardLayout;\n  const restoredTabs = [];\n  const queue = [tabId];\n  const visited = new Set();\n  while (queue.length > 0) {\n    const seek = queue.shift();\n    if (!visited.has(seek)) {var _prevInactiveTabs$fil;\n      visited.add(seek);\n      const found = (_prevInactiveTabs$fil =\n      prevInactiveTabs == null ? void 0 : prevInactiveTabs.filter((inactiveTabId) => {var _currentLayout$inacti;return (_currentLayout$inacti =\n        currentLayout[inactiveTabId]) == null ? void 0 : _currentLayout$inacti.parents.\n        filter((id) => id.startsWith('TAB-')).\n        slice(-1).\n        includes(seek);}\n      )) != null ? _prevInactiveTabs$fil : [];\n      restoredTabs.push(...found);\n      queue.push(...found);\n    }\n  }\n  const activeTabs = restoredTabs ? [tabId].concat(restoredTabs) : [tabId];\n  const tabChanged = Boolean(prevTabId) && tabId !== prevTabId;\n  const inactiveTabs = tabChanged ?\n  prevActiveTabs.filter(\n    (activeTabId) => {var _currentLayout$active;return (\n        activeTabId !== prevTabId && ((_currentLayout$active =\n        currentLayout[activeTabId]) == null ? void 0 : _currentLayout$active.parents.includes(prevTabId)));}\n  ) :\n  [];\n  return {\n    activeTabs,\n    inactiveTabs\n  };\n}\n\nexport function setActiveTab(tabId, prevTabId) {\n  return (dispatch, getState) => {\n    const { dashboardLayout, dashboardState } = getState();\n    const { activeTabs, inactiveTabs } = findTabsToRestore(\n      tabId,\n      prevTabId,\n      dashboardState,\n      dashboardLayout\n    );\n\n    return dispatch({\n      type: SET_ACTIVE_TAB,\n      activeTabs,\n      prevTabId,\n      inactiveTabs\n    });\n  };\n}\n\n// Even though SET_ACTIVE_TABS is not being called from Superset's codebase,\n// it is being used by Preset extensions.\nexport const SET_ACTIVE_TABS = 'SET_ACTIVE_TABS';\nexport function setActiveTabs(activeTabs) {\n  return { type: SET_ACTIVE_TABS, activeTabs };\n}\n\nexport const SET_FOCUSED_FILTER_FIELD = 'SET_FOCUSED_FILTER_FIELD';\nexport function setFocusedFilterField(chartId, column) {\n  return { type: SET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const UNSET_FOCUSED_FILTER_FIELD = 'UNSET_FOCUSED_FILTER_FIELD';\nexport function unsetFocusedFilterField(chartId, column) {\n  return { type: UNSET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const SET_FULL_SIZE_CHART_ID = 'SET_FULL_SIZE_CHART_ID';\nexport function setFullSizeChartId(chartId) {\n  return { type: SET_FULL_SIZE_CHART_ID, chartId };\n}\n\n// Undo history ---------------------------------------------------------------\nexport const SET_MAX_UNDO_HISTORY_EXCEEDED = 'SET_MAX_UNDO_HISTORY_EXCEEDED';\nexport function setMaxUndoHistoryExceeded(maxUndoHistoryExceeded = true) {\n  return {\n    type: SET_MAX_UNDO_HISTORY_EXCEEDED,\n    payload: { maxUndoHistoryExceeded }\n  };\n}\n\nexport function maxUndoHistoryToast() {\n  return (dispatch, getState) => {\n    const { dashboardLayout } = getState();\n    const historyLength = dashboardLayout.past.length;\n\n    return dispatch(\n      addWarningToast(\n        t(\n          'You have used all %(historyLength)s undo slots and will not be able to fully undo subsequent actions. You may save your current state to reset the history.',\n          { historyLength }\n        )\n      )\n    );\n  };\n}\n\nexport const SET_DATASETS_STATUS = 'SET_DATASETS_STATUS';\nexport function setDatasetsStatus(status) {\n  return {\n    type: SET_DATASETS_STATUS,\n    status\n  };\n}\n\nconst storeDashboardColorConfig = async (id, metadata) =>\nSupersetClient.put({\n  endpoint: `/api/v1/dashboard/${id}/colors?mark_updated=false`,\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    color_namespace: metadata.color_namespace,\n    color_scheme: metadata.color_scheme,\n    color_scheme_domain: metadata.color_scheme_domain || [],\n    shared_label_colors: metadata.shared_label_colors || [],\n    map_label_colors: metadata.map_label_colors || {},\n    label_colors: metadata.label_colors || {}\n  })\n});\n\n/**\n *\n * Persists the label colors maps in the dashboard metadata.\n * It runs when outdated color info are detected in stored metadata.\n *\n * @returns void\n */\nexport const persistDashboardLabelsColor = () => async (dispatch, getState) => {\n  const {\n    dashboardInfo: { id, metadata },\n    dashboardState: { labelsColorMapMustSync, sharedLabelsColorsMustSync }\n  } = getState();\n\n  if (labelsColorMapMustSync || sharedLabelsColorsMustSync) {\n    dispatch(setDashboardLabelsColorMapSynced());\n    dispatch(setDashboardSharedLabelsColorsSynced());\n    storeDashboardColorConfig(id, metadata);\n  }\n};\n\n/**\n * Checks the stored dashboard metadata for inconsistencies.\n * Update the current metadata with validated color information.\n * It runs only on Dashboard page load.\n *\n * @param {*} metadata - the stored dashboard metadata\n * @returns void\n */\nexport const applyDashboardLabelsColorOnLoad = (metadata) => async (dispatch) => {\n  try {\n    const customLabelsColor = metadata.label_colors || {};\n    let hasChanged = false;\n\n    // backward compatibility of shared_label_colors\n    const sharedLabels = metadata.shared_label_colors || [];\n    if (!Array.isArray(sharedLabels) && Object.keys(sharedLabels).length > 0) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          shared_label_colors: []\n        })\n      );\n    }\n    // backward compatibility of map_label_colors\n    const hasMapLabelColors = !!metadata.map_label_colors;\n\n    let updatedScheme = metadata.color_scheme;\n    const categoricalSchemes = getCategoricalSchemeRegistry();\n    const colorSchemeRegistry = categoricalSchemes.get(updatedScheme, true);\n    const hasInvalidColorScheme = !!updatedScheme && !colorSchemeRegistry;\n\n    // color scheme might not exist any longer\n    if (hasInvalidColorScheme) {\n      const defaultScheme = categoricalSchemes.defaultKey;\n      const fallbackScheme = (defaultScheme == null ? void 0 : defaultScheme.toString()) || 'supersetColors';\n      hasChanged = true;\n      updatedScheme = fallbackScheme;\n\n      dispatch(setColorScheme(updatedScheme));\n      dispatch(\n        setDashboardMetadata({\n          color_scheme: updatedScheme\n        })\n      );\n    }\n\n    // the stored color domain registry and fresh might differ at this point\n    const freshColorSchemeDomain = updatedScheme ?\n    getColorSchemeDomain(updatedScheme) :\n    [];\n    const currentColorSchemeDomain = metadata.color_scheme_domain || [];\n\n    if (!_isEqual(freshColorSchemeDomain, currentColorSchemeDomain)) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          color_scheme_domain: freshColorSchemeDomain\n        })\n      );\n    }\n\n    // if color scheme is invalid or map is missing, apply a fresh color map\n    // if valid, apply the stored map to keep consistency across refreshes\n    const shouldGoFresh = !hasMapLabelColors || hasInvalidColorScheme;\n    applyColors(metadata, shouldGoFresh);\n\n    if (shouldGoFresh) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor)\n        })\n      );\n    }\n\n    if (hasChanged) {\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  } catch (e) {\n    console.error('Failed to update dashboard color on load:', e);\n  }\n};\n\n/**\n *\n * Ensure that the stored color map matches fresh map.\n *\n * @param {*} metadata - the dashboard metadata\n * @returns void\n */\nexport const ensureSyncedLabelsColorMap = (metadata) => (dispatch, getState) => {\n  const syncLabelsColorMap = () => {\n    const {\n      dashboardState: { labelsColorMapMustSync }\n    } = getState();\n    const customLabelsColor = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColor\n    );\n    const freshColorMapEntries =\n    getFreshLabelsColorMapEntries(customLabelsColor);\n    const isMapSynced = isLabelsColorMapSynced(\n      fullLabelsColors,\n      freshColorMapEntries,\n      customLabelsColor\n    );\n\n    if (!isMapSynced) {\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: freshColorMapEntries\n        })\n      );\n    }\n\n    if (!isMapSynced && !labelsColorMapMustSync) {\n      // prepare to persist the just applied labels color map\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  };\n  promiseTimeout(syncLabelsColorMap, 500);\n};\n\n/**\n *\n * Ensure that the stored shared labels colors match current.\n *\n * @param {*} metadata - the dashboard metadata\n * @param {*} forceFresh - when true it will use the fresh shared labels ignoring stored ones\n * @returns void\n */\nexport const ensureSyncedSharedLabelsColors =\n(metadata, forceFresh = false) =>\n(dispatch, getState) => {\n  const syncSharedLabelsColors = () => {\n    const {\n      dashboardState: { sharedLabelsColorsMustSync }\n    } = getState();\n    const sharedLabelsColors = enforceSharedLabelsColorsArray(\n      metadata.shared_label_colors\n    );\n    const freshLabelsColors = getFreshSharedLabels(\n      forceFresh ? [] : sharedLabelsColors\n    );\n    const isSharedLabelsColorsSynced = _isEqual(\n      sharedLabelsColors.sort(),\n      freshLabelsColors.sort()\n    );\n    const mustSync = !isSharedLabelsColorsSynced;\n\n    if (mustSync) {\n      dispatch(\n        setDashboardMetadata({\n          shared_label_colors: freshLabelsColors\n        })\n      );\n    }\n\n    if (mustSync && !sharedLabelsColorsMustSync) {\n      // prepare to persist the shared labels colors\n      dispatch(setDashboardSharedLabelsColorsSync());\n    }\n  };\n  promiseTimeout(syncSharedLabelsColors, 500);\n};\n\n/**\n *\n * Updates the color map with new labels and colors as they appear.\n *\n * @param {*} renderedChartIds - the charts that have finished rendering\n * @returns void\n */\nexport const updateDashboardLabelsColor = (renderedChartIds) => (_, getState) => {\n  try {\n    const {\n      dashboardInfo: { metadata },\n      charts\n    } = getState();\n    const colorScheme = metadata.color_scheme;\n    const labelsColorMapInstance = getLabelsColorMap();\n    const sharedLabelsColors = enforceSharedLabelsColorsArray(\n      metadata.shared_label_colors\n    );\n    const customLabelsColors = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColors\n    );\n\n    // for dashboards with no color scheme, the charts should always use their individual schemes\n    // this logic looks for unique labels (not shared across multiple charts) of each rendered chart\n    // it applies a new color to those unique labels when the applied scheme is not up to date\n    // while leaving shared label colors and custom label colors intact for color consistency\n    const shouldReset = [];\n    if (renderedChartIds.length > 0) {\n      const sharedLabelsSet = new Set(sharedLabelsColors);\n      renderedChartIds.forEach((id) => {\n        const chart = charts[id];\n        const formData = chart.form_data || chart.latestQueryFormData;\n        // ensure charts have their original color scheme always available\n        labelsColorMapInstance.setOwnColorScheme(\n          formData.slice_id,\n          formData.color_scheme\n        );\n\n        // if dashboard has a scheme, charts should ignore individual schemes\n        // thus following logic is inapplicable if a dashboard color scheme exists\n        if (colorScheme) return;\n\n        const chartColorScheme = formData.color_scheme;\n        const currentChartConfig = labelsColorMapInstance.chartsLabelsMap.get(\n          formData.slice_id\n        );\n        const currentChartLabels = (currentChartConfig == null ? void 0 : currentChartConfig.labels) || [];\n        const uniqueChartLabels = currentChartLabels.filter(\n          (l) => !sharedLabelsSet.has(l) && !customLabelsColors.hasOwnProperty(l)\n        );\n\n        // Map unique labels to colors\n        const uniqueChartLabelsColor = new Set(\n          uniqueChartLabels.map((l) => fullLabelsColors[l]).filter(Boolean)\n        );\n\n        const expectedColorsForChartScheme = new Set(\n          getColorSchemeDomain(chartColorScheme)\n        );\n\n        // Check if any unique label color is not in the expected colors set\n        const shouldResetColors = [...uniqueChartLabelsColor].some(\n          (color) => !expectedColorsForChartScheme.has(color)\n        );\n\n        // Only push uniqueChartLabels if they require resetting\n        if (shouldResetColors) shouldReset.push(...uniqueChartLabels);\n      });\n    }\n\n    // an existing map is available, use mrge option\n    // to only apply colors to newly found labels\n    const shouldGoFresh = shouldReset.length > 0 ? shouldReset : false;\n    const shouldMerge = !shouldGoFresh;\n    // re-apply the color map first to get fresh maps accordingly\n    applyColors(metadata, shouldGoFresh, shouldMerge);\n  } catch (e) {\n    console.error('Failed to update colors for new charts and labels:', e);\n  }\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(SET_UNSAVED_CHANGES, \"SET_UNSAVED_CHANGES\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setUnsavedChanges, \"setUnsavedChanges\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ADD_SLICE, \"ADD_SLICE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(addSlice, \"addSlice\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(REMOVE_SLICE, \"REMOVE_SLICE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(removeSlice, \"removeSlice\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(TOGGLE_FAVE_STAR, \"TOGGLE_FAVE_STAR\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(toggleFaveStar, \"toggleFaveStar\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(fetchFaveStar, \"fetchFaveStar\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(saveFaveStar, \"saveFaveStar\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(TOGGLE_PUBLISHED, \"TOGGLE_PUBLISHED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(togglePublished, \"togglePublished\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(savePublished, \"savePublished\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(TOGGLE_EXPAND_SLICE, \"TOGGLE_EXPAND_SLICE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(toggleExpandSlice, \"toggleExpandSlice\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(UPDATE_CSS, \"UPDATE_CSS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(updateCss, \"updateCss\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_EDIT_MODE, \"SET_EDIT_MODE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setEditMode, \"setEditMode\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_CHANGE, \"ON_CHANGE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onChange, \"onChange\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_SAVE, \"ON_SAVE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onSave, \"onSave\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_REFRESH_FREQUENCY, \"SET_REFRESH_FREQUENCY\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setRefreshFrequency, \"setRefreshFrequency\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(saveDashboardRequestSuccess, \"saveDashboardRequestSuccess\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_OVERRIDE_CONFIRM, \"SET_OVERRIDE_CONFIRM\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setOverrideConfirm, \"setOverrideConfirm\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SAVE_DASHBOARD_STARTED, \"SAVE_DASHBOARD_STARTED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(saveDashboardStarted, \"saveDashboardStarted\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SAVE_DASHBOARD_FINISHED, \"SAVE_DASHBOARD_FINISHED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(saveDashboardFinished, \"saveDashboardFinished\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE, \"SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DASHBOARD_LABELS_COLORMAP_SYNCED, \"SET_DASHBOARD_LABELS_COLORMAP_SYNCED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE, \"SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED, \"SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDashboardLabelsColorMapSync, \"setDashboardLabelsColorMapSync\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDashboardLabelsColorMapSynced, \"setDashboardLabelsColorMapSynced\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDashboardSharedLabelsColorsSync, \"setDashboardSharedLabelsColorsSync\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDashboardSharedLabelsColorsSynced, \"setDashboardSharedLabelsColorsSynced\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDashboardMetadata, \"setDashboardMetadata\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(saveDashboardRequest, \"saveDashboardRequest\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(fetchCharts, \"fetchCharts\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(refreshCharts, \"refreshCharts\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_FILTERS_REFRESH, \"ON_FILTERS_REFRESH\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onFiltersRefresh, \"onFiltersRefresh\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_FILTERS_REFRESH_SUCCESS, \"ON_FILTERS_REFRESH_SUCCESS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onFiltersRefreshSuccess, \"onFiltersRefreshSuccess\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_REFRESH_SUCCESS, \"ON_REFRESH_SUCCESS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onRefreshSuccess, \"onRefreshSuccess\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ON_REFRESH, \"ON_REFRESH\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(onRefresh, \"onRefresh\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SHOW_BUILDER_PANE, \"SHOW_BUILDER_PANE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(showBuilderPane, \"showBuilderPane\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(addSliceToDashboard, \"addSliceToDashboard\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(removeSliceFromDashboard, \"removeSliceFromDashboard\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_COLOR_SCHEME, \"SET_COLOR_SCHEME\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setColorScheme, \"setColorScheme\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DIRECT_PATH, \"SET_DIRECT_PATH\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDirectPathToChild, \"setDirectPathToChild\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_ACTIVE_TAB, \"SET_ACTIVE_TAB\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(findTabsToRestore, \"findTabsToRestore\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setActiveTab, \"setActiveTab\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_ACTIVE_TABS, \"SET_ACTIVE_TABS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setActiveTabs, \"setActiveTabs\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_FOCUSED_FILTER_FIELD, \"SET_FOCUSED_FILTER_FIELD\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setFocusedFilterField, \"setFocusedFilterField\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(UNSET_FOCUSED_FILTER_FIELD, \"UNSET_FOCUSED_FILTER_FIELD\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(unsetFocusedFilterField, \"unsetFocusedFilterField\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_FULL_SIZE_CHART_ID, \"SET_FULL_SIZE_CHART_ID\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setFullSizeChartId, \"setFullSizeChartId\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_MAX_UNDO_HISTORY_EXCEEDED, \"SET_MAX_UNDO_HISTORY_EXCEEDED\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setMaxUndoHistoryExceeded, \"setMaxUndoHistoryExceeded\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(maxUndoHistoryToast, \"maxUndoHistoryToast\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(SET_DATASETS_STATUS, \"SET_DATASETS_STATUS\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(setDatasetsStatus, \"setDatasetsStatus\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(storeDashboardColorConfig, \"storeDashboardColorConfig\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(persistDashboardLabelsColor, \"persistDashboardLabelsColor\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(applyDashboardLabelsColorOnLoad, \"applyDashboardLabelsColorOnLoad\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ensureSyncedLabelsColorMap, \"ensureSyncedLabelsColorMap\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(ensureSyncedSharedLabelsColors, \"ensureSyncedSharedLabelsColors\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");reactHotLoader.register(updateDashboardLabelsColor, \"updateDashboardLabelsColor\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["ActionCreators","UndoActionCreators","rison","ensureIsArray","isFeatureEnabled","FeatureFlag","getLabelsColorMap","SupersetClient","t","getClientErrorObject","getCategoricalSchemeRegistry","promiseTimeout","addChart","removeChart","refreshChart","chart","initChart","applyDefaultFormData","SAVE_TYPE_OVERWRITE","SAVE_TYPE_OVERWRITE_CONFIRMED","getCrossFiltersConfiguration","isCrossFiltersEnabled","addSuccessToast","addWarningToast","addDangerToast","serializeActiveFilterValues","serializeFilterScopes","getActiveFilters","safeStringify","logEvent","LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA","navigateWithState","UPDATE_COMPONENTS_PARENTS_LIST","saveChartConfiguration","dashboardInfoChanged","SAVE_CHART_CONFIG_COMPLETE","fetchDatasourceMetadata","setDatasources","updateDirectPathToFilter","SET_IN_SCOPE_STATUS_OF_FILTERS","getOverwriteItems","applyColors","enforceSharedLabelsColorsArray","isLabelsColorMapSynced","getColorSchemeDomain","getColorNamespace","getFreshLabelsColorMapEntries","getFreshSharedLabels","getDynamicLabelsColors","SET_UNSAVED_CHANGES","setUnsavedChanges","hasUnsavedChanges","type","payload","ADD_SLICE","addSlice","slice","REMOVE_SLICE","removeSlice","sliceId","TOGGLE_FAVE_STAR","toggleFaveStar","isStarred","fetchFaveStar","id","fetchFaveStarThunk","dispatch","get","endpoint","encode","then","json","_json$result","_json$result$","result","value","catch","saveFaveStar","saveFaveStarThunk","apiCall","delete","post","TOGGLE_PUBLISHED","togglePublished","isPublished","savePublished","savePublishedThunk","put","headers","body","JSON","stringify","published","TOGGLE_EXPAND_SLICE","toggleExpandSlice","UPDATE_CSS","updateCss","css","SET_EDIT_MODE","setEditMode","editMode","ON_CHANGE","onChange","ON_SAVE","onSave","lastModifiedTime","SET_REFRESH_FREQUENCY","setRefreshFrequency","refreshFrequency","isPersistent","saveDashboardRequestSuccess","clearHistory","SET_OVERRIDE_CONFIRM","setOverrideConfirm","overwriteConfirmMetadata","SAVE_DASHBOARD_STARTED","saveDashboardStarted","SAVE_DASHBOARD_FINISHED","saveDashboardFinished","SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE","SET_DASHBOARD_LABELS_COLORMAP_SYNCED","SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE","SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED","setDashboardLabelsColorMapSync","setDashboardLabelsColorMapSynced","setDashboardSharedLabelsColorsSync","setDashboardSharedLabelsColorsSynced","setDashboardMetadata","updatedMetadata","getState","dashboardInfo","metadata","saveDashboardRequest","data","saveType","_data$metadata","_data$metadata2","_data$metadata3","_data$metadata4","_data$metadata5","_data$metadata6","_data$metadata7","_data$metadata8","dashboardFilters","dashboardLayout","layout","present","Object","values","forEach","filter","_layout$componentId","chartId","componentId","directPathToFilter","pop","parents","push","serializedFilters","serializedFilterScopes","certified_by","certification_details","dashboard_title","owners","roles","slug","hasId","item","undefined","metadataCrossFiltersEnabled","cross_filters_enabled","colorScheme","color_scheme","customLabelsColor","label_colors","sharedLabelsColor","shared_label_colors","cleanedData","map","o","DashboardRbac","r","color_namespace","color_scheme_domain","expanded_slices","map_label_colors","refresh_frequency","timed_refresh_immune_slices","handleChartConfiguration","charts","onCopySuccess","response","last_modified_time","chartConfiguration","globalChartConfiguration","onUpdateSuccess","updatedDashboard","json_metadata","parse","chart_configuration","native_filter_configuration","filterConfig","_json$result2","datasources","length","event","onError","error","message","errorText","includes","default_filters","filter_scopes","global_chart_configuration","updateDashboard","Promise","resolve","reject","ConfirmDashboardDiff","dashboard","overwriteConfirmItems","updatedAt","changed_on","updatedBy","changed_by_name","dashboardId","dashboard_id","items","positions","copyPayload","duplicate_slices","jsonPayload","fetchCharts","chartList","force","interval","chartKey","meta","refreshTime","Math","max","stagger_time","stagger_refresh","delay","i","setTimeout","refreshCharts","ON_FILTERS_REFRESH","onFiltersRefresh","ON_FILTERS_REFRESH_SUCCESS","onFiltersRefreshSuccess","ON_REFRESH_SUCCESS","onRefreshSuccess","ON_REFRESH","onRefresh","SHOW_BUILDER_PANE","showBuilderPane","addSliceToDashboard","sliceEntities","selectedSlice","slices","form_data","slice_id","newChart","all","datasource","removeSliceFromDashboard","SET_COLOR_SCHEME","setColorScheme","SET_DIRECT_PATH","setDirectPathToChild","path","SET_ACTIVE_TAB","findTabsToRestore","tabId","prevTabId","dashboardState","activeTabs","prevActiveTabs","inactiveTabs","prevInactiveTabs","currentLayout","restoredTabs","queue","visited","Set","seek","shift","has","_prevInactiveTabs$fil","add","found","inactiveTabId","_currentLayout$inacti","startsWith","concat","tabChanged","Boolean","activeTabId","_currentLayout$active","setActiveTab","SET_ACTIVE_TABS","setActiveTabs","SET_FOCUSED_FILTER_FIELD","setFocusedFilterField","column","UNSET_FOCUSED_FILTER_FIELD","unsetFocusedFilterField","SET_FULL_SIZE_CHART_ID","setFullSizeChartId","SET_MAX_UNDO_HISTORY_EXCEEDED","setMaxUndoHistoryExceeded","maxUndoHistoryExceeded","maxUndoHistoryToast","historyLength","past","SET_DATASETS_STATUS","setDatasetsStatus","status","storeDashboardColorConfig","persistDashboardLabelsColor","labelsColorMapMustSync","sharedLabelsColorsMustSync","applyDashboardLabelsColorOnLoad","hasChanged","sharedLabels","Array","isArray","keys","hasMapLabelColors","updatedScheme","categoricalSchemes","colorSchemeRegistry","hasInvalidColorScheme","defaultScheme","defaultKey","fallbackScheme","toString","freshColorSchemeDomain","currentColorSchemeDomain","_isEqual","shouldGoFresh","e","console","ensureSyncedLabelsColorMap","syncLabelsColorMap","fullLabelsColors","freshColorMapEntries","isMapSynced","ensureSyncedSharedLabelsColors","forceFresh","syncSharedLabelsColors","sharedLabelsColors","freshLabelsColors","isSharedLabelsColorsSynced","sort","mustSync","updateDashboardLabelsColor","renderedChartIds","_","labelsColorMapInstance","customLabelsColors","shouldReset","sharedLabelsSet","formData","latestQueryFormData","setOwnColorScheme","chartColorScheme","currentChartConfig","chartsLabelsMap","currentChartLabels","labels","uniqueChartLabels","l","hasOwnProperty","uniqueChartLabelsColor","expectedColorsForChartScheme","shouldResetColors","some","color","shouldMerge","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/dashboard/actions/dashboardState.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { ActionCreators as UndoActionCreators } from 'redux-undo';\nimport rison from 'rison';\nimport {\n  ensureIsArray,\n  isFeatureEnabled,\n  FeatureFlag,\n  getLabelsColorMap,\n  SupersetClient,\n  t,\n  getClientErrorObject,\n  getCategoricalSchemeRegistry,\n  promiseTimeout,\n} from '@superset-ui/core';\nimport {\n  addChart,\n  removeChart,\n  refreshChart,\n} from 'src/components/Chart/chartAction';\nimport { chart as initChart } from 'src/components/Chart/chartReducer';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport {\n  SAVE_TYPE_OVERWRITE,\n  SAVE_TYPE_OVERWRITE_CONFIRMED,\n} from 'src/dashboard/util/constants';\nimport {\n  getCrossFiltersConfiguration,\n  isCrossFiltersEnabled,\n} from 'src/dashboard/util/crossFilters';\nimport {\n  addSuccessToast,\n  addWarningToast,\n  addDangerToast,\n} from 'src/components/MessageToasts/actions';\nimport serializeActiveFilterValues from 'src/dashboard/util/serializeActiveFilterValues';\nimport serializeFilterScopes from 'src/dashboard/util/serializeFilterScopes';\nimport { getActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport { safeStringify } from 'src/utils/safeStringify';\nimport { logEvent } from 'src/logger/actions';\nimport { LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA } from 'src/logger/LogUtils';\nimport { isEqual } from 'lodash';\nimport { navigateWithState } from 'src/utils/navigationUtils';\nimport { UPDATE_COMPONENTS_PARENTS_LIST } from './dashboardLayout';\nimport {\n  saveChartConfiguration,\n  dashboardInfoChanged,\n  SAVE_CHART_CONFIG_COMPLETE,\n} from './dashboardInfo';\nimport { fetchDatasourceMetadata, setDatasources } from './datasources';\nimport { updateDirectPathToFilter } from './dashboardFilters';\nimport { SET_IN_SCOPE_STATUS_OF_FILTERS } from './nativeFilters';\nimport getOverwriteItems from '../util/getOverwriteItems';\nimport {\n  applyColors,\n  enforceSharedLabelsColorsArray,\n  isLabelsColorMapSynced,\n  getColorSchemeDomain,\n  getColorNamespace,\n  getFreshLabelsColorMapEntries,\n  getFreshSharedLabels,\n  getDynamicLabelsColors,\n} from '../../utils/colorScheme';\n\nexport const SET_UNSAVED_CHANGES = 'SET_UNSAVED_CHANGES';\nexport function setUnsavedChanges(hasUnsavedChanges) {\n  return { type: SET_UNSAVED_CHANGES, payload: { hasUnsavedChanges } };\n}\n\nexport const ADD_SLICE = 'ADD_SLICE';\nexport function addSlice(slice) {\n  return { type: ADD_SLICE, slice };\n}\n\nexport const REMOVE_SLICE = 'REMOVE_SLICE';\nexport function removeSlice(sliceId) {\n  return { type: REMOVE_SLICE, sliceId };\n}\n\nexport const TOGGLE_FAVE_STAR = 'TOGGLE_FAVE_STAR';\nexport function toggleFaveStar(isStarred) {\n  return { type: TOGGLE_FAVE_STAR, isStarred };\n}\n\nexport function fetchFaveStar(id) {\n  return function fetchFaveStarThunk(dispatch) {\n    return SupersetClient.get({\n      endpoint: `/api/v1/dashboard/favorite_status/?q=${rison.encode([id])}`,\n    })\n      .then(({ json }) => {\n        dispatch(toggleFaveStar(!!json?.result?.[0]?.value));\n      })\n      .catch(() =>\n        dispatch(\n          addDangerToast(\n            t(\n              'There was an issue fetching the favorite status of this dashboard.',\n            ),\n          ),\n        ),\n      );\n  };\n}\n\nexport function saveFaveStar(id, isStarred) {\n  return function saveFaveStarThunk(dispatch) {\n    const endpoint = `/api/v1/dashboard/${id}/favorites/`;\n    const apiCall = isStarred\n      ? SupersetClient.delete({\n          endpoint,\n        })\n      : SupersetClient.post({ endpoint });\n\n    return apiCall\n      .then(() => {\n        dispatch(toggleFaveStar(!isStarred));\n      })\n      .catch(() =>\n        dispatch(\n          addDangerToast(t('There was an issue favoriting this dashboard.')),\n        ),\n      );\n  };\n}\n\nexport const TOGGLE_PUBLISHED = 'TOGGLE_PUBLISHED';\nexport function togglePublished(isPublished) {\n  return { type: TOGGLE_PUBLISHED, isPublished };\n}\n\nexport function savePublished(id, isPublished) {\n  return function savePublishedThunk(dispatch) {\n    return SupersetClient.put({\n      endpoint: `/api/v1/dashboard/${id}`,\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        published: isPublished,\n      }),\n    })\n      .then(() => {\n        dispatch(\n          addSuccessToast(\n            isPublished\n              ? t('This dashboard is now published')\n              : t('This dashboard is now hidden'),\n          ),\n        );\n        dispatch(togglePublished(isPublished));\n      })\n      .catch(() => {\n        dispatch(\n          addDangerToast(\n            t('You do not have permissions to edit this dashboard.'),\n          ),\n        );\n      });\n  };\n}\n\nexport const TOGGLE_EXPAND_SLICE = 'TOGGLE_EXPAND_SLICE';\nexport function toggleExpandSlice(sliceId) {\n  return { type: TOGGLE_EXPAND_SLICE, sliceId };\n}\n\nexport const UPDATE_CSS = 'UPDATE_CSS';\nexport function updateCss(css) {\n  return { type: UPDATE_CSS, css };\n}\n\nexport const SET_EDIT_MODE = 'SET_EDIT_MODE';\nexport function setEditMode(editMode) {\n  return { type: SET_EDIT_MODE, editMode };\n}\n\nexport const ON_CHANGE = 'ON_CHANGE';\nexport function onChange() {\n  return { type: ON_CHANGE };\n}\n\nexport const ON_SAVE = 'ON_SAVE';\nexport function onSave(lastModifiedTime) {\n  return { type: ON_SAVE, lastModifiedTime };\n}\n\nexport const SET_REFRESH_FREQUENCY = 'SET_REFRESH_FREQUENCY';\nexport function setRefreshFrequency(refreshFrequency, isPersistent = false) {\n  return { type: SET_REFRESH_FREQUENCY, refreshFrequency, isPersistent };\n}\n\nexport function saveDashboardRequestSuccess(lastModifiedTime) {\n  return dispatch => {\n    dispatch(onSave(lastModifiedTime));\n    // clear layout undo history\n    dispatch(UndoActionCreators.clearHistory());\n  };\n}\n\nexport const SET_OVERRIDE_CONFIRM = 'SET_OVERRIDE_CONFIRM';\nexport function setOverrideConfirm(overwriteConfirmMetadata) {\n  return {\n    type: SET_OVERRIDE_CONFIRM,\n    overwriteConfirmMetadata,\n  };\n}\n\nexport const SAVE_DASHBOARD_STARTED = 'SAVE_DASHBOARD_STARTED';\nexport function saveDashboardStarted() {\n  return { type: SAVE_DASHBOARD_STARTED };\n}\n\nexport const SAVE_DASHBOARD_FINISHED = 'SAVE_DASHBOARD_FINISHED';\nexport function saveDashboardFinished() {\n  return { type: SAVE_DASHBOARD_FINISHED };\n}\n\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE =\n  'SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE';\nexport const SET_DASHBOARD_LABELS_COLORMAP_SYNCED =\n  'SET_DASHBOARD_LABELS_COLORMAP_SYNCED';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE =\n  'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE';\nexport const SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED =\n  'SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED';\n\nexport function setDashboardLabelsColorMapSync() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCABLE };\n}\n\nexport function setDashboardLabelsColorMapSynced() {\n  return { type: SET_DASHBOARD_LABELS_COLORMAP_SYNCED };\n}\n\nexport function setDashboardSharedLabelsColorsSync() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCABLE };\n}\n\nexport function setDashboardSharedLabelsColorsSynced() {\n  return { type: SET_DASHBOARD_SHARED_LABELS_COLORS_SYNCED };\n}\n\nexport const setDashboardMetadata =\n  updatedMetadata => async (dispatch, getState) => {\n    const { dashboardInfo } = getState();\n    dispatch(\n      dashboardInfoChanged({\n        metadata: {\n          ...(dashboardInfo?.metadata || {}),\n          ...updatedMetadata,\n        },\n      }),\n    );\n  };\n\nexport function saveDashboardRequest(data, id, saveType) {\n  return (dispatch, getState) => {\n    dispatch({ type: UPDATE_COMPONENTS_PARENTS_LIST });\n    dispatch(saveDashboardStarted());\n\n    const { dashboardFilters, dashboardLayout } = getState();\n    const layout = dashboardLayout.present;\n    Object.values(dashboardFilters).forEach(filter => {\n      const { chartId } = filter;\n      const componentId = filter.directPathToFilter.slice().pop();\n      const directPathToFilter = (layout[componentId]?.parents || []).slice();\n      directPathToFilter.push(componentId);\n      dispatch(updateDirectPathToFilter(chartId, directPathToFilter));\n    });\n    // serialize selected values for each filter field, grouped by filter id\n    const serializedFilters = serializeActiveFilterValues(getActiveFilters());\n    // serialize filter scope for each filter field, grouped by filter id\n    const serializedFilterScopes = serializeFilterScopes(dashboardFilters);\n    const {\n      certified_by,\n      certification_details,\n      css,\n      dashboard_title,\n      owners,\n      roles,\n      slug,\n    } = data;\n\n    const hasId = item => item.id !== undefined;\n    const metadataCrossFiltersEnabled = data.metadata?.cross_filters_enabled;\n    const colorScheme = data.metadata?.color_scheme;\n    const customLabelsColor = data.metadata?.label_colors || {};\n    const sharedLabelsColor = enforceSharedLabelsColorsArray(\n      data.metadata?.shared_label_colors,\n    );\n    const cleanedData = {\n      ...data,\n      certified_by: certified_by || '',\n      certification_details:\n        certified_by && certification_details ? certification_details : '',\n      css: css || '',\n      dashboard_title: dashboard_title || t('[ untitled dashboard ]'),\n      owners: ensureIsArray(owners).map(o => (hasId(o) ? o.id : o)),\n      roles: !isFeatureEnabled(FeatureFlag.DashboardRbac)\n        ? undefined\n        : ensureIsArray(roles).map(r => (hasId(r) ? r.id : r)),\n      slug: slug || null,\n      metadata: {\n        ...data.metadata,\n        color_namespace: getColorNamespace(data.metadata?.color_namespace),\n        color_scheme: colorScheme || '',\n        color_scheme_domain: colorScheme\n          ? getColorSchemeDomain(colorScheme)\n          : [],\n        expanded_slices: data.metadata?.expanded_slices || {},\n        label_colors: customLabelsColor,\n        shared_label_colors: getFreshSharedLabels(sharedLabelsColor),\n        map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor),\n        refresh_frequency: data.metadata?.refresh_frequency || 0,\n        timed_refresh_immune_slices:\n          data.metadata?.timed_refresh_immune_slices || [],\n        // cross-filters should be enabled by default\n        cross_filters_enabled: isCrossFiltersEnabled(\n          metadataCrossFiltersEnabled,\n        ),\n      },\n    };\n\n    const handleChartConfiguration = () => {\n      const {\n        dashboardLayout,\n        charts,\n        dashboardInfo: { metadata },\n      } = getState();\n      return getCrossFiltersConfiguration(\n        dashboardLayout.present,\n        metadata,\n        charts,\n      );\n    };\n\n    const onCopySuccess = response => {\n      const lastModifiedTime = response.json.result.last_modified_time;\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      const { chartConfiguration, globalChartConfiguration } =\n        handleChartConfiguration();\n      dispatch(\n        saveChartConfiguration({\n          chartConfiguration,\n          globalChartConfiguration,\n        }),\n      );\n      dispatch(saveDashboardFinished());\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      return response;\n    };\n\n    const onUpdateSuccess = response => {\n      const updatedDashboard = response.json.result;\n      const lastModifiedTime = response.json.last_modified_time;\n      // syncing with the backend transformations of the metadata\n      if (updatedDashboard.json_metadata) {\n        const metadata = JSON.parse(updatedDashboard.json_metadata);\n        dispatch(setDashboardMetadata(metadata));\n        if (metadata.chart_configuration) {\n          dispatch({\n            type: SAVE_CHART_CONFIG_COMPLETE,\n            chartConfiguration: metadata.chart_configuration,\n          });\n        }\n        if (metadata.native_filter_configuration) {\n          dispatch({\n            type: SET_IN_SCOPE_STATUS_OF_FILTERS,\n            filterConfig: metadata.native_filter_configuration,\n          });\n        }\n\n        // fetch datasets to make sure they are up to date\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}/datasets`,\n          headers: { 'Content-Type': 'application/json' },\n        }).then(({ json }) => {\n          const datasources = json?.result ?? [];\n          if (datasources.length) {\n            dispatch(setDatasources(datasources));\n          }\n        });\n      }\n      if (lastModifiedTime) {\n        dispatch(saveDashboardRequestSuccess(lastModifiedTime));\n      }\n      dispatch(saveDashboardFinished());\n      // redirect to the new slug or id\n      navigateWithState(`/superset/dashboard/${slug || id}/`, {\n        event: 'dashboard_properties_changed',\n      });\n\n      dispatch(addSuccessToast(t('This dashboard was saved successfully.')));\n      dispatch(setOverrideConfirm(undefined));\n      return response;\n    };\n\n    const onError = async response => {\n      const { error, message } = await getClientErrorObject(response);\n      let errorText = t('Sorry, an unknown error occurred');\n\n      if (error) {\n        errorText = t(\n          'Sorry, there was an error saving this dashboard: %s',\n          error,\n        );\n      }\n      if (typeof message === 'string' && message === 'Forbidden') {\n        errorText = t('You do not have permission to edit this dashboard');\n      }\n      dispatch(saveDashboardFinished());\n      dispatch(addDangerToast(errorText));\n    };\n\n    if (\n      [SAVE_TYPE_OVERWRITE, SAVE_TYPE_OVERWRITE_CONFIRMED].includes(saveType)\n    ) {\n      const { chartConfiguration, globalChartConfiguration } =\n        handleChartConfiguration();\n      const updatedDashboard =\n        saveType === SAVE_TYPE_OVERWRITE_CONFIRMED\n          ? data\n          : {\n              certified_by: cleanedData.certified_by,\n              certification_details: cleanedData.certification_details,\n              css: cleanedData.css,\n              dashboard_title: cleanedData.dashboard_title,\n              slug: cleanedData.slug,\n              owners: cleanedData.owners,\n              roles: cleanedData.roles,\n              json_metadata: safeStringify({\n                ...(cleanedData?.metadata || {}),\n                default_filters: safeStringify(serializedFilters),\n                filter_scopes: serializedFilterScopes,\n                chart_configuration: chartConfiguration,\n                global_chart_configuration: globalChartConfiguration,\n              }),\n            };\n\n      const updateDashboard = () =>\n        SupersetClient.put({\n          endpoint: `/api/v1/dashboard/${id}`,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(updatedDashboard),\n        })\n          .then(response => onUpdateSuccess(response))\n          .catch(response => onError(response));\n      return new Promise((resolve, reject) => {\n        if (\n          !isFeatureEnabled(FeatureFlag.ConfirmDashboardDiff) ||\n          saveType === SAVE_TYPE_OVERWRITE_CONFIRMED\n        ) {\n          // skip overwrite precheck\n          resolve();\n          return;\n        }\n\n        // precheck for overwrite items\n        SupersetClient.get({\n          endpoint: `/api/v1/dashboard/${id}`,\n        }).then(response => {\n          const dashboard = response.json.result;\n          const overwriteConfirmItems = getOverwriteItems(\n            dashboard,\n            updatedDashboard,\n          );\n          if (overwriteConfirmItems.length > 0) {\n            dispatch(\n              setOverrideConfirm({\n                updatedAt: dashboard.changed_on,\n                updatedBy: dashboard.changed_by_name,\n                overwriteConfirmItems,\n                dashboardId: id,\n                data: updatedDashboard,\n              }),\n            );\n            return reject(overwriteConfirmItems);\n          }\n          return resolve();\n        });\n      })\n        .then(updateDashboard)\n        .catch(overwriteConfirmItems => {\n          const errorText = t('Please confirm the overwrite values.');\n          dispatch(\n            logEvent(LOG_ACTIONS_CONFIRM_OVERWRITE_DASHBOARD_METADATA, {\n              dashboard_id: id,\n              items: overwriteConfirmItems,\n            }),\n          );\n          dispatch(addDangerToast(errorText));\n        });\n    }\n    // changing the data as the endpoint requires\n    if ('positions' in cleanedData && !('positions' in cleanedData.metadata)) {\n      cleanedData.metadata.positions = cleanedData.positions;\n    }\n    cleanedData.metadata.default_filters = safeStringify(serializedFilters);\n    cleanedData.metadata.filter_scopes = serializedFilterScopes;\n    const copyPayload = {\n      dashboard_title: cleanedData.dashboard_title,\n      css: cleanedData.css,\n      duplicate_slices: cleanedData.duplicate_slices,\n      json_metadata: JSON.stringify(cleanedData.metadata),\n    };\n\n    return SupersetClient.post({\n      endpoint: `/api/v1/dashboard/${id}/copy/`,\n      jsonPayload: copyPayload,\n    })\n      .then(response => onCopySuccess(response))\n      .catch(response => onError(response));\n  };\n}\n\nexport function fetchCharts(\n  chartList = [],\n  force = false,\n  interval = 0,\n  dashboardId,\n) {\n  return (dispatch, getState) => {\n    if (!interval) {\n      chartList.forEach(chartKey =>\n        dispatch(refreshChart(chartKey, force, dashboardId)),\n      );\n      return;\n    }\n\n    const { metadata: meta } = getState().dashboardInfo;\n    const refreshTime = Math.max(interval, meta.stagger_time || 5000); // default 5 seconds\n    if (typeof meta.stagger_refresh !== 'boolean') {\n      meta.stagger_refresh =\n        meta.stagger_refresh === undefined\n          ? true\n          : meta.stagger_refresh === 'true';\n    }\n    const delay = meta.stagger_refresh\n      ? refreshTime / (chartList.length - 1)\n      : 0;\n    chartList.forEach((chartKey, i) => {\n      setTimeout(\n        () => dispatch(refreshChart(chartKey, force, dashboardId)),\n        delay * i,\n      );\n    });\n  };\n}\n\nconst refreshCharts = (chartList, force, interval, dashboardId, dispatch) =>\n  new Promise(resolve => {\n    dispatch(fetchCharts(chartList, force, interval, dashboardId));\n    resolve();\n  });\n\nexport const ON_FILTERS_REFRESH = 'ON_FILTERS_REFRESH';\nexport function onFiltersRefresh() {\n  return { type: ON_FILTERS_REFRESH };\n}\n\nexport const ON_FILTERS_REFRESH_SUCCESS = 'ON_FILTERS_REFRESH_SUCCESS';\nexport function onFiltersRefreshSuccess() {\n  return { type: ON_FILTERS_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH_SUCCESS = 'ON_REFRESH_SUCCESS';\nexport function onRefreshSuccess() {\n  return { type: ON_REFRESH_SUCCESS };\n}\n\nexport const ON_REFRESH = 'ON_REFRESH';\nexport function onRefresh(\n  chartList = [],\n  force = false,\n  interval = 0,\n  dashboardId,\n) {\n  return dispatch => {\n    dispatch({ type: ON_REFRESH });\n    refreshCharts(chartList, force, interval, dashboardId, dispatch).then(\n      () => {\n        dispatch(onRefreshSuccess());\n        dispatch(onFiltersRefresh());\n      },\n    );\n  };\n}\n\nexport const SHOW_BUILDER_PANE = 'SHOW_BUILDER_PANE';\nexport function showBuilderPane() {\n  return { type: SHOW_BUILDER_PANE };\n}\n\nexport function addSliceToDashboard(id) {\n  return (dispatch, getState) => {\n    const { sliceEntities } = getState();\n    const selectedSlice = sliceEntities.slices[id];\n    if (!selectedSlice) {\n      return dispatch(\n        addWarningToast(\n          'Sorry, there is no chart definition associated with the chart trying to be added.',\n        ),\n      );\n    }\n    const form_data = {\n      ...selectedSlice.form_data,\n      slice_id: selectedSlice.slice_id,\n    };\n    const newChart = {\n      ...initChart,\n      id,\n      form_data: applyDefaultFormData(form_data),\n    };\n\n    return Promise.all([\n      dispatch(addChart(newChart, id)),\n      dispatch(fetchDatasourceMetadata(form_data.datasource)),\n    ]).then(() => {\n      dispatch(addSlice(selectedSlice));\n    });\n  };\n}\n\nexport function removeSliceFromDashboard(id) {\n  return dispatch => {\n    dispatch(removeSlice(id));\n    dispatch(removeChart(id));\n    getLabelsColorMap().removeSlice(id);\n  };\n}\n\nexport const SET_COLOR_SCHEME = 'SET_COLOR_SCHEME';\nexport function setColorScheme(colorScheme) {\n  return { type: SET_COLOR_SCHEME, colorScheme };\n}\n\nexport const SET_DIRECT_PATH = 'SET_DIRECT_PATH';\nexport function setDirectPathToChild(path) {\n  return { type: SET_DIRECT_PATH, path };\n}\n\nexport const SET_ACTIVE_TAB = 'SET_ACTIVE_TAB';\n\nfunction findTabsToRestore(tabId, prevTabId, dashboardState, dashboardLayout) {\n  const { activeTabs: prevActiveTabs, inactiveTabs: prevInactiveTabs } =\n    dashboardState;\n  const { present: currentLayout } = dashboardLayout;\n  const restoredTabs = [];\n  const queue = [tabId];\n  const visited = new Set();\n  while (queue.length > 0) {\n    const seek = queue.shift();\n    if (!visited.has(seek)) {\n      visited.add(seek);\n      const found =\n        prevInactiveTabs?.filter(inactiveTabId =>\n          currentLayout[inactiveTabId]?.parents\n            .filter(id => id.startsWith('TAB-'))\n            .slice(-1)\n            .includes(seek),\n        ) ?? [];\n      restoredTabs.push(...found);\n      queue.push(...found);\n    }\n  }\n  const activeTabs = restoredTabs ? [tabId].concat(restoredTabs) : [tabId];\n  const tabChanged = Boolean(prevTabId) && tabId !== prevTabId;\n  const inactiveTabs = tabChanged\n    ? prevActiveTabs.filter(\n        activeTabId =>\n          activeTabId !== prevTabId &&\n          currentLayout[activeTabId]?.parents.includes(prevTabId),\n      )\n    : [];\n  return {\n    activeTabs,\n    inactiveTabs,\n  };\n}\n\nexport function setActiveTab(tabId, prevTabId) {\n  return (dispatch, getState) => {\n    const { dashboardLayout, dashboardState } = getState();\n    const { activeTabs, inactiveTabs } = findTabsToRestore(\n      tabId,\n      prevTabId,\n      dashboardState,\n      dashboardLayout,\n    );\n\n    return dispatch({\n      type: SET_ACTIVE_TAB,\n      activeTabs,\n      prevTabId,\n      inactiveTabs,\n    });\n  };\n}\n\n// Even though SET_ACTIVE_TABS is not being called from Superset's codebase,\n// it is being used by Preset extensions.\nexport const SET_ACTIVE_TABS = 'SET_ACTIVE_TABS';\nexport function setActiveTabs(activeTabs) {\n  return { type: SET_ACTIVE_TABS, activeTabs };\n}\n\nexport const SET_FOCUSED_FILTER_FIELD = 'SET_FOCUSED_FILTER_FIELD';\nexport function setFocusedFilterField(chartId, column) {\n  return { type: SET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const UNSET_FOCUSED_FILTER_FIELD = 'UNSET_FOCUSED_FILTER_FIELD';\nexport function unsetFocusedFilterField(chartId, column) {\n  return { type: UNSET_FOCUSED_FILTER_FIELD, chartId, column };\n}\n\nexport const SET_FULL_SIZE_CHART_ID = 'SET_FULL_SIZE_CHART_ID';\nexport function setFullSizeChartId(chartId) {\n  return { type: SET_FULL_SIZE_CHART_ID, chartId };\n}\n\n// Undo history ---------------------------------------------------------------\nexport const SET_MAX_UNDO_HISTORY_EXCEEDED = 'SET_MAX_UNDO_HISTORY_EXCEEDED';\nexport function setMaxUndoHistoryExceeded(maxUndoHistoryExceeded = true) {\n  return {\n    type: SET_MAX_UNDO_HISTORY_EXCEEDED,\n    payload: { maxUndoHistoryExceeded },\n  };\n}\n\nexport function maxUndoHistoryToast() {\n  return (dispatch, getState) => {\n    const { dashboardLayout } = getState();\n    const historyLength = dashboardLayout.past.length;\n\n    return dispatch(\n      addWarningToast(\n        t(\n          'You have used all %(historyLength)s undo slots and will not be able to fully undo subsequent actions. You may save your current state to reset the history.',\n          { historyLength },\n        ),\n      ),\n    );\n  };\n}\n\nexport const SET_DATASETS_STATUS = 'SET_DATASETS_STATUS';\nexport function setDatasetsStatus(status) {\n  return {\n    type: SET_DATASETS_STATUS,\n    status,\n  };\n}\n\nconst storeDashboardColorConfig = async (id, metadata) =>\n  SupersetClient.put({\n    endpoint: `/api/v1/dashboard/${id}/colors?mark_updated=false`,\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      color_namespace: metadata.color_namespace,\n      color_scheme: metadata.color_scheme,\n      color_scheme_domain: metadata.color_scheme_domain || [],\n      shared_label_colors: metadata.shared_label_colors || [],\n      map_label_colors: metadata.map_label_colors || {},\n      label_colors: metadata.label_colors || {},\n    }),\n  });\n\n/**\n *\n * Persists the label colors maps in the dashboard metadata.\n * It runs when outdated color info are detected in stored metadata.\n *\n * @returns void\n */\nexport const persistDashboardLabelsColor = () => async (dispatch, getState) => {\n  const {\n    dashboardInfo: { id, metadata },\n    dashboardState: { labelsColorMapMustSync, sharedLabelsColorsMustSync },\n  } = getState();\n\n  if (labelsColorMapMustSync || sharedLabelsColorsMustSync) {\n    dispatch(setDashboardLabelsColorMapSynced());\n    dispatch(setDashboardSharedLabelsColorsSynced());\n    storeDashboardColorConfig(id, metadata);\n  }\n};\n\n/**\n * Checks the stored dashboard metadata for inconsistencies.\n * Update the current metadata with validated color information.\n * It runs only on Dashboard page load.\n *\n * @param {*} metadata - the stored dashboard metadata\n * @returns void\n */\nexport const applyDashboardLabelsColorOnLoad = metadata => async dispatch => {\n  try {\n    const customLabelsColor = metadata.label_colors || {};\n    let hasChanged = false;\n\n    // backward compatibility of shared_label_colors\n    const sharedLabels = metadata.shared_label_colors || [];\n    if (!Array.isArray(sharedLabels) && Object.keys(sharedLabels).length > 0) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          shared_label_colors: [],\n        }),\n      );\n    }\n    // backward compatibility of map_label_colors\n    const hasMapLabelColors = !!metadata.map_label_colors;\n\n    let updatedScheme = metadata.color_scheme;\n    const categoricalSchemes = getCategoricalSchemeRegistry();\n    const colorSchemeRegistry = categoricalSchemes.get(updatedScheme, true);\n    const hasInvalidColorScheme = !!updatedScheme && !colorSchemeRegistry;\n\n    // color scheme might not exist any longer\n    if (hasInvalidColorScheme) {\n      const defaultScheme = categoricalSchemes.defaultKey;\n      const fallbackScheme = defaultScheme?.toString() || 'supersetColors';\n      hasChanged = true;\n      updatedScheme = fallbackScheme;\n\n      dispatch(setColorScheme(updatedScheme));\n      dispatch(\n        setDashboardMetadata({\n          color_scheme: updatedScheme,\n        }),\n      );\n    }\n\n    // the stored color domain registry and fresh might differ at this point\n    const freshColorSchemeDomain = updatedScheme\n      ? getColorSchemeDomain(updatedScheme)\n      : [];\n    const currentColorSchemeDomain = metadata.color_scheme_domain || [];\n\n    if (!isEqual(freshColorSchemeDomain, currentColorSchemeDomain)) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          color_scheme_domain: freshColorSchemeDomain,\n        }),\n      );\n    }\n\n    // if color scheme is invalid or map is missing, apply a fresh color map\n    // if valid, apply the stored map to keep consistency across refreshes\n    const shouldGoFresh = !hasMapLabelColors || hasInvalidColorScheme;\n    applyColors(metadata, shouldGoFresh);\n\n    if (shouldGoFresh) {\n      hasChanged = true;\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: getFreshLabelsColorMapEntries(customLabelsColor),\n        }),\n      );\n    }\n\n    if (hasChanged) {\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  } catch (e) {\n    console.error('Failed to update dashboard color on load:', e);\n  }\n};\n\n/**\n *\n * Ensure that the stored color map matches fresh map.\n *\n * @param {*} metadata - the dashboard metadata\n * @returns void\n */\nexport const ensureSyncedLabelsColorMap = metadata => (dispatch, getState) => {\n  const syncLabelsColorMap = () => {\n    const {\n      dashboardState: { labelsColorMapMustSync },\n    } = getState();\n    const customLabelsColor = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColor,\n    );\n    const freshColorMapEntries =\n      getFreshLabelsColorMapEntries(customLabelsColor);\n    const isMapSynced = isLabelsColorMapSynced(\n      fullLabelsColors,\n      freshColorMapEntries,\n      customLabelsColor,\n    );\n\n    if (!isMapSynced) {\n      dispatch(\n        setDashboardMetadata({\n          map_label_colors: freshColorMapEntries,\n        }),\n      );\n    }\n\n    if (!isMapSynced && !labelsColorMapMustSync) {\n      // prepare to persist the just applied labels color map\n      dispatch(setDashboardLabelsColorMapSync());\n    }\n  };\n  promiseTimeout(syncLabelsColorMap, 500);\n};\n\n/**\n *\n * Ensure that the stored shared labels colors match current.\n *\n * @param {*} metadata - the dashboard metadata\n * @param {*} forceFresh - when true it will use the fresh shared labels ignoring stored ones\n * @returns void\n */\nexport const ensureSyncedSharedLabelsColors =\n  (metadata, forceFresh = false) =>\n  (dispatch, getState) => {\n    const syncSharedLabelsColors = () => {\n      const {\n        dashboardState: { sharedLabelsColorsMustSync },\n      } = getState();\n      const sharedLabelsColors = enforceSharedLabelsColorsArray(\n        metadata.shared_label_colors,\n      );\n      const freshLabelsColors = getFreshSharedLabels(\n        forceFresh ? [] : sharedLabelsColors,\n      );\n      const isSharedLabelsColorsSynced = isEqual(\n        sharedLabelsColors.sort(),\n        freshLabelsColors.sort(),\n      );\n      const mustSync = !isSharedLabelsColorsSynced;\n\n      if (mustSync) {\n        dispatch(\n          setDashboardMetadata({\n            shared_label_colors: freshLabelsColors,\n          }),\n        );\n      }\n\n      if (mustSync && !sharedLabelsColorsMustSync) {\n        // prepare to persist the shared labels colors\n        dispatch(setDashboardSharedLabelsColorsSync());\n      }\n    };\n    promiseTimeout(syncSharedLabelsColors, 500);\n  };\n\n/**\n *\n * Updates the color map with new labels and colors as they appear.\n *\n * @param {*} renderedChartIds - the charts that have finished rendering\n * @returns void\n */\nexport const updateDashboardLabelsColor = renderedChartIds => (_, getState) => {\n  try {\n    const {\n      dashboardInfo: { metadata },\n      charts,\n    } = getState();\n    const colorScheme = metadata.color_scheme;\n    const labelsColorMapInstance = getLabelsColorMap();\n    const sharedLabelsColors = enforceSharedLabelsColorsArray(\n      metadata.shared_label_colors,\n    );\n    const customLabelsColors = metadata.label_colors || {};\n    const fullLabelsColors = getDynamicLabelsColors(\n      metadata.map_label_colors || {},\n      customLabelsColors,\n    );\n\n    // for dashboards with no color scheme, the charts should always use their individual schemes\n    // this logic looks for unique labels (not shared across multiple charts) of each rendered chart\n    // it applies a new color to those unique labels when the applied scheme is not up to date\n    // while leaving shared label colors and custom label colors intact for color consistency\n    const shouldReset = [];\n    if (renderedChartIds.length > 0) {\n      const sharedLabelsSet = new Set(sharedLabelsColors);\n      renderedChartIds.forEach(id => {\n        const chart = charts[id];\n        const formData = chart.form_data || chart.latestQueryFormData;\n        // ensure charts have their original color scheme always available\n        labelsColorMapInstance.setOwnColorScheme(\n          formData.slice_id,\n          formData.color_scheme,\n        );\n\n        // if dashboard has a scheme, charts should ignore individual schemes\n        // thus following logic is inapplicable if a dashboard color scheme exists\n        if (colorScheme) return;\n\n        const chartColorScheme = formData.color_scheme;\n        const currentChartConfig = labelsColorMapInstance.chartsLabelsMap.get(\n          formData.slice_id,\n        );\n        const currentChartLabels = currentChartConfig?.labels || [];\n        const uniqueChartLabels = currentChartLabels.filter(\n          l => !sharedLabelsSet.has(l) && !customLabelsColors.hasOwnProperty(l),\n        );\n\n        // Map unique labels to colors\n        const uniqueChartLabelsColor = new Set(\n          uniqueChartLabels.map(l => fullLabelsColors[l]).filter(Boolean),\n        );\n\n        const expectedColorsForChartScheme = new Set(\n          getColorSchemeDomain(chartColorScheme),\n        );\n\n        // Check if any unique label color is not in the expected colors set\n        const shouldResetColors = [...uniqueChartLabelsColor].some(\n          color => !expectedColorsForChartScheme.has(color),\n        );\n\n        // Only push uniqueChartLabels if they require resetting\n        if (shouldResetColors) shouldReset.push(...uniqueChartLabels);\n      });\n    }\n\n    // an existing map is available, use mrge option\n    // to only apply colors to newly found labels\n    const shouldGoFresh = shouldReset.length > 0 ? shouldReset : false;\n    const shouldMerge = !shouldGoFresh;\n    // re-apply the color map first to get fresh maps accordingly\n    applyColors(metadata, shouldGoFresh, shouldMerge);\n  } catch (e) {\n    console.error('Failed to update colors for new charts and labels:', e);\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}