{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Children, cloneElement } from 'react';\nimport { nanoid } from 'nanoid';\nimport { SupersetClient, tn } from '@superset-ui/core';\nimport rison from 'rison';\n\nexport function recurseReactClone(children, type, propExtender) {\n  /**\n   * Clones a React component's children, and injects new props\n   * where the type specified is matched.\n   */\n  return Children.map(children, (child) => {\n    let newChild = child;\n    if (child && child.type.name === type.name) {\n      newChild = /*#__PURE__*/cloneElement(child, propExtender(child));\n    }\n    if (newChild && newChild.props.children) {\n      newChild = /*#__PURE__*/cloneElement(newChild, {\n        children: recurseReactClone(\n          newChild.props.children,\n          type,\n          propExtender\n        )\n      });\n    }\n    return newChild;\n  });\n}\n\nexport function updateColumns(prevCols, newCols, addSuccessToast) {\n  // cols: Array<{column_name: string; is_dttm: boolean; type: string;}>\n  const databaseColumnNames = newCols.map((col) => col.column_name);\n  const currentCols = prevCols.reduce((agg, col) => {\n    // eslint-disable-next-line no-param-reassign\n    agg[col.column_name] = col;\n    return agg;\n  }, {});\n  const columnChanges = {\n    added: [],\n    modified: [],\n    removed: prevCols.\n    filter(\n      (col) =>\n      !(col.expression || databaseColumnNames.includes(col.column_name))\n    ).\n    map((col) => col.column_name),\n    finalColumns: []\n  };\n  newCols.forEach((col) => {\n    const currentCol = currentCols[col.column_name];\n    if (!currentCol) {\n      // new column\n      columnChanges.finalColumns.push({\n        id: nanoid(),\n        column_name: col.column_name,\n        type: col.type,\n        groupby: true,\n        filterable: true,\n        is_dttm: col.is_dttm\n      });\n      columnChanges.added.push(col.column_name);\n    } else if (\n    currentCol.type !== col.type ||\n    currentCol.is_dttm !== col.is_dttm)\n    {\n      // modified column\n      columnChanges.finalColumns.push({\n        ...currentCol,\n        type: col.type,\n        is_dttm: currentCol.is_dttm || col.is_dttm\n      });\n      columnChanges.modified.push(col.column_name);\n    } else {\n      // unchanged\n      columnChanges.finalColumns.push(currentCol);\n    }\n  });\n  // push all calculated columns\n  prevCols.\n  filter((col) => col.expression).\n  forEach((col) => {\n    columnChanges.finalColumns.push(col);\n  });\n\n  if (columnChanges.modified.length) {\n    addSuccessToast(\n      tn(\n        'Modified 1 column in the virtual dataset',\n        'Modified %s columns in the virtual dataset',\n        columnChanges.modified.length\n      )\n    );\n  }\n  if (columnChanges.removed.length) {\n    addSuccessToast(\n      tn(\n        'Removed 1 column from the virtual dataset',\n        'Removed %s columns from the virtual dataset',\n        columnChanges.removed.length\n      )\n    );\n  }\n  if (columnChanges.added.length) {\n    addSuccessToast(\n      tn(\n        'Added 1 new column to the virtual dataset',\n        'Added %s new columns to the virtual dataset',\n        columnChanges.added.length\n      )\n    );\n  }\n  return columnChanges;\n}\n\nexport async function fetchSyncedColumns(datasource) {var _datasource$database, _datasource$database2;\n  const params = {\n    datasource_type: datasource.type || datasource.datasource_type,\n    database_name:\n    ((_datasource$database = datasource.database) == null ? void 0 : _datasource$database.database_name) || ((_datasource$database2 = datasource.database) == null ? void 0 : _datasource$database2.name),\n    catalog_name: datasource.catalog,\n    schema_name: datasource.schema,\n    table_name: datasource.table_name,\n    normalize_columns: datasource.normalize_columns,\n    always_filter_main_dttm: datasource.always_filter_main_dttm\n  };\n  Object.entries(params).forEach(([key, value]) => {\n    // rison can't encode the undefined value\n    if (value === undefined) {\n      params[key] = null;\n    }\n  });\n  const endpoint = `/datasource/external_metadata_by_name/?q=${rison.encode_uri(\n    params\n  )}`;\n  const { json } = await SupersetClient.get({ endpoint });\n  return json;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(recurseReactClone, \"recurseReactClone\", \"/Users/aryurkov/superset/superset-frontend/src/components/Datasource/utils.js\");reactHotLoader.register(updateColumns, \"updateColumns\", \"/Users/aryurkov/superset/superset-frontend/src/components/Datasource/utils.js\");reactHotLoader.register(fetchSyncedColumns, \"fetchSyncedColumns\", \"/Users/aryurkov/superset/superset-frontend/src/components/Datasource/utils.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["Children","cloneElement","nanoid","SupersetClient","tn","rison","recurseReactClone","children","type","propExtender","map","child","newChild","name","props","updateColumns","prevCols","newCols","addSuccessToast","databaseColumnNames","col","column_name","currentCols","reduce","agg","columnChanges","added","modified","removed","filter","expression","includes","finalColumns","forEach","currentCol","push","id","groupby","filterable","is_dttm","length","fetchSyncedColumns","datasource","_datasource$database","_datasource$database2","params","datasource_type","database_name","database","catalog_name","catalog","schema_name","schema","table_name","normalize_columns","always_filter_main_dttm","Object","entries","key","value","undefined","endpoint","encode_uri","json","get","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/components/Datasource/utils.js"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Children, cloneElement } from 'react';\nimport { nanoid } from 'nanoid';\nimport { SupersetClient, tn } from '@superset-ui/core';\nimport rison from 'rison';\n\nexport function recurseReactClone(children, type, propExtender) {\n  /**\n   * Clones a React component's children, and injects new props\n   * where the type specified is matched.\n   */\n  return Children.map(children, child => {\n    let newChild = child;\n    if (child && child.type.name === type.name) {\n      newChild = cloneElement(child, propExtender(child));\n    }\n    if (newChild && newChild.props.children) {\n      newChild = cloneElement(newChild, {\n        children: recurseReactClone(\n          newChild.props.children,\n          type,\n          propExtender,\n        ),\n      });\n    }\n    return newChild;\n  });\n}\n\nexport function updateColumns(prevCols, newCols, addSuccessToast) {\n  // cols: Array<{column_name: string; is_dttm: boolean; type: string;}>\n  const databaseColumnNames = newCols.map(col => col.column_name);\n  const currentCols = prevCols.reduce((agg, col) => {\n    // eslint-disable-next-line no-param-reassign\n    agg[col.column_name] = col;\n    return agg;\n  }, {});\n  const columnChanges = {\n    added: [],\n    modified: [],\n    removed: prevCols\n      .filter(\n        col =>\n          !(col.expression || databaseColumnNames.includes(col.column_name)),\n      )\n      .map(col => col.column_name),\n    finalColumns: [],\n  };\n  newCols.forEach(col => {\n    const currentCol = currentCols[col.column_name];\n    if (!currentCol) {\n      // new column\n      columnChanges.finalColumns.push({\n        id: nanoid(),\n        column_name: col.column_name,\n        type: col.type,\n        groupby: true,\n        filterable: true,\n        is_dttm: col.is_dttm,\n      });\n      columnChanges.added.push(col.column_name);\n    } else if (\n      currentCol.type !== col.type ||\n      currentCol.is_dttm !== col.is_dttm\n    ) {\n      // modified column\n      columnChanges.finalColumns.push({\n        ...currentCol,\n        type: col.type,\n        is_dttm: currentCol.is_dttm || col.is_dttm,\n      });\n      columnChanges.modified.push(col.column_name);\n    } else {\n      // unchanged\n      columnChanges.finalColumns.push(currentCol);\n    }\n  });\n  // push all calculated columns\n  prevCols\n    .filter(col => col.expression)\n    .forEach(col => {\n      columnChanges.finalColumns.push(col);\n    });\n\n  if (columnChanges.modified.length) {\n    addSuccessToast(\n      tn(\n        'Modified 1 column in the virtual dataset',\n        'Modified %s columns in the virtual dataset',\n        columnChanges.modified.length,\n      ),\n    );\n  }\n  if (columnChanges.removed.length) {\n    addSuccessToast(\n      tn(\n        'Removed 1 column from the virtual dataset',\n        'Removed %s columns from the virtual dataset',\n        columnChanges.removed.length,\n      ),\n    );\n  }\n  if (columnChanges.added.length) {\n    addSuccessToast(\n      tn(\n        'Added 1 new column to the virtual dataset',\n        'Added %s new columns to the virtual dataset',\n        columnChanges.added.length,\n      ),\n    );\n  }\n  return columnChanges;\n}\n\nexport async function fetchSyncedColumns(datasource) {\n  const params = {\n    datasource_type: datasource.type || datasource.datasource_type,\n    database_name:\n      datasource.database?.database_name || datasource.database?.name,\n    catalog_name: datasource.catalog,\n    schema_name: datasource.schema,\n    table_name: datasource.table_name,\n    normalize_columns: datasource.normalize_columns,\n    always_filter_main_dttm: datasource.always_filter_main_dttm,\n  };\n  Object.entries(params).forEach(([key, value]) => {\n    // rison can't encode the undefined value\n    if (value === undefined) {\n      params[key] = null;\n    }\n  });\n  const endpoint = `/datasource/external_metadata_by_name/?q=${rison.encode_uri(\n    params,\n  )}`;\n  const { json } = await SupersetClient.get({ endpoint });\n  return json;\n}\n"],"mappings":"wSAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,EAAEC,YAAY,QAAQ,OAAO;AAC9C,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SAASC,cAAc,EAAEC,EAAE,QAAQ,mBAAmB;AACtD,OAAOC,KAAK,MAAM,OAAO;;AAEzB,OAAO,SAASC,iBAAiBA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE;EAC9D;AACF;AACA;AACA;EACE,OAAOT,QAAQ,CAACU,GAAG,CAACH,QAAQ,EAAE,CAAAI,KAAK,KAAI;IACrC,IAAIC,QAAQ,GAAGD,KAAK;IACpB,IAAIA,KAAK,IAAIA,KAAK,CAACH,IAAI,CAACK,IAAI,KAAKL,IAAI,CAACK,IAAI,EAAE;MAC1CD,QAAQ,gBAAGX,YAAY,CAACU,KAAK,EAAEF,YAAY,CAACE,KAAK,CAAC,CAAC;IACrD;IACA,IAAIC,QAAQ,IAAIA,QAAQ,CAACE,KAAK,CAACP,QAAQ,EAAE;MACvCK,QAAQ,gBAAGX,YAAY,CAACW,QAAQ,EAAE;QAChCL,QAAQ,EAAED,iBAAiB;UACzBM,QAAQ,CAACE,KAAK,CAACP,QAAQ;UACvBC,IAAI;UACJC;QACF;MACF,CAAC,CAAC;IACJ;IACA,OAAOG,QAAQ;EACjB,CAAC,CAAC;AACJ;;AAEA,OAAO,SAASG,aAAaA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,eAAe,EAAE;EAChE;EACA,MAAMC,mBAAmB,GAAGF,OAAO,CAACP,GAAG,CAAC,CAAAU,GAAG,KAAIA,GAAG,CAACC,WAAW,CAAC;EAC/D,MAAMC,WAAW,GAAGN,QAAQ,CAACO,MAAM,CAAC,CAACC,GAAG,EAAEJ,GAAG,KAAK;IAChD;IACAI,GAAG,CAACJ,GAAG,CAACC,WAAW,CAAC,GAAGD,GAAG;IAC1B,OAAOI,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,MAAMC,aAAa,GAAG;IACpBC,KAAK,EAAE,EAAE;IACTC,QAAQ,EAAE,EAAE;IACZC,OAAO,EAAEZ,QAAQ;IACda,MAAM;MACL,CAAAT,GAAG;MACD,EAAEA,GAAG,CAACU,UAAU,IAAIX,mBAAmB,CAACY,QAAQ,CAACX,GAAG,CAACC,WAAW,CAAC;IACrE,CAAC;IACAX,GAAG,CAAC,CAAAU,GAAG,KAAIA,GAAG,CAACC,WAAW,CAAC;IAC9BW,YAAY,EAAE;EAChB,CAAC;EACDf,OAAO,CAACgB,OAAO,CAAC,CAAAb,GAAG,KAAI;IACrB,MAAMc,UAAU,GAAGZ,WAAW,CAACF,GAAG,CAACC,WAAW,CAAC;IAC/C,IAAI,CAACa,UAAU,EAAE;MACf;MACAT,aAAa,CAACO,YAAY,CAACG,IAAI,CAAC;QAC9BC,EAAE,EAAElC,MAAM,CAAC,CAAC;QACZmB,WAAW,EAAED,GAAG,CAACC,WAAW;QAC5Bb,IAAI,EAAEY,GAAG,CAACZ,IAAI;QACd6B,OAAO,EAAE,IAAI;QACbC,UAAU,EAAE,IAAI;QAChBC,OAAO,EAAEnB,GAAG,CAACmB;MACf,CAAC,CAAC;MACFd,aAAa,CAACC,KAAK,CAACS,IAAI,CAACf,GAAG,CAACC,WAAW,CAAC;IAC3C,CAAC,MAAM;IACLa,UAAU,CAAC1B,IAAI,KAAKY,GAAG,CAACZ,IAAI;IAC5B0B,UAAU,CAACK,OAAO,KAAKnB,GAAG,CAACmB,OAAO;IAClC;MACA;MACAd,aAAa,CAACO,YAAY,CAACG,IAAI,CAAC;QAC9B,GAAGD,UAAU;QACb1B,IAAI,EAAEY,GAAG,CAACZ,IAAI;QACd+B,OAAO,EAAEL,UAAU,CAACK,OAAO,IAAInB,GAAG,CAACmB;MACrC,CAAC,CAAC;MACFd,aAAa,CAACE,QAAQ,CAACQ,IAAI,CAACf,GAAG,CAACC,WAAW,CAAC;IAC9C,CAAC,MAAM;MACL;MACAI,aAAa,CAACO,YAAY,CAACG,IAAI,CAACD,UAAU,CAAC;IAC7C;EACF,CAAC,CAAC;EACF;EACAlB,QAAQ;EACLa,MAAM,CAAC,CAAAT,GAAG,KAAIA,GAAG,CAACU,UAAU,CAAC;EAC7BG,OAAO,CAAC,CAAAb,GAAG,KAAI;IACdK,aAAa,CAACO,YAAY,CAACG,IAAI,CAACf,GAAG,CAAC;EACtC,CAAC,CAAC;;EAEJ,IAAIK,aAAa,CAACE,QAAQ,CAACa,MAAM,EAAE;IACjCtB,eAAe;MACbd,EAAE;QACA,0CAA0C;QAC1C,4CAA4C;QAC5CqB,aAAa,CAACE,QAAQ,CAACa;MACzB;IACF,CAAC;EACH;EACA,IAAIf,aAAa,CAACG,OAAO,CAACY,MAAM,EAAE;IAChCtB,eAAe;MACbd,EAAE;QACA,2CAA2C;QAC3C,6CAA6C;QAC7CqB,aAAa,CAACG,OAAO,CAACY;MACxB;IACF,CAAC;EACH;EACA,IAAIf,aAAa,CAACC,KAAK,CAACc,MAAM,EAAE;IAC9BtB,eAAe;MACbd,EAAE;QACA,2CAA2C;QAC3C,6CAA6C;QAC7CqB,aAAa,CAACC,KAAK,CAACc;MACtB;IACF,CAAC;EACH;EACA,OAAOf,aAAa;AACtB;;AAEA,OAAO,eAAegB,kBAAkBA,CAACC,UAAU,EAAE,KAAAC,oBAAA,EAAAC,qBAAA;EACnD,MAAMC,MAAM,GAAG;IACbC,eAAe,EAAEJ,UAAU,CAAClC,IAAI,IAAIkC,UAAU,CAACI,eAAe;IAC9DC,aAAa;IACX,EAAAJ,oBAAA,GAAAD,UAAU,CAACM,QAAQ,qBAAnBL,oBAAA,CAAqBI,aAAa,OAAAH,qBAAA,GAAIF,UAAU,CAACM,QAAQ,qBAAnBJ,qBAAA,CAAqB/B,IAAI;IACjEoC,YAAY,EAAEP,UAAU,CAACQ,OAAO;IAChCC,WAAW,EAAET,UAAU,CAACU,MAAM;IAC9BC,UAAU,EAAEX,UAAU,CAACW,UAAU;IACjCC,iBAAiB,EAAEZ,UAAU,CAACY,iBAAiB;IAC/CC,uBAAuB,EAAEb,UAAU,CAACa;EACtC,CAAC;EACDC,MAAM,CAACC,OAAO,CAACZ,MAAM,CAAC,CAACZ,OAAO,CAAC,CAAC,CAACyB,GAAG,EAAEC,KAAK,CAAC,KAAK;IAC/C;IACA,IAAIA,KAAK,KAAKC,SAAS,EAAE;MACvBf,MAAM,CAACa,GAAG,CAAC,GAAG,IAAI;IACpB;EACF,CAAC,CAAC;EACF,MAAMG,QAAQ,GAAG,4CAA4CxD,KAAK,CAACyD,UAAU;IAC3EjB;EACF,CAAC,EAAE;EACH,MAAM,EAAEkB,IAAI,CAAC,CAAC,GAAG,MAAM5D,cAAc,CAAC6D,GAAG,CAAC,EAAEH,QAAQ,CAAC,CAAC,CAAC;EACvD,OAAOE,IAAI;AACb,CAAC,mBAAAE,cAAA,UAAAC,oBAAA,mBAAAA,oBAAA,CAAAC,OAAA,GAAAP,SAAA,MAAAK,cAAA,WAAAA,cAAA,CAAAG,QAAA,CAlIe9D,iBAAiB,wGAAA2D,cAAA,CAAAG,QAAA,CAuBjBrD,aAAa,oGAAAkD,cAAA,CAAAG,QAAA,CAqFP3B,kBAAkB,iIAAA4B,WAAA,UAAAH,oBAAA,mBAAAA,oBAAA,CAAAG,WAAA,GAAAT,SAAA,CAAAS,WAAA,IAAAA,WAAA,CAAAC,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}