{"ast":null,"code":"import _isObject from \"lodash/isObject\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\n\nimport rison from 'rison';\nimport { SupersetClient, runningQueryStateList, QueryState, lruCache } from '@superset-ui/core';\nimport useInterval from 'src/SqlLab/utils/useInterval';\nimport { refreshQueries, clearInactiveQueries, logFailedQuery } from 'src/SqlLab/actions/sqlLab';\nexport const QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n// returns true if the Query.state matches one of the specific values indicating the query is still processing on server\nexport const isQueryRunning = (q) => runningQueryStateList.includes(q == null ? void 0 : q.state);\n// returns true if at least one query is running and within the max age to poll timeframe\nexport const shouldCheckForQueries = (queryList) => {\n  let shouldCheck = false;\n  const now = Date.now();\n  if (_isObject(queryList)) {\n    shouldCheck = Object.values(queryList).some((q) => isQueryRunning(q) && now - (q == null ? void 0 : q.startDttm) < MAX_QUERY_AGE_TO_POLL);\n  }\n  return shouldCheck;\n};\nfunction QueryAutoRefresh({ queries, queriesLastUpdate }) {\n  // We do not want to spam requests in the case of slow connections and potentially receive responses out of order\n  // pendingRequest check ensures we only have one active http call to check for query statuses\n  const pendingRequestRef = useRef(false);\n  const cleanInactiveRequestRef = useRef(false);\n  const failedQueries = useRef(lruCache(1000));\n  const databases = useSelector(({ sqlLab }) => sqlLab.databases);\n  const asyncFetchDbs = useRef(new Set(Object.values(databases).\n  filter(({ allow_run_async }) => Boolean(allow_run_async)).\n  map(({ id }) => id)));\n  const dispatch = useDispatch();\n  const checkForRefresh = () => {\n    const shouldRequestChecking = shouldCheckForQueries(queries);\n    if (!pendingRequestRef.current && shouldRequestChecking) {\n      const params = rison.encode({\n        last_updated_ms: queriesLastUpdate - QUERY_UPDATE_BUFFER_MS\n      });\n      const controller = new AbortController();\n      pendingRequestRef.current = true;\n      SupersetClient.get({\n        endpoint: `/api/v1/query/updated_since?q=${params}`,\n        timeout: QUERY_TIMEOUT_LIMIT,\n        parseMethod: 'json-bigint',\n        signal: controller.signal\n      }).\n      then(({ json }) => {\n        if (json) {var _jsonPayload$result;\n          const jsonPayload = json;\n          if (jsonPayload != null && (_jsonPayload$result = jsonPayload.result) != null && _jsonPayload$result.length) {var _jsonPayload$result$r, _jsonPayload$result2;\n            const queries = (_jsonPayload$result$r = jsonPayload == null ? void 0 : (_jsonPayload$result2 = jsonPayload.result) == null ? void 0 : _jsonPayload$result2.reduce((acc, current) => {\n              acc[current.id] = current;\n              return acc;\n            }, {})) != null ? _jsonPayload$result$r : {};\n            dispatch(refreshQueries(queries));\n            jsonPayload.result.forEach((query) => {\n              const { id, dbId, state } = query;\n              if (asyncFetchDbs.current.has(dbId) &&\n              !failedQueries.current.has(id) &&\n              state === QueryState.Failed) {var _query$extra;\n                dispatch(logFailedQuery(query, (_query$extra = query.extra) == null ? void 0 : _query$extra.errors));\n                failedQueries.current.set(id, true);\n              }\n            });\n          } else\n          {\n            dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n          }\n        }\n      }).\n      catch(() => {\n        controller.abort();\n      }).\n      finally(() => {\n        pendingRequestRef.current = false;\n      });\n    }\n    if (!cleanInactiveRequestRef.current && !shouldRequestChecking) {\n      dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n      cleanInactiveRequestRef.current = true;\n    }\n  };\n  // Solves issue where direct usage of setInterval in function components\n  // uses stale props / state from closure\n  // See comments in the useInterval.ts file for more information\n  useInterval(() => {\n    checkForRefresh();\n  }, QUERY_UPDATE_FREQ);\n  return null;\n}__signature__(QueryAutoRefresh, \"useRef{pendingRequestRef}\\nuseRef{cleanInactiveRequestRef}\\nuseRef{failedQueries}\\nuseSelector{databases}\\nuseRef{asyncFetchDbs}\\nuseDispatch{dispatch}\\nuseInterval{}\", () => [useSelector, useDispatch, useInterval]);const _default =\nQueryAutoRefresh;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(QUERY_UPDATE_FREQ, \"QUERY_UPDATE_FREQ\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QUERY_UPDATE_BUFFER_MS, \"QUERY_UPDATE_BUFFER_MS\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(MAX_QUERY_AGE_TO_POLL, \"MAX_QUERY_AGE_TO_POLL\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QUERY_TIMEOUT_LIMIT, \"QUERY_TIMEOUT_LIMIT\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(isQueryRunning, \"isQueryRunning\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(shouldCheckForQueries, \"shouldCheckForQueries\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(QueryAutoRefresh, \"QueryAutoRefresh\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["useRef","useSelector","useDispatch","rison","SupersetClient","runningQueryStateList","QueryState","lruCache","useInterval","refreshQueries","clearInactiveQueries","logFailedQuery","QUERY_UPDATE_FREQ","QUERY_UPDATE_BUFFER_MS","MAX_QUERY_AGE_TO_POLL","QUERY_TIMEOUT_LIMIT","isQueryRunning","q","includes","state","shouldCheckForQueries","queryList","shouldCheck","now","Date","_isObject","Object","values","some","startDttm","QueryAutoRefresh","queries","queriesLastUpdate","pendingRequestRef","cleanInactiveRequestRef","failedQueries","databases","sqlLab","asyncFetchDbs","Set","filter","allow_run_async","Boolean","map","id","dispatch","checkForRefresh","shouldRequestChecking","current","params","encode","last_updated_ms","controller","AbortController","get","endpoint","timeout","parseMethod","signal","then","json","_jsonPayload$result","jsonPayload","result","length","_jsonPayload$result$r","_jsonPayload$result2","reduce","acc","forEach","query","dbId","has","Failed","_query$extra","extra","errors","set","catch","abort","finally","__signature__","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/SqlLab/components/QueryAutoRefresh/index.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { useRef } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { isObject } from 'lodash';\nimport rison from 'rison';\nimport {\n  SupersetClient,\n  Query,\n  runningQueryStateList,\n  QueryResponse,\n  QueryState,\n  lruCache,\n} from '@superset-ui/core';\nimport { QueryDictionary, SqlLabRootState } from 'src/SqlLab/types';\nimport useInterval from 'src/SqlLab/utils/useInterval';\nimport {\n  refreshQueries,\n  clearInactiveQueries,\n  logFailedQuery,\n} from 'src/SqlLab/actions/sqlLab';\nimport type { DatabaseObject } from 'src/features/databases/types';\n\nexport const QUERY_UPDATE_FREQ = 2000;\nconst QUERY_UPDATE_BUFFER_MS = 5000;\nconst MAX_QUERY_AGE_TO_POLL = 21600000;\nconst QUERY_TIMEOUT_LIMIT = 10000;\n\nexport interface QueryAutoRefreshProps {\n  queries: QueryDictionary;\n  queriesLastUpdate: number;\n}\n\n// returns true if the Query.state matches one of the specific values indicating the query is still processing on server\nexport const isQueryRunning = (q: Query): boolean =>\n  runningQueryStateList.includes(q?.state);\n\n// returns true if at least one query is running and within the max age to poll timeframe\nexport const shouldCheckForQueries = (queryList: QueryDictionary): boolean => {\n  let shouldCheck = false;\n  const now = Date.now();\n  if (isObject(queryList)) {\n    shouldCheck = Object.values(queryList).some(\n      q => isQueryRunning(q) && now - q?.startDttm < MAX_QUERY_AGE_TO_POLL,\n    );\n  }\n  return shouldCheck;\n};\n\nfunction QueryAutoRefresh({\n  queries,\n  queriesLastUpdate,\n}: QueryAutoRefreshProps) {\n  // We do not want to spam requests in the case of slow connections and potentially receive responses out of order\n  // pendingRequest check ensures we only have one active http call to check for query statuses\n  const pendingRequestRef = useRef(false);\n  const cleanInactiveRequestRef = useRef(false);\n  const failedQueries = useRef(lruCache(1000));\n  const databases = useSelector<SqlLabRootState>(\n    ({ sqlLab }) => sqlLab.databases,\n  ) as Record<string, DatabaseObject>;\n  const asyncFetchDbs = useRef(\n    new Set(\n      Object.values(databases)\n        .filter(({ allow_run_async }) => Boolean(allow_run_async))\n        .map(({ id }) => id),\n    ),\n  );\n  const dispatch = useDispatch();\n\n  const checkForRefresh = () => {\n    const shouldRequestChecking = shouldCheckForQueries(queries);\n    if (!pendingRequestRef.current && shouldRequestChecking) {\n      const params = rison.encode({\n        last_updated_ms: queriesLastUpdate - QUERY_UPDATE_BUFFER_MS,\n      });\n\n      const controller = new AbortController();\n      pendingRequestRef.current = true;\n      SupersetClient.get({\n        endpoint: `/api/v1/query/updated_since?q=${params}`,\n        timeout: QUERY_TIMEOUT_LIMIT,\n        parseMethod: 'json-bigint',\n        signal: controller.signal,\n      })\n        .then(({ json }) => {\n          if (json) {\n            const jsonPayload = json as { result?: QueryResponse[] };\n            if (jsonPayload?.result?.length) {\n              const queries =\n                jsonPayload?.result?.reduce(\n                  (acc: Record<string, QueryResponse>, current) => {\n                    acc[current.id] = current;\n                    return acc;\n                  },\n                  {},\n                ) ?? {};\n              dispatch(refreshQueries(queries));\n              jsonPayload.result.forEach(query => {\n                const { id, dbId, state } = query;\n                if (\n                  asyncFetchDbs.current.has(dbId) &&\n                  !failedQueries.current.has(id) &&\n                  state === QueryState.Failed\n                ) {\n                  dispatch(logFailedQuery(query, query.extra?.errors));\n                  failedQueries.current.set(id, true);\n                }\n              });\n            } else {\n              dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n            }\n          }\n        })\n        .catch(() => {\n          controller.abort();\n        })\n        .finally(() => {\n          pendingRequestRef.current = false;\n        });\n    }\n    if (!cleanInactiveRequestRef.current && !shouldRequestChecking) {\n      dispatch(clearInactiveQueries(QUERY_UPDATE_FREQ));\n      cleanInactiveRequestRef.current = true;\n    }\n  };\n\n  // Solves issue where direct usage of setInterval in function components\n  // uses stale props / state from closure\n  // See comments in the useInterval.ts file for more information\n  useInterval(() => {\n    checkForRefresh();\n  }, QUERY_UPDATE_FREQ);\n\n  return null;\n}\n\nexport default QueryAutoRefresh;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}