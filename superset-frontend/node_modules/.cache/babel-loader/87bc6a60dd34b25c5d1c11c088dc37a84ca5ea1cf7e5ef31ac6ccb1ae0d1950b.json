{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { CategoricalColorNamespace, getColumnLabel, getMetricLabel, getNumberFormatter, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, NumberFormats, t, tooltipHtml } from '@superset-ui/core';\nimport { NULL_STRING, OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder } from '../utils/treeBuilder';\nimport { EchartsSunburstLabelType } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nexport function getLinearDomain(treeData, callback) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree) {\n    tree.forEach((treeNode) => {var _treeNode$children;\n      if ((_treeNode$children = treeNode.children) != null && _treeNode$children.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp)\n        min = temp;\n        if (max < temp)\n        max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\nexport function formatLabel({ params, labelType, numberFormatter }) {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value);\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\nexport function formatTooltip({ params, primaryValueFormatter, secondaryValueFormatter, colorByCategory, totalValue, metricLabel, secondaryMetricLabel }) {\n  const { data, treePathInfo = [] } = params;\n  const node = data;\n  const formattedValue = primaryValueFormatter(node.value);\n  const formattedSecondaryValue = secondaryValueFormatter == null ? void 0 : secondaryValueFormatter(node.secondaryValue);\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(node.secondaryValue / node.value);\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode = treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n  const title = (node.name || NULL_STRING).\n  toString().\n  replaceAll('<', '&lt;').\n  replaceAll('>', '&gt;');\n  const rows = [[t('% of total'), absolutePercentage]];\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(node.value / parentNode.value);\n    rows.push([t('% of parent'), conditionalPercentage]);\n  }\n  rows.push([metricLabel, formattedValue]);\n  if (!colorByCategory) {\n    rows.push([\n    secondaryMetricLabel || NULL_STRING,\n    formattedSecondaryValue || NULL_STRING]\n    );\n    rows.push([\n    `${metricLabel}/${secondaryMetricLabel}`,\n    compareValuePercentage]\n    );\n  }\n  return tooltipHtml(rows, title);\n}\nexport default function transformProps(chartProps) {\n  const { formData, height, hooks, filterState, queriesData, width, theme, inContextMenu, emitCrossFilters, datasource } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const { groupby = [], columns = [], metric = '', secondaryMetric = '', colorScheme, linearColorScheme, labelType, numberFormat, currencyFormat, dateFormat, showLabels, showLabelsThreshold, showTotal, sliceId } = formData;\n  const { currencyFormats = {}, columnFormats = {}, verboseMap = {} } = datasource;\n  const refs = {};\n  const primaryValueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, numberFormat, currencyFormat);\n  const secondaryValueFormatter = secondaryMetric ?\n  getValueFormatter(secondaryMetric, currencyFormats, columnFormats, numberFormat, currencyFormat) :\n  undefined;\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params) => formatLabel({\n    params,\n    numberFormatter: primaryValueFormatter,\n    labelType\n  });\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit\n  };\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric ?\n  getMetricLabel(secondaryMetric) :\n  undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(data, columnLabels, metricLabel, secondaryMetricLabel);\n  const totalValue = treeData.reduce((result, treeNode) => result + treeNode.value, 0);\n  const totalSecondaryValue = treeData.reduce((result, treeNode) => result + treeNode.secondaryValue, 0);\n  const categoricalColorScale = CategoricalColorNamespace.getScale(colorScheme);\n  let linearColorScale;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {var _getSequentialSchemeR, _getSequentialSchemeR2;\n    const domain = getLinearDomain(treeData, (node) => node.secondaryValue / node.value);\n    colorByCategory = false;\n    linearColorScale = (_getSequentialSchemeR = getSequentialSchemeRegistry()) == null ? void 0 : (_getSequentialSchemeR2 = _getSequentialSchemeR.\n    get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR2.\n    createLinearScale(domain);\n  }\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else\n  {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n  const traverse = (treeNodes, path, pathRecords) => treeNodes.map((treeNode) => {var _treeNode$children2, _filterState$selected, _filterState$selected2;\n    const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n    const records = [...(pathRecords || []), nodeName];\n    let name = formatSeriesName(nodeName, {\n      numberFormatter,\n      timeFormatter: getTimeFormatter(dateFormat),\n      ...(coltypeMapping[groupBy] && {\n        coltype: coltypeMapping[groupBy]\n      })\n    });\n    const newPath = path.concat(name);\n    let item = {\n      records,\n      name,\n      value,\n      secondaryValue,\n      itemStyle: {\n        color: colorByCategory ?\n        categoricalColorScale(name, sliceId) :\n        linearColorScale(secondaryValue / value)\n      }\n    };\n    if ((_treeNode$children2 = treeNode.children) != null && _treeNode$children2.length) {\n      item.children = traverse(treeNode.children, newPath, records);\n    } else\n    {\n      name = newPath.join(',');\n    }\n    columnsLabelMap.set(name, newPath);\n    if (((_filterState$selected = filterState.selectedValues) == null ? void 0 : (_filterState$selected2 = _filterState$selected[0]) == null ? void 0 : _filterState$selected2.includes(name)) === false) {\n      item = {\n        ...item,\n        itemStyle: {\n          ...item.itemStyle,\n          opacity: OpacityEnum.SemiTransparent\n        },\n        label: {\n          color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`\n        }\n      };\n    }\n    return item;\n  });\n  const echartOptions = {\n    grid: {\n      ...defaultGrid\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params) => formatTooltip({\n        params,\n        primaryValueFormatter,\n        secondaryValueFormatter,\n        colorByCategory,\n        totalValue,\n        metricLabel: verboseMap[metricLabel] || metricLabel,\n        secondaryMetricLabel: secondaryMetricLabel ?\n        verboseMap[secondaryMetricLabel] || secondaryMetricLabel :\n        undefined\n      })\n    },\n    series: [\n    {\n      type: 'sunburst',\n      ...padding,\n      nodeClick: false,\n      emphasis: {\n        focus: 'ancestor',\n        label: {\n          show: showLabels\n        }\n      },\n      label: {\n        width: radius * 0.6 / (columns.length || 1),\n        show: showLabels,\n        formatter,\n        color: theme.colors.grayscale.dark2,\n        minAngle: minShowLabelAngle,\n        overflow: 'breakAll'\n      },\n      radius: [radius * 0.3, radius],\n      data: traverse(treeData, [])\n    }],\n\n    graphic: showTotal ?\n    {\n      type: 'text',\n      top: 'center',\n      left: 'center',\n      style: {\n        text: t('Total: %s', primaryValueFormatter(totalValue)),\n        fontSize: 16,\n        fontWeight: 'bold'\n      },\n      z: 10\n    } :\n    null\n  };\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getLinearDomain, \"getLinearDomain\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(formatLabel, \"formatLabel\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(formatTooltip, \"formatTooltip\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["CategoricalColorNamespace","getColumnLabel","getMetricLabel","getNumberFormatter","getSequentialSchemeRegistry","getTimeFormatter","getValueFormatter","NumberFormats","t","tooltipHtml","NULL_STRING","OpacityEnum","defaultGrid","formatSeriesName","getColtypesMapping","treeBuilder","EchartsSunburstLabelType","getDefaultTooltip","getLinearDomain","treeData","callback","min","max","temp","traverse","tree","forEach","treeNode","_treeNode$children","children","length","formatLabel","params","labelType","numberFormatter","name","value","formattedValue","Key","Value","KeyValue","formatTooltip","primaryValueFormatter","secondaryValueFormatter","colorByCategory","totalValue","metricLabel","secondaryMetricLabel","data","treePathInfo","node","formattedSecondaryValue","secondaryValue","percentFormatter","PERCENT_2_POINT","compareValuePercentage","absolutePercentage","parentNode","undefined","title","toString","replaceAll","rows","conditionalPercentage","push","transformProps","chartProps","formData","height","hooks","filterState","queriesData","width","theme","inContextMenu","emitCrossFilters","datasource","coltypeMapping","groupby","columns","metric","secondaryMetric","colorScheme","linearColorScheme","numberFormat","currencyFormat","dateFormat","showLabels","showLabelsThreshold","showTotal","sliceId","currencyFormats","columnFormats","verboseMap","refs","formatter","minShowLabelAngle","padding","top","gridUnit","right","bottom","left","containerWidth","containerHeight","visWidth","visHeight","radius","Math","setDataMask","onContextMenu","columnsLabelMap","Map","columnLabels","map","reduce","result","totalSecondaryValue","categoricalColorScale","getScale","linearColorScale","_getSequentialSchemeR","_getSequentialSchemeR2","domain","get","createLinearScale","treeNodes","path","pathRecords","_treeNode$children2","_filterState$selected","_filterState$selected2","nodeName","groupBy","records","timeFormatter","coltype","newPath","concat","item","itemStyle","color","join","set","selectedValues","includes","opacity","SemiTransparent","label","echartOptions","grid","tooltip","show","trigger","series","type","nodeClick","emphasis","focus","colors","grayscale","dark2","minAngle","overflow","graphic","style","text","fontSize","fontWeight","z","labelMap","Object","fromEntries","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Sunburst/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  CategoricalColorNamespace,\n  DataRecordValue,\n  getColumnLabel,\n  getMetricLabel,\n  getNumberFormatter,\n  getSequentialSchemeRegistry,\n  getTimeFormatter,\n  getValueFormatter,\n  NumberFormats,\n  t,\n  tooltipHtml,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport type { EChartsCoreOption } from 'echarts/core';\nimport type { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { NULL_STRING, OpacityEnum } from '../constants';\nimport { defaultGrid } from '../defaults';\nimport { Refs } from '../types';\nimport { formatSeriesName, getColtypesMapping } from '../utils/series';\nimport { treeBuilder, TreeNode } from '../utils/treeBuilder';\nimport {\n  EchartsSunburstChartProps,\n  EchartsSunburstLabelType,\n  NodeItemOption,\n  SunburstTransformedProps,\n} from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\n\nexport function getLinearDomain(\n  treeData: TreeNode[],\n  callback: (treeNode: TreeNode) => number,\n) {\n  let min = 0;\n  let max = 0;\n  let temp = null;\n  function traverse(tree: TreeNode[]) {\n    tree.forEach(treeNode => {\n      if (treeNode.children?.length) {\n        traverse(treeNode.children);\n      }\n      temp = callback(treeNode);\n      if (temp !== null) {\n        if (min > temp) min = temp;\n        if (max < temp) max = temp;\n      }\n    });\n  }\n  traverse(treeData);\n  return [min, max];\n}\n\nexport function formatLabel({\n  params,\n  labelType,\n  numberFormatter,\n}: {\n  params: CallbackDataParams;\n  labelType: EchartsSunburstLabelType;\n  numberFormatter: ValueFormatter;\n}): string {\n  const { name = '', value } = params;\n  const formattedValue = numberFormatter(value as number);\n\n  switch (labelType) {\n    case EchartsSunburstLabelType.Key:\n      return name;\n    case EchartsSunburstLabelType.Value:\n      return formattedValue;\n    case EchartsSunburstLabelType.KeyValue:\n      return `${name}: ${formattedValue}`;\n    default:\n      return name;\n  }\n}\n\nexport function formatTooltip({\n  params,\n  primaryValueFormatter,\n  secondaryValueFormatter,\n  colorByCategory,\n  totalValue,\n  metricLabel,\n  secondaryMetricLabel,\n}: {\n  params: CallbackDataParams & {\n    treePathInfo: {\n      name: string;\n      dataIndex: number;\n      value: number;\n    }[];\n  };\n  primaryValueFormatter: ValueFormatter;\n  secondaryValueFormatter: ValueFormatter | undefined;\n  colorByCategory: boolean;\n  totalValue: number;\n  metricLabel: string;\n  secondaryMetricLabel?: string;\n}): string {\n  const { data, treePathInfo = [] } = params;\n  const node = data as TreeNode;\n  const formattedValue = primaryValueFormatter(node.value);\n  const formattedSecondaryValue = secondaryValueFormatter?.(\n    node.secondaryValue,\n  );\n\n  const percentFormatter = getNumberFormatter(NumberFormats.PERCENT_2_POINT);\n  const compareValuePercentage = percentFormatter(\n    node.secondaryValue / node.value,\n  );\n  const absolutePercentage = percentFormatter(node.value / totalValue);\n  const parentNode =\n    treePathInfo.length > 2 ? treePathInfo[treePathInfo.length - 2] : undefined;\n\n  const title = (node.name || NULL_STRING)\n    .toString()\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;');\n  const rows = [[t('% of total'), absolutePercentage]];\n  if (parentNode) {\n    const conditionalPercentage = percentFormatter(\n      node.value / parentNode.value,\n    );\n    rows.push([t('% of parent'), conditionalPercentage]);\n  }\n  rows.push([metricLabel, formattedValue]);\n  if (!colorByCategory) {\n    rows.push([\n      secondaryMetricLabel || NULL_STRING,\n      formattedSecondaryValue || NULL_STRING,\n    ]);\n    rows.push([\n      `${metricLabel}/${secondaryMetricLabel}`,\n      compareValuePercentage,\n    ]);\n  }\n  return tooltipHtml(rows, title);\n}\n\nexport default function transformProps(\n  chartProps: EchartsSunburstChartProps,\n): SunburstTransformedProps {\n  const {\n    formData,\n    height,\n    hooks,\n    filterState,\n    queriesData,\n    width,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n    datasource,\n  } = chartProps;\n  const { data = [] } = queriesData[0];\n  const coltypeMapping = getColtypesMapping(queriesData[0]);\n  const {\n    groupby = [],\n    columns = [],\n    metric = '',\n    secondaryMetric = '',\n    colorScheme,\n    linearColorScheme,\n    labelType,\n    numberFormat,\n    currencyFormat,\n    dateFormat,\n    showLabels,\n    showLabelsThreshold,\n    showTotal,\n    sliceId,\n  } = formData;\n  const {\n    currencyFormats = {},\n    columnFormats = {},\n    verboseMap = {},\n  } = datasource;\n  const refs: Refs = {};\n  const primaryValueFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    numberFormat,\n    currencyFormat,\n  );\n  const secondaryValueFormatter = secondaryMetric\n    ? getValueFormatter(\n        secondaryMetric,\n        currencyFormats,\n        columnFormats,\n        numberFormat,\n        currencyFormat,\n      )\n    : undefined;\n\n  const numberFormatter = getNumberFormatter(numberFormat);\n  const formatter = (params: CallbackDataParams) =>\n    formatLabel({\n      params,\n      numberFormatter: primaryValueFormatter,\n      labelType,\n    });\n  const minShowLabelAngle = (showLabelsThreshold || 0) * 3.6;\n  const padding = {\n    top: theme.gridUnit * 3,\n    right: theme.gridUnit,\n    bottom: theme.gridUnit * 3,\n    left: theme.gridUnit,\n  };\n  const containerWidth = width;\n  const containerHeight = height;\n  const visWidth = containerWidth - padding.left - padding.right;\n  const visHeight = containerHeight - padding.top - padding.bottom;\n  const radius = Math.min(visWidth, visHeight) / 2;\n  const { setDataMask = () => {}, onContextMenu } = hooks;\n  const columnsLabelMap = new Map<string, string[]>();\n  const metricLabel = getMetricLabel(metric);\n  const secondaryMetricLabel = secondaryMetric\n    ? getMetricLabel(secondaryMetric)\n    : undefined;\n  const columnLabels = columns.map(getColumnLabel);\n  const treeData = treeBuilder(\n    data,\n    columnLabels,\n    metricLabel,\n    secondaryMetricLabel,\n  );\n  const totalValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.value,\n    0,\n  );\n  const totalSecondaryValue = treeData.reduce(\n    (result, treeNode) => result + treeNode.secondaryValue,\n    0,\n  );\n\n  const categoricalColorScale = CategoricalColorNamespace.getScale(\n    colorScheme as string,\n  );\n  let linearColorScale: any;\n  let colorByCategory = true;\n  if (secondaryMetric && metric !== secondaryMetric) {\n    const domain = getLinearDomain(\n      treeData,\n      node => node.secondaryValue / node.value,\n    );\n    colorByCategory = false;\n    linearColorScale = getSequentialSchemeRegistry()\n      ?.get(linearColorScheme)\n      ?.createLinearScale(domain);\n  }\n\n  // add a base color to keep feature parity\n  if (colorByCategory) {\n    categoricalColorScale(metricLabel, sliceId);\n  } else {\n    linearColorScale(totalSecondaryValue / totalValue);\n  }\n\n  const traverse = (\n    treeNodes: TreeNode[],\n    path: string[],\n    pathRecords?: DataRecordValue[],\n  ) =>\n    treeNodes.map(treeNode => {\n      const { name: nodeName, value, secondaryValue, groupBy } = treeNode;\n      const records = [...(pathRecords || []), nodeName];\n      let name = formatSeriesName(nodeName, {\n        numberFormatter,\n        timeFormatter: getTimeFormatter(dateFormat),\n        ...(coltypeMapping[groupBy] && {\n          coltype: coltypeMapping[groupBy],\n        }),\n      });\n      const newPath = path.concat(name);\n      let item: NodeItemOption = {\n        records,\n        name,\n        value,\n        secondaryValue,\n        itemStyle: {\n          color: colorByCategory\n            ? categoricalColorScale(name, sliceId)\n            : linearColorScale(secondaryValue / value),\n        },\n      };\n      if (treeNode.children?.length) {\n        item.children = traverse(treeNode.children, newPath, records);\n      } else {\n        name = newPath.join(',');\n      }\n      columnsLabelMap.set(name, newPath);\n      if (filterState.selectedValues?.[0]?.includes(name) === false) {\n        item = {\n          ...item,\n          itemStyle: {\n            ...item.itemStyle,\n            opacity: OpacityEnum.SemiTransparent,\n          },\n          label: {\n            color: `rgba(0, 0, 0, ${OpacityEnum.SemiTransparent})`,\n          },\n        };\n      }\n      return item;\n    });\n\n  const echartOptions: EChartsCoreOption = {\n    grid: {\n      ...defaultGrid,\n    },\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: 'item',\n      formatter: (params: any) =>\n        formatTooltip({\n          params,\n          primaryValueFormatter,\n          secondaryValueFormatter,\n          colorByCategory,\n          totalValue,\n          metricLabel: verboseMap[metricLabel] || metricLabel,\n          secondaryMetricLabel: secondaryMetricLabel\n            ? verboseMap[secondaryMetricLabel] || secondaryMetricLabel\n            : undefined,\n        }),\n    },\n    series: [\n      {\n        type: 'sunburst',\n        ...padding,\n        nodeClick: false,\n        emphasis: {\n          focus: 'ancestor',\n          label: {\n            show: showLabels,\n          },\n        },\n        label: {\n          width: (radius * 0.6) / (columns.length || 1),\n          show: showLabels,\n          formatter,\n          color: theme.colors.grayscale.dark2,\n          minAngle: minShowLabelAngle,\n          overflow: 'breakAll',\n        },\n        radius: [radius * 0.3, radius],\n        data: traverse(treeData, []),\n      },\n    ],\n    graphic: showTotal\n      ? {\n          type: 'text',\n          top: 'center',\n          left: 'center',\n          style: {\n            text: t('Total: %s', primaryValueFormatter(totalValue)),\n            fontSize: 16,\n            fontWeight: 'bold',\n          },\n          z: 10,\n        }\n      : null,\n  };\n\n  return {\n    formData,\n    width,\n    height,\n    echartOptions,\n    setDataMask,\n    emitCrossFilters,\n    labelMap: Object.fromEntries(columnsLabelMap),\n    groupby,\n    selectedValues: filterState.selectedValues || [],\n    onContextMenu,\n    refs,\n    coltypeMapping,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}