{"ast":null,"code":"import _isObject from \"lodash/isObject\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { convertKeysToCamelCase } from '@superset-ui/core';\n\nconst COLUMN_SEPARATOR = ', ';\n/**\n * Get the indices of columns where the title is a geojson.\n *\n * @param columns List of column names.\n * @returns List of indices containing geojsonColumns.\n */\nexport const getGeojsonColumns = (columns) => columns.reduce((prev, current, idx) => {\n  let parsedColName;\n  try {\n    parsedColName = JSON.parse(current);\n  }\n  catch {\n    parsedColName = undefined;\n  }\n  if (!parsedColName || !_isObject(parsedColName)) {\n    return [...prev];\n  }\n  if (!('type' in parsedColName) || !('coordinates' in parsedColName)) {\n    return [...prev];\n  }\n  return [...prev, idx];\n}, []);\n/**\n * Create a column name ignoring provided indices.\n *\n * @param columns List of column names.\n * @param ignoreIdx List of indices to ignore.\n * @returns Column name.\n */\nexport const createColumnName = (columns, ignoreIdx) => columns.filter((l, idx) => !ignoreIdx.includes(idx)).join(COLUMN_SEPARATOR);\n/**\n * Group data by location for data providing a generic\n * x-axis.\n *\n * @param data The data to group.\n * @param params The data params.\n * @returns Data grouped by location.\n */\nexport const groupByLocationGenericX = (data, params, queryData) => {\n  const locations = {};\n  if (!data) {\n    return locations;\n  }\n  data.forEach((d) => {\n    Object.keys(d).\n    filter((k) => k !== params.x_axis).\n    forEach((k) => {var _queryData$label_map;\n      const labelMap = (_queryData$label_map = queryData.label_map) == null ? void 0 : _queryData$label_map[k];\n      if (!labelMap) {\n        console.log('Cannot extract location from queryData. label_map not defined');\n        return;\n      }\n      const geojsonCols = getGeojsonColumns(labelMap);\n      if (geojsonCols.length > 1) {\n        // TODO what should we do, if there is more than one geom column?\n        console.log('More than one geometry column detected. Using first found.');\n      }\n      const location = labelMap[geojsonCols[0]];\n      const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n      const leftOverKey = createColumnName(labelMap, filter);\n      if (!Object.keys(locations).includes(location)) {\n        locations[location] = [];\n      }\n      let dataAtX = locations[location].find((i) => i[params.x_axis] === d[params.x_axis]);\n      if (!dataAtX) {\n        dataAtX = {\n          // add the x_axis value explicitly, since we\n          // filtered it out for the rest of the computation.\n          [params.x_axis]: d[params.x_axis]\n        };\n        locations[location].push(dataAtX);\n      }\n      dataAtX[leftOverKey] = d[k];\n    });\n  });\n  return locations;\n};\n/**\n * Group data by location.\n *\n * @param data The incoming dataset\n * @param geomColumn The name of the geometry column\n * @returns The grouped data\n */\nexport const groupByLocation = (data, geomColumn) => {\n  const locations = {};\n  data.forEach((d) => {\n    const loc = d[geomColumn];\n    if (!loc) {\n      return;\n    }\n    if (!Object.keys(locations).includes(loc)) {\n      locations[loc] = [];\n    }\n    const newData = {\n      ...d\n    };\n    delete newData[geomColumn];\n    locations[loc].push(newData);\n  });\n  return locations;\n};\n/**\n * Strips the geom from colnames and coltypes.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns colnames and coltypes without the geom.\n */\nexport const stripGeomFromColnamesAndTypes = (queryData, geomColumn) => {var _queryData$colnames;\n  const newColnames = [];\n  const newColtypes = [];\n  (_queryData$colnames = queryData.colnames) == null ? void 0 : _queryData$colnames.forEach((colname, idx) => {\n    if (colname === geomColumn) {\n      return;\n    }\n    const parts = colname.split(COLUMN_SEPARATOR);\n    const geojsonColumns = getGeojsonColumns(parts);\n    const filter = geojsonColumns.length ? [geojsonColumns[0]] : [];\n    const newColname = createColumnName(parts, filter);\n    if (newColnames.includes(newColname)) {\n      return;\n    }\n    newColnames.push(newColname);\n    newColtypes.push(queryData.coltypes[idx]);\n  });\n  return {\n    colnames: newColnames,\n    coltypes: newColtypes\n  };\n};\n/**\n * Strips the geom from labelMap.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns labelMap without the geom column.\n */\nexport const stripGeomColumnFromLabelMap = (labelMap, geomColumn) => {\n  const newLabelMap = {};\n  Object.entries(labelMap).forEach(([key, value]) => {\n    if (key === geomColumn) {\n      return;\n    }\n    const geojsonCols = getGeojsonColumns(value);\n    const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n    const columnName = createColumnName(value, filter);\n    const restItems = value.filter((v, idx) => !geojsonCols.includes(idx));\n    newLabelMap[columnName] = restItems;\n  });\n  return newLabelMap;\n};\n/**\n * Strip occurrences of the geom column from the query data.\n *\n * @param queryDataClone The query data\n * @param geomColumn The name of the geom column\n * @returns query data without geom column.\n */\nexport const stripGeomColumnFromQueryData = (queryData, geomColumn) => {\n  const queryDataClone = {\n    ...structuredClone(queryData),\n    ...stripGeomFromColnamesAndTypes(queryData, geomColumn)\n  };\n  if (queryDataClone.label_map) {\n    queryDataClone.label_map = stripGeomColumnFromLabelMap(queryData.label_map, geomColumn);\n  }\n  return queryDataClone;\n};\n/**\n * Create the chart configurations depending on the referenced Superset chart.\n *\n * @param selectedChart The configuration of the referenced Superset chart\n * @param geomColumn The name of the geometry column\n * @param chartProps The properties provided within this OL plugin\n * @param chartTransformer The transformer function\n * @returns The chart configurations\n */\nexport const getChartConfigs = (selectedChart, geomColumn, chartProps, chartTransformer) => {\n  const chartFormDataSnake = selectedChart.params;\n  const chartFormData = convertKeysToCamelCase(chartFormDataSnake);\n  const baseConfig = {\n    ...chartProps,\n    // We overwrite width and height, which are not needed\n    // here, but leads to unnecessary updating of the UI.\n    width: null,\n    height: null,\n    formData: chartFormData,\n    rawFormData: chartFormDataSnake,\n    datasource: {}\n  };\n  const { queriesData } = chartProps;\n  const [queryData] = queriesData;\n  const data = queryData.data;\n  let dataByLocation;\n  const chartConfigs = {\n    type: 'FeatureCollection',\n    features: []\n  };\n  if (!data) {\n    return chartConfigs;\n  }\n  if ('x_axis' in selectedChart.params) {\n    dataByLocation = groupByLocationGenericX(data, selectedChart.params, queryData);\n  } else\n  {\n    dataByLocation = groupByLocation(data, geomColumn);\n  }\n  const strippedQueryData = stripGeomColumnFromQueryData(queryData, geomColumn);\n  Object.keys(dataByLocation).forEach((location) => {\n    const config = {\n      ...baseConfig,\n      queriesData: [\n      {\n        ...strippedQueryData,\n        data: dataByLocation[location]\n      }]\n\n    };\n    const transformedProps = chartTransformer(config);\n    const feature = {\n      type: 'Feature',\n      geometry: JSON.parse(location),\n      properties: {\n        ...transformedProps\n      }\n    };\n    chartConfigs.features.push(feature);\n  });\n  return chartConfigs;\n};\n/**\n * Return the same chart configuration with parsed values for of the stringified \"params\" object.\n *\n * @param selectedChart Incoming chart configuration\n * @returns Chart configuration with parsed values for \"params\"\n */\nexport const parseSelectedChart = (selectedChart) => {\n  const selectedChartParsed = JSON.parse(selectedChart);\n  selectedChartParsed.params = JSON.parse(selectedChartParsed.params);\n  return selectedChartParsed;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(COLUMN_SEPARATOR, \"COLUMN_SEPARATOR\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(getGeojsonColumns, \"getGeojsonColumns\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(createColumnName, \"createColumnName\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(groupByLocationGenericX, \"groupByLocationGenericX\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(groupByLocation, \"groupByLocation\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(stripGeomFromColnamesAndTypes, \"stripGeomFromColnamesAndTypes\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(stripGeomColumnFromLabelMap, \"stripGeomColumnFromLabelMap\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(stripGeomColumnFromQueryData, \"stripGeomColumnFromQueryData\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(getChartConfigs, \"getChartConfigs\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");reactHotLoader.register(parseSelectedChart, \"parseSelectedChart\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["convertKeysToCamelCase","COLUMN_SEPARATOR","getGeojsonColumns","columns","reduce","prev","current","idx","parsedColName","JSON","parse","undefined","_isObject","createColumnName","ignoreIdx","filter","l","includes","join","groupByLocationGenericX","data","params","queryData","locations","forEach","d","Object","keys","k","x_axis","_queryData$label_map","labelMap","label_map","console","log","geojsonCols","length","location","leftOverKey","dataAtX","find","i","push","groupByLocation","geomColumn","loc","newData","stripGeomFromColnamesAndTypes","_queryData$colnames","newColnames","newColtypes","colnames","colname","parts","split","geojsonColumns","newColname","coltypes","stripGeomColumnFromLabelMap","newLabelMap","entries","key","value","columnName","restItems","v","stripGeomColumnFromQueryData","queryDataClone","structuredClone","getChartConfigs","selectedChart","chartProps","chartTransformer","chartFormDataSnake","chartFormData","baseConfig","width","height","formData","rawFormData","datasource","queriesData","dataByLocation","chartConfigs","type","features","strippedQueryData","config","transformedProps","feature","geometry","properties","parseSelectedChart","selectedChartParsed","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-cartodiagram/src/util/transformPropsUtil.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport {\n  ChartProps,\n  convertKeysToCamelCase,\n  DataRecord,\n} from '@superset-ui/core';\nimport { isObject } from 'lodash';\nimport {\n  LocationConfigMapping,\n  SelectedChartConfig,\n  ChartConfig,\n  ChartConfigFeature,\n} from '../types';\n\nconst COLUMN_SEPARATOR = ', ';\n\n/**\n * Get the indices of columns where the title is a geojson.\n *\n * @param columns List of column names.\n * @returns List of indices containing geojsonColumns.\n */\nexport const getGeojsonColumns = (columns: string[]) =>\n  columns.reduce((prev, current, idx) => {\n    let parsedColName;\n    try {\n      parsedColName = JSON.parse(current);\n    } catch {\n      parsedColName = undefined;\n    }\n    if (!parsedColName || !isObject(parsedColName)) {\n      return [...prev];\n    }\n    if (!('type' in parsedColName) || !('coordinates' in parsedColName)) {\n      return [...prev];\n    }\n    return [...prev, idx];\n  }, []);\n\n/**\n * Create a column name ignoring provided indices.\n *\n * @param columns List of column names.\n * @param ignoreIdx List of indices to ignore.\n * @returns Column name.\n */\nexport const createColumnName = (columns: string[], ignoreIdx: number[]) =>\n  columns.filter((l, idx) => !ignoreIdx.includes(idx)).join(COLUMN_SEPARATOR);\n\n/**\n * Group data by location for data providing a generic\n * x-axis.\n *\n * @param data The data to group.\n * @param params The data params.\n * @returns Data grouped by location.\n */\nexport const groupByLocationGenericX = (\n  data: DataRecord[],\n  params: SelectedChartConfig['params'],\n  queryData: any,\n) => {\n  const locations: LocationConfigMapping = {};\n  if (!data) {\n    return locations;\n  }\n  data.forEach(d => {\n    Object.keys(d)\n      .filter(k => k !== params.x_axis)\n      .forEach(k => {\n        const labelMap: string[] = queryData.label_map?.[k];\n\n        if (!labelMap) {\n          console.log(\n            'Cannot extract location from queryData. label_map not defined',\n          );\n          return;\n        }\n\n        const geojsonCols = getGeojsonColumns(labelMap);\n\n        if (geojsonCols.length > 1) {\n          // TODO what should we do, if there is more than one geom column?\n          console.log(\n            'More than one geometry column detected. Using first found.',\n          );\n        }\n        const location = labelMap[geojsonCols[0]];\n        const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n        const leftOverKey = createColumnName(labelMap, filter);\n\n        if (!Object.keys(locations).includes(location)) {\n          locations[location] = [];\n        }\n\n        let dataAtX = locations[location].find(\n          i => i[params.x_axis] === d[params.x_axis],\n        );\n\n        if (!dataAtX) {\n          dataAtX = {\n            // add the x_axis value explicitly, since we\n            // filtered it out for the rest of the computation.\n            [params.x_axis]: d[params.x_axis],\n          };\n          locations[location].push(dataAtX);\n        }\n        dataAtX[leftOverKey] = d[k];\n      });\n  });\n\n  return locations;\n};\n\n/**\n * Group data by location.\n *\n * @param data The incoming dataset\n * @param geomColumn The name of the geometry column\n * @returns The grouped data\n */\nexport const groupByLocation = (data: DataRecord[], geomColumn: string) => {\n  const locations: LocationConfigMapping = {};\n\n  data.forEach(d => {\n    const loc = d[geomColumn] as string;\n    if (!loc) {\n      return;\n    }\n\n    if (!Object.keys(locations).includes(loc)) {\n      locations[loc] = [];\n    }\n\n    const newData = {\n      ...d,\n    };\n    delete newData[geomColumn];\n\n    locations[loc].push(newData);\n  });\n\n  return locations;\n};\n\n/**\n * Strips the geom from colnames and coltypes.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns colnames and coltypes without the geom.\n */\nexport const stripGeomFromColnamesAndTypes = (\n  queryData: any,\n  geomColumn: string,\n) => {\n  const newColnames: string[] = [];\n  const newColtypes: number[] = [];\n  queryData.colnames?.forEach((colname: string, idx: number) => {\n    if (colname === geomColumn) {\n      return;\n    }\n\n    const parts = colname.split(COLUMN_SEPARATOR);\n    const geojsonColumns = getGeojsonColumns(parts);\n    const filter = geojsonColumns.length ? [geojsonColumns[0]] : [];\n\n    const newColname = createColumnName(parts, filter);\n    if (newColnames.includes(newColname)) {\n      return;\n    }\n    newColnames.push(newColname);\n    newColtypes.push(queryData.coltypes[idx]);\n  });\n\n  return {\n    colnames: newColnames,\n    coltypes: newColtypes,\n  };\n};\n\n/**\n * Strips the geom from labelMap.\n *\n * @param queryData The querydata.\n * @param geomColumn Name of the geom column.\n * @returns labelMap without the geom column.\n */\nexport const stripGeomColumnFromLabelMap = (\n  labelMap: { [key: string]: string[] },\n  geomColumn: string,\n) => {\n  const newLabelMap: Record<string, string[]> = {};\n  Object.entries(labelMap).forEach(([key, value]) => {\n    if (key === geomColumn) {\n      return;\n    }\n    const geojsonCols = getGeojsonColumns(value);\n    const filter = geojsonCols.length ? [geojsonCols[0]] : [];\n    const columnName = createColumnName(value, filter);\n    const restItems = value.filter((v, idx) => !geojsonCols.includes(idx));\n    newLabelMap[columnName] = restItems;\n  });\n  return newLabelMap;\n};\n\n/**\n * Strip occurrences of the geom column from the query data.\n *\n * @param queryDataClone The query data\n * @param geomColumn The name of the geom column\n * @returns query data without geom column.\n */\nexport const stripGeomColumnFromQueryData = (\n  queryData: any,\n  geomColumn: string,\n) => {\n  const queryDataClone = {\n    ...structuredClone(queryData),\n    ...stripGeomFromColnamesAndTypes(queryData, geomColumn),\n  };\n  if (queryDataClone.label_map) {\n    queryDataClone.label_map = stripGeomColumnFromLabelMap(\n      queryData.label_map,\n      geomColumn,\n    );\n  }\n  return queryDataClone;\n};\n\n/**\n * Create the chart configurations depending on the referenced Superset chart.\n *\n * @param selectedChart The configuration of the referenced Superset chart\n * @param geomColumn The name of the geometry column\n * @param chartProps The properties provided within this OL plugin\n * @param chartTransformer The transformer function\n * @returns The chart configurations\n */\nexport const getChartConfigs = (\n  selectedChart: SelectedChartConfig,\n  geomColumn: string,\n  chartProps: ChartProps,\n  chartTransformer: any,\n) => {\n  const chartFormDataSnake = selectedChart.params;\n  const chartFormData = convertKeysToCamelCase(chartFormDataSnake);\n\n  const baseConfig = {\n    ...chartProps,\n    // We overwrite width and height, which are not needed\n    // here, but leads to unnecessary updating of the UI.\n    width: null,\n    height: null,\n    formData: chartFormData,\n    rawFormData: chartFormDataSnake,\n    datasource: {},\n  };\n\n  const { queriesData } = chartProps;\n  const [queryData] = queriesData;\n\n  const data = queryData.data as DataRecord[];\n  let dataByLocation: LocationConfigMapping;\n\n  const chartConfigs: ChartConfig = {\n    type: 'FeatureCollection',\n    features: [],\n  };\n\n  if (!data) {\n    return chartConfigs;\n  }\n\n  if ('x_axis' in selectedChart.params) {\n    dataByLocation = groupByLocationGenericX(\n      data,\n      selectedChart.params,\n      queryData,\n    );\n  } else {\n    dataByLocation = groupByLocation(data, geomColumn);\n  }\n\n  const strippedQueryData = stripGeomColumnFromQueryData(queryData, geomColumn);\n\n  Object.keys(dataByLocation).forEach(location => {\n    const config = {\n      ...baseConfig,\n      queriesData: [\n        {\n          ...strippedQueryData,\n          data: dataByLocation[location],\n        },\n      ],\n    };\n    const transformedProps = chartTransformer(config);\n\n    const feature: ChartConfigFeature = {\n      type: 'Feature',\n      geometry: JSON.parse(location),\n      properties: {\n        ...transformedProps,\n      },\n    };\n\n    chartConfigs.features.push(feature);\n  });\n  return chartConfigs;\n};\n\n/**\n * Return the same chart configuration with parsed values for of the stringified \"params\" object.\n *\n * @param selectedChart Incoming chart configuration\n * @returns Chart configuration with parsed values for \"params\"\n */\nexport const parseSelectedChart = (selectedChart: string) => {\n  const selectedChartParsed = JSON.parse(selectedChart);\n  selectedChartParsed.params = JSON.parse(selectedChartParsed.params);\n  return selectedChartParsed;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}