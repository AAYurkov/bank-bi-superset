{"ast":null,"code":"import _minBy from \"lodash/minBy\";import _maxBy from \"lodash/maxBy\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { GenericDataType, NumberFormats, getColumnLabel, getMetricLabel, getSequentialSchemeRegistry, getTimeFormatter, getValueFormatter, rgbToHex, addAlpha, supersetTheme, tooltipHtml } from '@superset-ui/core';\nimport memoizeOne from 'memoize-one';\n\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { parseAxisBound } from '../utils/controls';\nimport { NULL_STRING } from '../constants';\nimport { getPercentFormatter } from '../utils/formatters';\nconst DEFAULT_ECHARTS_BOUNDS = [0, 200];\n// Calculated totals per x and y categories plus total\nconst calculateTotals = memoizeOne((data, xAxis, groupby, metric) => data.reduce((acc, row) => {\n  const value = row[metric];\n  if (typeof value !== 'number') {\n    return acc;\n  }\n  const x = row[xAxis];\n  const y = row[groupby];\n  const xTotal = acc.x[x] || 0;\n  const yTotal = acc.y[y] || 0;\n  return {\n    x: { ...acc.x, [x]: xTotal + value },\n    y: { ...acc.y, [y]: yTotal + value },\n    total: acc.total + value\n  };\n}, { x: {}, y: {}, total: 0 }));\nexport default function transformProps(chartProps) {var _getSequentialSchemeR;\n  const refs = {};\n  const { width, height, formData, queriesData, datasource } = chartProps;\n  const { bottomMargin, xAxis, groupby, linearColorScheme, leftMargin, legendType = 'continuous', metric = '', normalizeAcross, normalized, borderColor, borderWidth = 0, showLegend, showPercentage, showValues, xscaleInterval, yscaleInterval, valueBounds, yAxisFormat, xAxisTimeFormat, currencyFormat } = formData;\n  const metricLabel = getMetricLabel(metric);\n  const xAxisLabel = getColumnLabel(xAxis);\n  // groupby is overridden to be a single value\n  const yAxisLabel = getColumnLabel(groupby);\n  const { data, colnames, coltypes } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const colorColumn = normalized ? 'rank' : metricLabel;\n  const colors = (_getSequentialSchemeR = getSequentialSchemeRegistry().get(linearColorScheme)) == null ? void 0 : _getSequentialSchemeR.colors;\n  const getAxisFormatter = (colType) => (value) => {\n    if (colType === GenericDataType.Temporal) {\n      if (typeof value === 'string') {\n        return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n      }\n      return getTimeFormatter(xAxisTimeFormat)(value);\n    }\n    return String(value);\n  };\n  const xAxisFormatter = getAxisFormatter(coltypes[0]);\n  const yAxisFormatter = getAxisFormatter(coltypes[1]);\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const valueFormatter = getValueFormatter(metric, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  let [min, max] = (valueBounds || []).map(parseAxisBound);\n  if (min === undefined) {var _minBy2;\n    min =\n    ((_minBy2 = _minBy(data, (row) => row[colorColumn])) == null ? void 0 : _minBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[0];\n  }\n  if (max === undefined) {var _maxBy2;\n    max =\n    ((_maxBy2 = _maxBy(data, (row) => row[colorColumn])) == null ? void 0 : _maxBy2[colorColumn]) ||\n    DEFAULT_ECHARTS_BOUNDS[1];\n  }\n  const series = [\n  {\n    name: metricLabel,\n    type: 'heatmap',\n    data: data.map((row) => colnames.map((col) => {\n      const value = row[col];\n      if (value === null || value === undefined) {\n        return NULL_STRING;\n      }\n      if (typeof value === 'boolean' || typeof value === 'bigint') {\n        return String(value);\n      }\n      return value;\n    })),\n    label: {\n      show: showValues,\n      formatter: (params) => {\n        const paramsValue = params.value;\n        return valueFormatter(paramsValue == null ? void 0 : paramsValue[2]);\n      }\n    },\n    itemStyle: {\n      borderColor: addAlpha(rgbToHex(borderColor.r, borderColor.g, borderColor.b), borderColor.a),\n      borderWidth\n    },\n    emphasis: {\n      itemStyle: {\n        borderColor: supersetTheme.colors.grayscale.light5,\n        shadowBlur: 10,\n        shadowColor: supersetTheme.colors.grayscale.dark2\n      }\n    }\n  }];\n\n  const echartOptions = {\n    grid: {\n      containLabel: true,\n      bottom: bottomMargin,\n      left: leftMargin\n    },\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (params) => {\n        const totals = calculateTotals(data, xAxisLabel, yAxisLabel, metricLabel);\n        const paramsValue = params.value;\n        const x = paramsValue == null ? void 0 : paramsValue[0];\n        const y = paramsValue == null ? void 0 : paramsValue[1];\n        const value = paramsValue == null ? void 0 : paramsValue[2];\n        const formattedX = xAxisFormatter(x);\n        const formattedY = yAxisFormatter(y);\n        const formattedValue = valueFormatter(value);\n        let percentage = 0;\n        let suffix = 'heatmap';\n        if (typeof value === 'number') {\n          if (normalizeAcross === 'x') {\n            percentage = value / totals.x[x];\n            suffix = formattedX;\n          } else\n          if (normalizeAcross === 'y') {\n            percentage = value / totals.y[y];\n            suffix = formattedY;\n          } else\n          {\n            percentage = value / totals.total;\n            suffix = 'heatmap';\n          }\n        }\n        const title = `${formattedX} (${formattedY})`;\n        const row = [colnames[2], formattedValue];\n        if (showPercentage) {\n          row.push(`${percentFormatter(percentage)} (${suffix})`);\n        }\n        return tooltipHtml([row], title);\n      }\n    },\n    visualMap: {\n      type: legendType,\n      min,\n      max,\n      calculable: true,\n      orient: 'horizontal',\n      right: 0,\n      top: 0,\n      itemHeight: legendType === 'continuous' ? 300 : 14,\n      itemWidth: 15,\n      formatter: (min) => valueFormatter(min),\n      inRange: {\n        color: colors\n      },\n      show: showLegend,\n      // By default, ECharts uses the last dimension which is rank\n      dimension: normalized ? 3 : 2\n    },\n    xAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        interval: xscaleInterval === -1 ? 'auto' : xscaleInterval - 1\n      }\n    },\n    yAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: yAxisFormatter,\n        interval: yscaleInterval === -1 ? 'auto' : yscaleInterval - 1\n      }\n    }\n  };\n  return {\n    refs,\n    echartOptions,\n    width,\n    height,\n    formData\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DEFAULT_ECHARTS_BOUNDS, \"DEFAULT_ECHARTS_BOUNDS\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");reactHotLoader.register(calculateTotals, \"calculateTotals\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");reactHotLoader.register(transformProps, \"transformProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["GenericDataType","NumberFormats","getColumnLabel","getMetricLabel","getSequentialSchemeRegistry","getTimeFormatter","getValueFormatter","rgbToHex","addAlpha","supersetTheme","tooltipHtml","memoizeOne","getDefaultTooltip","parseAxisBound","NULL_STRING","getPercentFormatter","DEFAULT_ECHARTS_BOUNDS","calculateTotals","data","xAxis","groupby","metric","reduce","acc","row","value","x","y","xTotal","yTotal","total","transformProps","chartProps","_getSequentialSchemeR","refs","width","height","formData","queriesData","datasource","bottomMargin","linearColorScheme","leftMargin","legendType","normalizeAcross","normalized","borderColor","borderWidth","showLegend","showPercentage","showValues","xscaleInterval","yscaleInterval","valueBounds","yAxisFormat","xAxisTimeFormat","currencyFormat","metricLabel","xAxisLabel","yAxisLabel","colnames","coltypes","columnFormats","currencyFormats","colorColumn","colors","get","getAxisFormatter","colType","Temporal","Number","parseInt","String","xAxisFormatter","yAxisFormatter","percentFormatter","PERCENT_2_POINT","valueFormatter","min","max","map","undefined","_minBy2","_minBy","_maxBy2","_maxBy","series","name","type","col","label","show","formatter","params","paramsValue","itemStyle","r","g","b","a","emphasis","grayscale","light5","shadowBlur","shadowColor","dark2","echartOptions","grid","containLabel","bottom","left","tooltip","totals","formattedX","formattedY","formattedValue","percentage","suffix","title","push","visualMap","calculable","orient","right","top","itemHeight","itemWidth","inRange","color","dimension","axisLabel","interval","yAxis","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Heatmap/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  GenericDataType,\n  NumberFormats,\n  QueryFormColumn,\n  getColumnLabel,\n  getMetricLabel,\n  getSequentialSchemeRegistry,\n  getTimeFormatter,\n  getValueFormatter,\n  rgbToHex,\n  addAlpha,\n  supersetTheme,\n  tooltipHtml,\n} from '@superset-ui/core';\nimport memoizeOne from 'memoize-one';\nimport { maxBy, minBy } from 'lodash';\nimport type { ComposeOption } from 'echarts/core';\nimport type { HeatmapSeriesOption } from 'echarts/charts';\nimport type { CallbackDataParams } from 'echarts/types/src/util/types';\nimport { HeatmapChartProps, HeatmapTransformedProps } from './types';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { Refs } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { NULL_STRING } from '../constants';\nimport { getPercentFormatter } from '../utils/formatters';\n\ntype EChartsOption = ComposeOption<HeatmapSeriesOption>;\n\nconst DEFAULT_ECHARTS_BOUNDS = [0, 200];\n\n// Calculated totals per x and y categories plus total\nconst calculateTotals = memoizeOne(\n  (\n    data: Record<string, any>[],\n    xAxis: string,\n    groupby: string,\n    metric: string,\n  ) =>\n    data.reduce(\n      (acc, row) => {\n        const value = row[metric];\n        if (typeof value !== 'number') {\n          return acc;\n        }\n        const x = row[xAxis] as string;\n        const y = row[groupby] as string;\n        const xTotal = acc.x[x] || 0;\n        const yTotal = acc.y[y] || 0;\n        return {\n          x: { ...acc.x, [x]: xTotal + value },\n          y: { ...acc.y, [y]: yTotal + value },\n          total: acc.total + value,\n        };\n      },\n      { x: {}, y: {}, total: 0 },\n    ),\n);\n\nexport default function transformProps(\n  chartProps: HeatmapChartProps,\n): HeatmapTransformedProps {\n  const refs: Refs = {};\n  const { width, height, formData, queriesData, datasource } = chartProps;\n  const {\n    bottomMargin,\n    xAxis,\n    groupby,\n    linearColorScheme,\n    leftMargin,\n    legendType = 'continuous',\n    metric = '',\n    normalizeAcross,\n    normalized,\n    borderColor,\n    borderWidth = 0,\n    showLegend,\n    showPercentage,\n    showValues,\n    xscaleInterval,\n    yscaleInterval,\n    valueBounds,\n    yAxisFormat,\n    xAxisTimeFormat,\n    currencyFormat,\n  } = formData;\n  const metricLabel = getMetricLabel(metric);\n  const xAxisLabel = getColumnLabel(xAxis);\n  // groupby is overridden to be a single value\n  const yAxisLabel = getColumnLabel(groupby as unknown as QueryFormColumn);\n  const { data, colnames, coltypes } = queriesData[0];\n  const { columnFormats = {}, currencyFormats = {} } = datasource;\n  const colorColumn = normalized ? 'rank' : metricLabel;\n  const colors = getSequentialSchemeRegistry().get(linearColorScheme)?.colors;\n  const getAxisFormatter =\n    (colType: GenericDataType) => (value: number | string) => {\n      if (colType === GenericDataType.Temporal) {\n        if (typeof value === 'string') {\n          return getTimeFormatter(xAxisTimeFormat)(Number.parseInt(value, 10));\n        }\n        return getTimeFormatter(xAxisTimeFormat)(value);\n      }\n      return String(value);\n    };\n\n  const xAxisFormatter = getAxisFormatter(coltypes[0]);\n  const yAxisFormatter = getAxisFormatter(coltypes[1]);\n  const percentFormatter = getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const valueFormatter = getValueFormatter(\n    metric,\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n\n  let [min, max] = (valueBounds || []).map(parseAxisBound);\n  if (min === undefined) {\n    min =\n      (minBy(data, row => row[colorColumn])?.[colorColumn] as number) ||\n      DEFAULT_ECHARTS_BOUNDS[0];\n  }\n  if (max === undefined) {\n    max =\n      (maxBy(data, row => row[colorColumn])?.[colorColumn] as number) ||\n      DEFAULT_ECHARTS_BOUNDS[1];\n  }\n\n  const series: HeatmapSeriesOption[] = [\n    {\n      name: metricLabel,\n      type: 'heatmap',\n      data: data.map(row =>\n        colnames.map(col => {\n          const value = row[col];\n          if (value === null || value === undefined) {\n            return NULL_STRING;\n          }\n          if (typeof value === 'boolean' || typeof value === 'bigint') {\n            return String(value);\n          }\n          return value;\n        }),\n      ),\n      label: {\n        show: showValues,\n        formatter: (params: CallbackDataParams) => {\n          const paramsValue = params.value as (string | number)[];\n          return valueFormatter(paramsValue?.[2] as number | null | undefined);\n        },\n      },\n      itemStyle: {\n        borderColor: addAlpha(\n          rgbToHex(borderColor.r, borderColor.g, borderColor.b),\n          borderColor.a,\n        ),\n        borderWidth,\n      },\n      emphasis: {\n        itemStyle: {\n          borderColor: supersetTheme.colors.grayscale.light5,\n          shadowBlur: 10,\n          shadowColor: supersetTheme.colors.grayscale.dark2,\n        },\n      },\n    },\n  ];\n\n  const echartOptions: EChartsOption = {\n    grid: {\n      containLabel: true,\n      bottom: bottomMargin,\n      left: leftMargin,\n    },\n    series,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      formatter: (params: CallbackDataParams) => {\n        const totals = calculateTotals(\n          data,\n          xAxisLabel,\n          yAxisLabel,\n          metricLabel,\n        );\n        const paramsValue = params.value as (string | number)[];\n        const x = paramsValue?.[0];\n        const y = paramsValue?.[1];\n        const value = paramsValue?.[2] as number | null | undefined;\n        const formattedX = xAxisFormatter(x);\n        const formattedY = yAxisFormatter(y);\n        const formattedValue = valueFormatter(value);\n        let percentage = 0;\n        let suffix = 'heatmap';\n        if (typeof value === 'number') {\n          if (normalizeAcross === 'x') {\n            percentage = value / totals.x[x];\n            suffix = formattedX;\n          } else if (normalizeAcross === 'y') {\n            percentage = value / totals.y[y];\n            suffix = formattedY;\n          } else {\n            percentage = value / totals.total;\n            suffix = 'heatmap';\n          }\n        }\n        const title = `${formattedX} (${formattedY})`;\n        const row = [colnames[2], formattedValue];\n        if (showPercentage) {\n          row.push(`${percentFormatter(percentage)} (${suffix})`);\n        }\n        return tooltipHtml([row], title);\n      },\n    },\n    visualMap: {\n      type: legendType,\n      min,\n      max,\n      calculable: true,\n      orient: 'horizontal',\n      right: 0,\n      top: 0,\n      itemHeight: legendType === 'continuous' ? 300 : 14,\n      itemWidth: 15,\n      formatter: (min: number) => valueFormatter(min),\n      inRange: {\n        color: colors,\n      },\n      show: showLegend,\n      // By default, ECharts uses the last dimension which is rank\n      dimension: normalized ? 3 : 2,\n    },\n    xAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: xAxisFormatter,\n        interval: xscaleInterval === -1 ? 'auto' : xscaleInterval - 1,\n      },\n    },\n    yAxis: {\n      type: 'category',\n      axisLabel: {\n        formatter: yAxisFormatter,\n        interval: yscaleInterval === -1 ? 'auto' : yscaleInterval - 1,\n      },\n    },\n  };\n  return {\n    refs,\n    echartOptions,\n    width,\n    height,\n    formData,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}