{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { scaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getLabelsColorMap, { LabelsColorMapSource } from './LabelsColorMapSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\nclass CategoricalColorScale extends ExtensibleFunction {\n\n\n\n\n\n\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} forcedColors optional parameter that comes from parent\n   * @param {*} appliedColorScheme the color scheme applied to the chart\n   *\n   */\n  constructor(colors, forcedColors = {}, appliedColorScheme) {\n    super((value, sliceId) => this.getColor(value, sliceId, appliedColorScheme));\n    // holds original color scheme colors\n    this.originColors = void 0;this.colors = void 0;this.scale = void 0;this.forcedColors = void 0;this.labelsColorMapInstance = void 0;this.chartLabelsColorMap = void 0;this.multiple = void 0;this.originColors = colors;\n    // holds the extended color range (includes analogous colors)\n    this.colors = colors;\n    // holds the values of this specific slice (label+color)\n    this.chartLabelsColorMap = new Map();\n    // shared color map instance (when context is shared, i.e. dashboard)\n    this.labelsColorMapInstance = getLabelsColorMap();\n    // holds the multiple value for analogous colors range\n    this.multiple = 0;\n    this.scale = scaleOrdinal();\n    this.scale.range(colors);\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(forcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        forcedColors[key] = colors[value % colors.length];\n      }\n    });\n    // forced colors from parent (usually CategoricalColorNamespace)\n    // currently used in dashboards to set custom label colors\n    this.forcedColors = forcedColors;\n  }\n  /**\n   * Increment the color range with analogous colors\n   */\n  incrementColorRange() {\n    const multiple = Math.floor(this.domain().length / this.originColors.length);\n    // the domain has grown larger than the original range\n    // increments the range with analogous colors\n    if (multiple > this.multiple) {\n      this.multiple = multiple;\n      const newRange = getAnalogousColors(this.originColors, multiple);\n      const extendedColors = this.originColors.concat(newRange);\n      this.range(extendedColors);\n      this.colors = extendedColors;\n    }\n  }\n  /**\n   * Get the color for a given value\n   *\n   * @param value the value of a label to get the color for\n   * @param sliceId the ID of the current chart\n   * @param appliedColorScheme the color scheme applied to the chart\n   * @returns the color or the next available color\n   */\n  getColor(value, sliceId, appliedColorScheme) {var _this$forcedColors;\n    const cleanedValue = stringifyAndTrim(value);\n    // priority: forced color (aka custom label colors) > shared color > scale color\n    const forcedColor = (_this$forcedColors = this.forcedColors) == null ? void 0 : _this$forcedColors[cleanedValue];\n    const { source } = this.labelsColorMapInstance;\n    const currentColorMap = source === LabelsColorMapSource.Dashboard ?\n    this.labelsColorMapInstance.getColorMap() :\n    this.chartLabelsColorMap;\n    const isExistingLabel = currentColorMap.has(cleanedValue);\n    let color = forcedColor || (\n    isExistingLabel ?\n    currentColorMap.get(cleanedValue) :\n    this.scale(cleanedValue));\n    // a forced color will always be used independently of the usage count\n    if (!forcedColor && !isExistingLabel) {\n      if (isFeatureEnabled(FeatureFlag.UseAnalogousColors)) {\n        this.incrementColorRange();\n      }\n      if (\n      // feature flag to be deprecated (will become standard behaviour)\n      isFeatureEnabled(FeatureFlag.AvoidColorsCollision) &&\n      this.isColorUsed(color)) {\n        // fallback to least used color\n        color = this.getNextAvailableColor(cleanedValue, color);\n      }\n    }\n    // keep track of values in this slice\n    this.chartLabelsColorMap.set(cleanedValue, color);\n    // store the value+color in the LabelsColorMapSingleton\n    if (sliceId) {\n      this.labelsColorMapInstance.addSlice(cleanedValue, color, sliceId, appliedColorScheme);\n    }\n    return color;\n  }\n  /**\n   * Verify if a color is used in this slice\n   *\n   * @param color\n   * @returns true if the color is used in this slice\n   */\n  isColorUsed(color) {\n    return this.getColorUsageCount(color) > 0;\n  }\n  /**\n   * Get the count of the color usage in this slice\n   *\n   * @param sliceId the ID of the current slice\n   * @param color the color to check\n   * @returns the count of the color usage in this slice\n   */\n  getColorUsageCount(color) {\n    return Array.from(this.chartLabelsColorMap.values()).filter((value) => value === color).length;\n  }\n  /**\n   * Lower chances of color collision by returning the least used color.\n   * Checks across colors of current slice within chartLabelsColorMap.\n   *\n   * @param currentLabel the current label\n   * @param currentColor the current color\n   * @returns the least used color that is not the current color\n   */\n  getNextAvailableColor(currentLabel, currentColor) {\n    // Precompute color usage counts for all colors\n    const colorUsageCounts = new Map(this.colors.map((color) => [color, this.getColorUsageCount(color)]));\n    // Get an ordered array of labels from the map\n    const orderedLabels = Array.from(this.chartLabelsColorMap.keys());\n    const currentLabelIndex = orderedLabels.indexOf(currentLabel);\n    // Helper to infer \"previous\" and \"next\" labels based on index\n    const getAdjacentLabelsColors = () => {\n      const previousLabel = currentLabelIndex > 0 ? orderedLabels[currentLabelIndex - 1] : null;\n      const nextLabel = currentLabelIndex < orderedLabels.length - 1 ?\n      orderedLabels[currentLabelIndex + 1] :\n      null;\n      const previousColor = previousLabel ?\n      this.chartLabelsColorMap.get(previousLabel) :\n      null;\n      const nextColor = nextLabel ?\n      this.chartLabelsColorMap.get(nextLabel) :\n      null;\n      return [previousColor, nextColor].filter((color) => color);\n    };\n    const adjacentColors = getAdjacentLabelsColors();\n    // Determine adjusted score (usage count + penalties)\n    const calculateScore = (color) => {\n      /* istanbul ignore next */\n      const usageCount = colorUsageCounts.get(color) || 0;\n      const adjacencyPenalty = adjacentColors.includes(color) ? 100 : 0;\n      return usageCount + adjacencyPenalty;\n    };\n    // If there is any color that has never been used, prioritize it\n    const unusedColor = this.colors.find((color) => (colorUsageCounts.get(color) || 0) === 0);\n    if (unusedColor) {\n      return unusedColor;\n    }\n    // If all colors are used, calculate scores and choose the best one\n    const otherColors = this.colors.filter((color) => color !== currentColor);\n    // Find the color with the minimum score, defaulting to currentColor\n    return otherColors.reduce((bestColor, color) => {\n      const bestScore = calculateScore(bestColor);\n      const currentScore = calculateScore(color);\n      return currentScore < bestScore ? color : bestColor;\n    }, currentColor);\n  }\n  /**\n   * Enforce specific color for a given value at the scale level\n   * Overrides any existing color and forced color for the given value\n   *\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   * @returns {CategoricalColorScale}\n   */\n  setColor(value, forcedColor) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n  /**\n   * Get a mapping of data values to colors\n   *\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap = {};\n    this.scale.domain().forEach((value) => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n    return {\n      ...colorMap,\n      ...this.forcedColors\n    };\n  }\n  /**\n   * Return an exact copy of this scale.\n   * Changes to this scale will not affect the returned scale and vice versa.\n   *\n   * @returns {CategoricalColorScale} A copy of this scale.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(this.scale.range(), this.forcedColors);\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n  domain(newDomain) {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n    this.scale.domain(newDomain);\n    return this;\n  }\n  range(newRange) {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n  unknown(value) {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n    this.scale.unknown(value);\n    return this;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}const _default = CategoricalColorScale;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(CategoricalColorScale, \"CategoricalColorScale\", \"/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts\");reactHotLoader.register(_default, \"default\", \"/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["scaleOrdinal","ExtensibleFunction","stringifyAndTrim","getLabelsColorMap","LabelsColorMapSource","getAnalogousColors","FeatureFlag","isFeatureEnabled","CategoricalColorScale","constructor","colors","forcedColors","appliedColorScheme","value","sliceId","getColor","originColors","scale","labelsColorMapInstance","chartLabelsColorMap","multiple","Map","range","Object","entries","forEach","key","length","incrementColorRange","Math","floor","domain","newRange","extendedColors","concat","_this$forcedColors","cleanedValue","forcedColor","source","currentColorMap","Dashboard","getColorMap","isExistingLabel","has","color","get","UseAnalogousColors","AvoidColorsCollision","isColorUsed","getNextAvailableColor","set","addSlice","getColorUsageCount","Array","from","values","filter","currentLabel","currentColor","colorUsageCounts","map","orderedLabels","keys","currentLabelIndex","indexOf","getAdjacentLabelsColors","previousLabel","nextLabel","previousColor","nextColor","adjacentColors","calculateScore","usageCount","adjacencyPenalty","includes","unusedColor","find","otherColors","reduce","bestColor","bestScore","currentScore","setColor","colorMap","toString","copy","unknown","newDomain","__reactstandin__regenerateByEval","code","eval","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/packages/superset-ui-core/src/color/CategoricalColorScale.ts"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { scaleOrdinal, ScaleOrdinal } from 'd3-scale';\nimport { ExtensibleFunction } from '../models';\nimport { ColorsInitLookup, ColorsLookup } from './types';\nimport stringifyAndTrim from './stringifyAndTrim';\nimport getLabelsColorMap, {\n  LabelsColorMapSource,\n} from './LabelsColorMapSingleton';\nimport { getAnalogousColors } from './utils';\nimport { FeatureFlag, isFeatureEnabled } from '../utils';\n\n// Use type augmentation to correct the fact that\n// an instance of CategoricalScale is also a function\ninterface CategoricalColorScale {\n  (x: { toString(): string }, y?: number): string;\n}\n\nclass CategoricalColorScale extends ExtensibleFunction {\n  originColors: string[];\n\n  colors: string[];\n\n  scale: ScaleOrdinal<{ toString(): string }, string>;\n\n  forcedColors: ColorsLookup;\n\n  labelsColorMapInstance: ReturnType<typeof getLabelsColorMap>;\n\n  chartLabelsColorMap: Map<string, string>;\n\n  multiple: number;\n\n  /**\n   * Constructor\n   * @param {*} colors an array of colors\n   * @param {*} forcedColors optional parameter that comes from parent\n   * @param {*} appliedColorScheme the color scheme applied to the chart\n   *\n   */\n  constructor(\n    colors: string[],\n    forcedColors: ColorsInitLookup = {},\n    appliedColorScheme?: string,\n  ) {\n    super((value: string, sliceId?: number) =>\n      this.getColor(value, sliceId, appliedColorScheme),\n    );\n    // holds original color scheme colors\n    this.originColors = colors;\n    // holds the extended color range (includes analogous colors)\n    this.colors = colors;\n    // holds the values of this specific slice (label+color)\n    this.chartLabelsColorMap = new Map();\n    // shared color map instance (when context is shared, i.e. dashboard)\n    this.labelsColorMapInstance = getLabelsColorMap();\n    // holds the multiple value for analogous colors range\n    this.multiple = 0;\n\n    this.scale = scaleOrdinal<{ toString(): string }, string>();\n    this.scale.range(colors);\n\n    // reserve fixed colors in parent map based on their index in the scale\n    Object.entries(forcedColors).forEach(([key, value]) => {\n      if (typeof value === 'number') {\n        // eslint-disable-next-line no-param-reassign\n        forcedColors[key] = colors[value % colors.length];\n      }\n    });\n\n    // forced colors from parent (usually CategoricalColorNamespace)\n    // currently used in dashboards to set custom label colors\n    this.forcedColors = forcedColors as ColorsLookup;\n  }\n\n  /**\n   * Increment the color range with analogous colors\n   */\n  incrementColorRange() {\n    const multiple = Math.floor(\n      this.domain().length / this.originColors.length,\n    );\n    // the domain has grown larger than the original range\n    // increments the range with analogous colors\n    if (multiple > this.multiple) {\n      this.multiple = multiple;\n      const newRange = getAnalogousColors(this.originColors, multiple);\n      const extendedColors = this.originColors.concat(newRange);\n\n      this.range(extendedColors);\n      this.colors = extendedColors;\n    }\n  }\n\n  /**\n   * Get the color for a given value\n   *\n   * @param value the value of a label to get the color for\n   * @param sliceId the ID of the current chart\n   * @param appliedColorScheme the color scheme applied to the chart\n   * @returns the color or the next available color\n   */\n  getColor(\n    value?: string,\n    sliceId?: number,\n    appliedColorScheme?: string,\n  ): string {\n    const cleanedValue = stringifyAndTrim(value);\n    // priority: forced color (aka custom label colors) > shared color > scale color\n    const forcedColor = this.forcedColors?.[cleanedValue];\n    const { source } = this.labelsColorMapInstance;\n    const currentColorMap =\n      source === LabelsColorMapSource.Dashboard\n        ? this.labelsColorMapInstance.getColorMap()\n        : this.chartLabelsColorMap;\n    const isExistingLabel = currentColorMap.has(cleanedValue);\n    let color =\n      forcedColor ||\n      (isExistingLabel\n        ? (currentColorMap.get(cleanedValue) as string)\n        : this.scale(cleanedValue));\n\n    // a forced color will always be used independently of the usage count\n    if (!forcedColor && !isExistingLabel) {\n      if (isFeatureEnabled(FeatureFlag.UseAnalogousColors)) {\n        this.incrementColorRange();\n      }\n      if (\n        // feature flag to be deprecated (will become standard behaviour)\n        isFeatureEnabled(FeatureFlag.AvoidColorsCollision) &&\n        this.isColorUsed(color)\n      ) {\n        // fallback to least used color\n        color = this.getNextAvailableColor(cleanedValue, color);\n      }\n    }\n\n    // keep track of values in this slice\n    this.chartLabelsColorMap.set(cleanedValue, color);\n\n    // store the value+color in the LabelsColorMapSingleton\n    if (sliceId) {\n      this.labelsColorMapInstance.addSlice(\n        cleanedValue,\n        color,\n        sliceId,\n        appliedColorScheme,\n      );\n    }\n    return color;\n  }\n\n  /**\n   * Verify if a color is used in this slice\n   *\n   * @param color\n   * @returns true if the color is used in this slice\n   */\n  isColorUsed(color: string): boolean {\n    return this.getColorUsageCount(color) > 0;\n  }\n\n  /**\n   * Get the count of the color usage in this slice\n   *\n   * @param sliceId the ID of the current slice\n   * @param color the color to check\n   * @returns the count of the color usage in this slice\n   */\n  getColorUsageCount(color: string): number {\n    return Array.from(this.chartLabelsColorMap.values()).filter(\n      value => value === color,\n    ).length;\n  }\n\n  /**\n   * Lower chances of color collision by returning the least used color.\n   * Checks across colors of current slice within chartLabelsColorMap.\n   *\n   * @param currentLabel the current label\n   * @param currentColor the current color\n   * @returns the least used color that is not the current color\n   */\n  getNextAvailableColor(currentLabel: string, currentColor: string): string {\n    // Precompute color usage counts for all colors\n    const colorUsageCounts = new Map(\n      this.colors.map(color => [color, this.getColorUsageCount(color)]),\n    );\n\n    // Get an ordered array of labels from the map\n    const orderedLabels = Array.from(this.chartLabelsColorMap.keys());\n    const currentLabelIndex = orderedLabels.indexOf(currentLabel);\n\n    // Helper to infer \"previous\" and \"next\" labels based on index\n    const getAdjacentLabelsColors = (): string[] => {\n      const previousLabel =\n        currentLabelIndex > 0 ? orderedLabels[currentLabelIndex - 1] : null;\n      const nextLabel =\n        currentLabelIndex < orderedLabels.length - 1\n          ? orderedLabels[currentLabelIndex + 1]\n          : null;\n\n      const previousColor = previousLabel\n        ? this.chartLabelsColorMap.get(previousLabel)\n        : null;\n      const nextColor = nextLabel\n        ? this.chartLabelsColorMap.get(nextLabel)\n        : null;\n\n      return [previousColor, nextColor].filter(color => color) as string[];\n    };\n\n    const adjacentColors = getAdjacentLabelsColors();\n\n    // Determine adjusted score (usage count + penalties)\n    const calculateScore = (color: string): number => {\n      /* istanbul ignore next */\n      const usageCount = colorUsageCounts.get(color) || 0;\n      const adjacencyPenalty = adjacentColors.includes(color) ? 100 : 0;\n      return usageCount + adjacencyPenalty;\n    };\n\n    // If there is any color that has never been used, prioritize it\n    const unusedColor = this.colors.find(\n      color => (colorUsageCounts.get(color) || 0) === 0,\n    );\n    if (unusedColor) {\n      return unusedColor;\n    }\n\n    // If all colors are used, calculate scores and choose the best one\n    const otherColors = this.colors.filter(color => color !== currentColor);\n\n    // Find the color with the minimum score, defaulting to currentColor\n    return otherColors.reduce((bestColor, color) => {\n      const bestScore = calculateScore(bestColor);\n      const currentScore = calculateScore(color);\n      return currentScore < bestScore ? color : bestColor;\n    }, currentColor);\n  }\n\n  /**\n   * Enforce specific color for a given value at the scale level\n   * Overrides any existing color and forced color for the given value\n   *\n   * @param {*} value value\n   * @param {*} forcedColor forcedColor\n   * @returns {CategoricalColorScale}\n   */\n  setColor(value: string, forcedColor: string) {\n    this.forcedColors[stringifyAndTrim(value)] = forcedColor;\n    return this;\n  }\n\n  /**\n   * Get a mapping of data values to colors\n   *\n   * @returns an object where the key is the data value and the value is the hex color code\n   */\n  getColorMap() {\n    const colorMap: { [key: string]: string | undefined } = {};\n    this.scale.domain().forEach(value => {\n      colorMap[value.toString()] = this.scale(value);\n    });\n\n    return {\n      ...colorMap,\n      ...this.forcedColors,\n    };\n  }\n\n  /**\n   * Return an exact copy of this scale.\n   * Changes to this scale will not affect the returned scale and vice versa.\n   *\n   * @returns {CategoricalColorScale} A copy of this scale.\n   */\n  copy() {\n    const copy = new CategoricalColorScale(\n      this.scale.range(),\n      this.forcedColors,\n    );\n    copy.forcedColors = { ...this.forcedColors };\n    copy.domain(this.domain());\n    copy.unknown(this.unknown());\n    return copy;\n  }\n\n  /**\n   * Returns the scale's current domain.\n   */\n  domain(): { toString(): string }[];\n\n  /**\n   * Expands the domain to include the specified array of values.\n   */\n  domain(newDomain: { toString(): string }[]): this;\n\n  domain(newDomain?: { toString(): string }[]): unknown {\n    if (typeof newDomain === 'undefined') {\n      return this.scale.domain();\n    }\n\n    this.scale.domain(newDomain);\n    return this;\n  }\n\n  /**\n   * Returns the scale's current range.\n   */\n  range(): string[];\n\n  /**\n   * Sets the range of the ordinal scale to the specified array of values.\n   *\n   * The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on.\n   *\n   * If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range.\n   *\n   * @param newRange Array of range values.\n   */\n  range(newRange: string[]): this;\n\n  range(newRange?: string[]): unknown {\n    if (typeof newRange === 'undefined') {\n      return this.scale.range();\n    }\n\n    this.colors = newRange;\n    this.scale.range(newRange);\n    return this;\n  }\n\n  /**\n   * Returns the current unknown value, which defaults to \"implicit\".\n   */\n  unknown(): string | { name: 'implicit' };\n\n  /**\n   * Sets the output value of the scale for unknown input values and returns this scale.\n   * The implicit value enables implicit domain construction. scaleImplicit can be used as a convenience to set the implicit value.\n   *\n   * @param value Unknown value to be used or scaleImplicit to set implicit scale generation.\n   */\n  unknown(value: string | { name: 'implicit' }): this;\n\n  unknown(value?: string | { name: 'implicit' }): unknown {\n    if (typeof value === 'undefined') {\n      return this.scale.unknown();\n    }\n\n    this.scale.unknown(value);\n    return this;\n  }\n}\n\nexport default CategoricalColorScale;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}