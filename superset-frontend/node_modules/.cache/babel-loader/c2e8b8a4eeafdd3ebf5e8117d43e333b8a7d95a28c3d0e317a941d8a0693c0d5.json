{"ast":null,"code":"import _pick from \"lodash/pick\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { createSelector } from '@reduxjs/toolkit';\nimport { LabelsColorMapSource, getLabelsColorMap } from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\n\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { useChartIds } from 'src/dashboard/util/charts/useChartIds';\nimport { applyDashboardLabelsColorOnLoad, updateDashboardLabelsColor, persistDashboardLabelsColor, ensureSyncedSharedLabelsColors, ensureSyncedLabelsColorMap } from 'src/dashboard/actions/dashboardState';\nimport { CHART_TYPE } from 'src/dashboard/util/componentTypes';\nimport { getColorNamespace, resetColors } from 'src/utils/colorScheme';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';import { Fragment as _Fragment, jsx as _jsx } from \"@emotion/react/jsx-runtime\";\nexport const renderedChartIdsSelector = createSelector([(state) => state.charts], (charts) => Object.values(charts).\nfilter((chart) => chart.chartStatus === 'rendered').\nmap((chart) => chart.id));\nconst useRenderedChartIds = () => {\n  const renderedChartIds = useSelector(renderedChartIdsSelector);\n  return useMemo(() => renderedChartIds, [JSON.stringify(renderedChartIds)]);\n};__signature__(useRenderedChartIds, \"useSelector{renderedChartIds}\\nuseMemo{}\", () => [useSelector]);\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;});\n  return useMemo(() => nativeFilters ?\n  Object.values(nativeFilters).map((filter) => _pick(filter, ['id', 'scope', 'type'])) :\n  [], [nativeFilters]);\n};__signature__(useNativeFilterScopes, \"useSelector{nativeFilters}\\nuseMemo{}\", () => [useSelector]);\nconst TOP_OF_PAGE_RANGE = 220;\nconst DashboardContainer = ({ topLevelTabs }) => {var _dashboardInfo$metada2;\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const dashboardInfo = useSelector((state) => state.dashboardInfo);\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const chartIds = useChartIds();\n  const renderedChartIds = useRenderedChartIds();\n  const [dashboardLabelsColorInitiated, setDashboardLabelsColorInitiated] = useState(false);\n  const prevRenderedChartIds = useRef([]);\n  const prevTabIndexRef = useRef();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild\n    });\n    if (nextTabIndex === -1) {var _prevTabIndexRef$curr;\n      return (_prevTabIndexRef$curr = prevTabIndexRef.current) != null ? _prevTabIndexRef$curr : 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n  // when all charts have rendered, enforce fresh shared labels\n  const shouldForceFreshSharedLabelsColors = dashboardLabelsColorInitiated &&\n  renderedChartIds.length > 0 &&\n  chartIds.length === renderedChartIds.length &&\n  prevRenderedChartIds.current.length < renderedChartIds.length;\n  const onBeforeUnload = useCallback(() => {var _dashboardInfo$metada;\n    dispatch(persistDashboardLabelsColor());\n    resetColors(getColorNamespace(dashboardInfo == null ? void 0 : (_dashboardInfo$metada = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada.color_namespace));\n    prevRenderedChartIds.current = [];\n  }, [dashboardInfo == null ? void 0 : (_dashboardInfo$metada2 = dashboardInfo.metadata) == null ? void 0 : _dashboardInfo$metada2.color_namespace, dispatch]);\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map((filterScope) => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: []\n        };\n      }\n      const chartLayoutItems = Object.values(dashboardLayout).filter((item) => (item == null ? void 0 : item.type) === CHART_TYPE);\n      const chartsInScope = getChartIdsInFilterScope(filterScope.scope, chartIds, chartLayoutItems);\n      const tabsInScope = findTabsWithChartsInScope(chartLayoutItems, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [chartIds, JSON.stringify(nativeFilterScopes), dashboardLayout, dispatch]);\n  const childIds = useMemo(() => topLevelTabs ? topLevelTabs.children : [DASHBOARD_GRID_ID], [topLevelTabs]);\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  useEffect(() => {\n    if (shouldForceFreshSharedLabelsColors) {\n      // all available charts have rendered, enforce freshest shared label colors\n      dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata, true));\n    }\n  }, [dashboardInfo.metadata, dispatch, shouldForceFreshSharedLabelsColors]);\n  useEffect(() => {\n    // verify freshness of color map\n    // when charts render to catch new labels\n    const numRenderedCharts = renderedChartIds.length;\n    if (dashboardLabelsColorInitiated &&\n    numRenderedCharts > 0 &&\n    prevRenderedChartIds.current.length < numRenderedCharts) {\n      const newRenderedChartIds = renderedChartIds.filter((id) => !prevRenderedChartIds.current.includes(id));\n      prevRenderedChartIds.current = renderedChartIds;\n      dispatch(updateDashboardLabelsColor(newRenderedChartIds));\n      // new data may have appeared in the map (data changes)\n      // or new slices may have appeared while changing tabs\n      dispatch(ensureSyncedLabelsColorMap(dashboardInfo.metadata));\n      if (!shouldForceFreshSharedLabelsColors) {\n        dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata));\n      }\n    }\n  }, [\n  renderedChartIds,\n  dispatch,\n  dashboardLabelsColorInitiated,\n  dashboardInfo.metadata,\n  shouldForceFreshSharedLabelsColors]\n  );\n  useEffect(() => {\n    const labelsColorMap = getLabelsColorMap();\n    labelsColorMap.source = LabelsColorMapSource.Dashboard;\n    if (dashboardInfo != null && dashboardInfo.id && !dashboardLabelsColorInitiated) {\n      dispatch(applyDashboardLabelsColorOnLoad(dashboardInfo.metadata));\n      // apply labels color as dictated by stored metadata (if any)\n      setDashboardLabelsColorInitiated(true);\n    }\n    return () => {\n      onBeforeUnload();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardInfo == null ? void 0 : dashboardInfo.id, dispatch]);\n  useEffect(() => {\n    // 'beforeunload' event interferes with Cypress data cleanup process.\n    // This code prevents 'beforeunload' from triggering in Cypress tests,\n    // as it is not required for end-to-end testing scenarios.\n    if (!window.Cypress) {\n      window.addEventListener('beforeunload', onBeforeUnload);\n    }\n    return () => {\n      window.removeEventListener('beforeunload', onBeforeUnload);\n    };\n  }, [onBeforeUnload]);\n  const renderTabBar = useCallback(() => _jsx(_Fragment, {}), []);\n  const handleFocus = useCallback((e) => {\n    if (\n    // prevent scrolling when tabbing to the tab pane\n    e.target.classList.contains('ant-tabs-tabpane') &&\n    window.scrollY < TOP_OF_PAGE_RANGE) {\n      // prevent window from jumping down when tabbing\n      // if already at the top of the page\n      // to help with accessibility when using keyboard navigation\n      window.scrollTo(window.scrollX, 0);\n    }\n  }, []);\n  const renderParentSizeChildren = useCallback(({ width }) =>\n  /*\n  We use a TabContainer irrespective of whether top-level tabs exist to maintain\n  a consistent React component tree. This avoids expensive mounts/unmounts of\n  the entire dashboard upon adding/removing top-level tabs, which would otherwise\n  happen because of React's diffing algorithm\n  */\n  _jsx(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: renderTabBar, fullWidth: false, animated: false, allowOverflow: true, onFocus: handleFocus, children:\n    childIds.map((id, index) =>\n    // Matching the key of the first TabPane irrespective of topLevelTabs\n    // lets us keep the same React component tree when !!topLevelTabs changes.\n    // This avoids expensive mounts/unmounts of the entire dashboard.\n    _jsx(Tabs.TabPane, { children:\n      _jsx(DashboardGrid, { gridComponent: dashboardLayout[id]\n        // see isValidChild for why tabs do not increment the depth of their children\n        , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n        , width: width, isComponentVisible: index === tabIndex }) }, index === 0 ? DASHBOARD_GRID_ID : index.toString()\n    )) }\n  ), [activeKey, childIds, dashboardLayout, handleFocus, renderTabBar, tabIndex]);\n  return _jsx(\"div\", { className: \"grid-container\", \"data-test\": \"grid-container\", children:\n    _jsx(ParentSize, { children: renderParentSizeChildren }) }\n  );\n};__signature__(DashboardContainer, \"useNativeFilterScopes{nativeFilterScopes}\\nuseDispatch{dispatch}\\nuseSelector{dashboardLayout}\\nuseSelector{dashboardInfo}\\nuseSelector{directPathToChild}\\nuseChartIds{chartIds}\\nuseRenderedChartIds{renderedChartIds}\\nuseState{[dashboardLabelsColorInitiated, setDashboardLabelsColorInitiated](false)}\\nuseRef{prevRenderedChartIds}\\nuseRef{prevTabIndexRef}\\nuseMemo{tabIndex}\\nuseCallback{onBeforeUnload}\\nuseEffect{}\\nuseMemo{childIds}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseEffect{}\\nuseCallback{renderTabBar}\\nuseCallback{handleFocus}\\nuseCallback{renderParentSizeChildren}\", () => [useNativeFilterScopes, useDispatch, useSelector, useSelector, useSelector, useChartIds, useRenderedChartIds]);const _default = /*#__PURE__*/\nmemo(DashboardContainer);export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(renderedChartIdsSelector, \"renderedChartIdsSelector\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(useRenderedChartIds, \"useRenderedChartIds\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(useNativeFilterScopes, \"useNativeFilterScopes\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(TOP_OF_PAGE_RANGE, \"TOP_OF_PAGE_RANGE\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(DashboardContainer, \"DashboardContainer\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["memo","useCallback","useEffect","useMemo","useRef","useState","useDispatch","useSelector","createSelector","LabelsColorMapSource","getLabelsColorMap","ParentSize","Tabs","DashboardGrid","DASHBOARD_GRID_ID","DASHBOARD_ROOT_DEPTH","getChartIdsInFilterScope","findTabIndexByComponentId","setInScopeStatusOfFilters","useChartIds","applyDashboardLabelsColorOnLoad","updateDashboardLabelsColor","persistDashboardLabelsColor","ensureSyncedSharedLabelsColors","ensureSyncedLabelsColorMap","CHART_TYPE","getColorNamespace","resetColors","NATIVE_FILTER_DIVIDER_PREFIX","findTabsWithChartsInScope","getRootLevelTabsComponent","Fragment","_Fragment","jsx","_jsx","renderedChartIdsSelector","state","charts","Object","values","filter","chart","chartStatus","map","id","useRenderedChartIds","renderedChartIds","JSON","stringify","__signature__","useNativeFilterScopes","nativeFilters","_state$nativeFilters","filters","_pick","TOP_OF_PAGE_RANGE","DashboardContainer","topLevelTabs","_dashboardInfo$metada2","nativeFilterScopes","dispatch","dashboardLayout","present","dashboardInfo","directPathToChild","dashboardState","chartIds","dashboardLabelsColorInitiated","setDashboardLabelsColorInitiated","prevRenderedChartIds","prevTabIndexRef","tabIndex","nextTabIndex","currentComponent","_prevTabIndexRef$curr","current","shouldForceFreshSharedLabelsColors","length","onBeforeUnload","_dashboardInfo$metada","metadata","color_namespace","scopes","filterScope","startsWith","filterId","tabsInScope","chartsInScope","chartLayoutItems","item","type","scope","Array","from","childIds","children","min","Math","activeKey","toString","numRenderedCharts","newRenderedChartIds","includes","labelsColorMap","source","Dashboard","window","Cypress","addEventListener","removeEventListener","renderTabBar","handleFocus","e","target","classList","contains","scrollY","scrollTo","scrollX","renderParentSizeChildren","width","fullWidth","animated","allowOverflow","onFocus","index","TabPane","gridComponent","depth","isComponentVisible","className","_default","reactHotLoader","reactHotLoaderGlobal","default","undefined","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport {\n  FC,\n  memo,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { createSelector } from '@reduxjs/toolkit';\nimport {\n  Filter,\n  Filters,\n  LabelsColorMapSource,\n  getLabelsColorMap,\n} from '@superset-ui/core';\nimport { ParentSize } from '@visx/responsive';\nimport { pick } from 'lodash';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport {\n  DashboardInfo,\n  DashboardLayout,\n  LayoutItem,\n  RootState,\n} from 'src/dashboard/types';\nimport {\n  DASHBOARD_GRID_ID,\n  DASHBOARD_ROOT_DEPTH,\n} from 'src/dashboard/util/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/getChartIdsInFilterScope';\nimport findTabIndexByComponentId from 'src/dashboard/util/findTabIndexByComponentId';\nimport { setInScopeStatusOfFilters } from 'src/dashboard/actions/nativeFilters';\nimport { useChartIds } from 'src/dashboard/util/charts/useChartIds';\nimport {\n  applyDashboardLabelsColorOnLoad,\n  updateDashboardLabelsColor,\n  persistDashboardLabelsColor,\n  ensureSyncedSharedLabelsColors,\n  ensureSyncedLabelsColorMap,\n} from 'src/dashboard/actions/dashboardState';\nimport { CHART_TYPE } from 'src/dashboard/util/componentTypes';\nimport { getColorNamespace, resetColors } from 'src/utils/colorScheme';\nimport { NATIVE_FILTER_DIVIDER_PREFIX } from '../nativeFilters/FiltersConfigModal/utils';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { getRootLevelTabsComponent } from './utils';\n\ntype DashboardContainerProps = {\n  topLevelTabs?: LayoutItem;\n};\n\nexport const renderedChartIdsSelector = createSelector(\n  [(state: RootState) => state.charts],\n  charts =>\n    Object.values(charts)\n      .filter(chart => chart.chartStatus === 'rendered')\n      .map(chart => chart.id),\n);\n\nconst useRenderedChartIds = () => {\n  const renderedChartIds = useSelector<RootState, number[]>(\n    renderedChartIdsSelector,\n  );\n  return useMemo(() => renderedChartIds, [JSON.stringify(renderedChartIds)]);\n};\n\nconst useNativeFilterScopes = () => {\n  const nativeFilters = useSelector<RootState, Filters>(\n    state => state.nativeFilters?.filters,\n  );\n  return useMemo(\n    () =>\n      nativeFilters\n        ? Object.values(nativeFilters).map((filter: Filter) =>\n            pick(filter, ['id', 'scope', 'type']),\n          )\n        : [],\n    [nativeFilters],\n  );\n};\n\nconst TOP_OF_PAGE_RANGE = 220;\n\nconst DashboardContainer: FC<DashboardContainerProps> = ({ topLevelTabs }) => {\n  const nativeFilterScopes = useNativeFilterScopes();\n  const dispatch = useDispatch();\n\n  const dashboardLayout = useSelector<RootState, DashboardLayout>(\n    state => state.dashboardLayout.present,\n  );\n  const dashboardInfo = useSelector<RootState, DashboardInfo>(\n    state => state.dashboardInfo,\n  );\n  const directPathToChild = useSelector<RootState, string[]>(\n    state => state.dashboardState.directPathToChild,\n  );\n  const chartIds = useChartIds();\n\n  const renderedChartIds = useRenderedChartIds();\n\n  const [dashboardLabelsColorInitiated, setDashboardLabelsColorInitiated] =\n    useState(false);\n  const prevRenderedChartIds = useRef<number[]>([]);\n  const prevTabIndexRef = useRef<number>();\n  const tabIndex = useMemo(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild,\n    });\n\n    if (nextTabIndex === -1) {\n      return prevTabIndexRef.current ?? 0;\n    }\n    prevTabIndexRef.current = nextTabIndex;\n    return nextTabIndex;\n  }, [dashboardLayout, directPathToChild]);\n  // when all charts have rendered, enforce fresh shared labels\n  const shouldForceFreshSharedLabelsColors =\n    dashboardLabelsColorInitiated &&\n    renderedChartIds.length > 0 &&\n    chartIds.length === renderedChartIds.length &&\n    prevRenderedChartIds.current.length < renderedChartIds.length;\n\n  const onBeforeUnload = useCallback(() => {\n    dispatch(persistDashboardLabelsColor());\n    resetColors(getColorNamespace(dashboardInfo?.metadata?.color_namespace));\n    prevRenderedChartIds.current = [];\n  }, [dashboardInfo?.metadata?.color_namespace, dispatch]);\n\n  useEffect(() => {\n    if (nativeFilterScopes.length === 0) {\n      return;\n    }\n    const scopes = nativeFilterScopes.map(filterScope => {\n      if (filterScope.id.startsWith(NATIVE_FILTER_DIVIDER_PREFIX)) {\n        return {\n          filterId: filterScope.id,\n          tabsInScope: [],\n          chartsInScope: [],\n        };\n      }\n\n      const chartLayoutItems = Object.values(dashboardLayout).filter(\n        item => item?.type === CHART_TYPE,\n      );\n\n      const chartsInScope: number[] = getChartIdsInFilterScope(\n        filterScope.scope,\n        chartIds,\n        chartLayoutItems,\n      );\n\n      const tabsInScope = findTabsWithChartsInScope(\n        chartLayoutItems,\n        chartsInScope,\n      );\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope,\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [chartIds, JSON.stringify(nativeFilterScopes), dashboardLayout, dispatch]);\n\n  const childIds: string[] = useMemo(\n    () => (topLevelTabs ? topLevelTabs.children : [DASHBOARD_GRID_ID]),\n    [topLevelTabs],\n  );\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n\n  useEffect(() => {\n    if (shouldForceFreshSharedLabelsColors) {\n      // all available charts have rendered, enforce freshest shared label colors\n      dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata, true));\n    }\n  }, [dashboardInfo.metadata, dispatch, shouldForceFreshSharedLabelsColors]);\n\n  useEffect(() => {\n    // verify freshness of color map\n    // when charts render to catch new labels\n    const numRenderedCharts = renderedChartIds.length;\n\n    if (\n      dashboardLabelsColorInitiated &&\n      numRenderedCharts > 0 &&\n      prevRenderedChartIds.current.length < numRenderedCharts\n    ) {\n      const newRenderedChartIds = renderedChartIds.filter(\n        id => !prevRenderedChartIds.current.includes(id),\n      );\n      prevRenderedChartIds.current = renderedChartIds;\n      dispatch(updateDashboardLabelsColor(newRenderedChartIds));\n      // new data may have appeared in the map (data changes)\n      // or new slices may have appeared while changing tabs\n      dispatch(ensureSyncedLabelsColorMap(dashboardInfo.metadata));\n\n      if (!shouldForceFreshSharedLabelsColors) {\n        dispatch(ensureSyncedSharedLabelsColors(dashboardInfo.metadata));\n      }\n    }\n  }, [\n    renderedChartIds,\n    dispatch,\n    dashboardLabelsColorInitiated,\n    dashboardInfo.metadata,\n    shouldForceFreshSharedLabelsColors,\n  ]);\n\n  useEffect(() => {\n    const labelsColorMap = getLabelsColorMap();\n    labelsColorMap.source = LabelsColorMapSource.Dashboard;\n\n    if (dashboardInfo?.id && !dashboardLabelsColorInitiated) {\n      dispatch(applyDashboardLabelsColorOnLoad(dashboardInfo.metadata));\n      // apply labels color as dictated by stored metadata (if any)\n      setDashboardLabelsColorInitiated(true);\n    }\n\n    return () => {\n      onBeforeUnload();\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dashboardInfo?.id, dispatch]);\n\n  useEffect(() => {\n    // 'beforeunload' event interferes with Cypress data cleanup process.\n    // This code prevents 'beforeunload' from triggering in Cypress tests,\n    // as it is not required for end-to-end testing scenarios.\n    if (!(window as any).Cypress) {\n      window.addEventListener('beforeunload', onBeforeUnload);\n    }\n\n    return () => {\n      window.removeEventListener('beforeunload', onBeforeUnload);\n    };\n  }, [onBeforeUnload]);\n\n  const renderTabBar = useCallback(() => <></>, []);\n  const handleFocus = useCallback(e => {\n    if (\n      // prevent scrolling when tabbing to the tab pane\n      e.target.classList.contains('ant-tabs-tabpane') &&\n      window.scrollY < TOP_OF_PAGE_RANGE\n    ) {\n      // prevent window from jumping down when tabbing\n      // if already at the top of the page\n      // to help with accessibility when using keyboard navigation\n      window.scrollTo(window.scrollX, 0);\n    }\n  }, []);\n\n  const renderParentSizeChildren = useCallback(\n    ({ width }) => (\n      /*\n      We use a TabContainer irrespective of whether top-level tabs exist to maintain\n      a consistent React component tree. This avoids expensive mounts/unmounts of\n      the entire dashboard upon adding/removing top-level tabs, which would otherwise\n      happen because of React's diffing algorithm\n    */\n      <Tabs\n        id={DASHBOARD_GRID_ID}\n        activeKey={activeKey}\n        renderTabBar={renderTabBar}\n        fullWidth={false}\n        animated={false}\n        allowOverflow\n        onFocus={handleFocus}\n      >\n        {childIds.map((id, index) => (\n          // Matching the key of the first TabPane irrespective of topLevelTabs\n          // lets us keep the same React component tree when !!topLevelTabs changes.\n          // This avoids expensive mounts/unmounts of the entire dashboard.\n          <Tabs.TabPane\n            key={index === 0 ? DASHBOARD_GRID_ID : index.toString()}\n          >\n            <DashboardGrid\n              gridComponent={dashboardLayout[id]}\n              // see isValidChild for why tabs do not increment the depth of their children\n              depth={DASHBOARD_ROOT_DEPTH + 1} // (topLevelTabs ? 0 : 1)}\n              width={width}\n              isComponentVisible={index === tabIndex}\n            />\n          </Tabs.TabPane>\n        ))}\n      </Tabs>\n    ),\n    [activeKey, childIds, dashboardLayout, handleFocus, renderTabBar, tabIndex],\n  );\n\n  return (\n    <div className=\"grid-container\" data-test=\"grid-container\">\n      <ParentSize>{renderParentSizeChildren}</ParentSize>\n    </div>\n  );\n};\n\nexport default memo(DashboardContainer);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}