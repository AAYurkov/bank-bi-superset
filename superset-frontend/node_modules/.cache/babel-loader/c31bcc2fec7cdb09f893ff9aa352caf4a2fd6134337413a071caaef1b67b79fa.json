{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AnnotationOpacity, isTimeseriesAnnotationResult } from '@superset-ui/core';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport { EchartsTimeseriesSeriesType, ForecastSeriesEnum, LegendOrientation, OrientationType } from '../types';\nimport { evalFormula, extractRecordAnnotations, formatAnnotationLabel, parseAnnotationOpacity } from '../utils/annotation';\nimport { getChartPadding, getTimeCompareStackId } from '../utils/series';\nimport { OpacityEnum, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (series, seriesType) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value) => value != null ? value : 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta = i > 0 ?\n      getVal(series[j][i][1]) - getVal(series[j][i - 1][1]) :\n      getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n        i > 0 ?\n        getVal(series[k][i][1]) - getVal(series[k][i - 1][1]) :\n        getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else\n    {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all',\n    type: 'line',\n    lineStyle: {\n      opacity: 0\n    },\n    tooltip: {\n      show: false\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0\n    },\n    step: [\n    EchartsTimeseriesSeriesType.Start,\n    EchartsTimeseriesSeriesType.Middle,\n    EchartsTimeseriesSeriesType.End].\n    includes(seriesType) ?\n    seriesType :\n    undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth\n  };\n};\nexport function transformSeries(series, colorScale, colorScaleKey, opts) {var _opts$lineStyle;\n  const { name } = series;\n  const { area, connectNulls, filterState, seriesContexts = {}, markerEnabled, markerSize, areaOpacity = 1, seriesType, stack, stackIdSuffix, yAxisIndex = 0, showValue, onlyTotal, formatter, legendState, totalStackedValues = [], showValueIndexes = [], thresholdValues = [], richTooltip, seriesKey, sliceId, isHorizontal = false, queryIndex = 0, timeCompare = [], timeShiftColor } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast = contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n  contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n  contexts.includes(ForecastSeriesEnum.ForecastUpper);\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand = forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n  forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered = (filterState == null ? void 0 : filterState.selectedValues) && !(filterState != null && filterState.selectedValues.includes(name));\n  const opacity = isFiltered ?\n  OpacityEnum.SemiTransparent :\n  ((_opts$lineStyle = opts.lineStyle) == null ? void 0 : _opts$lineStyle.opacity) || OpacityEnum.NonTransparent;\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand)\n  return undefined;\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else\n  if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore, we need to set something that is truthy.\n    stackId = getTimeCompareStackId('obs', timeCompare, name);\n  } else\n  if (stack && isTrend) {\n    stackId = getTimeCompareStackId(forecastSeries.type, timeCompare, name);\n  }\n  if (stackId && stackIdSuffix) {\n    stackId += stackIdSuffix;\n  }\n  let plotType;\n  if (!isConfidenceBand && (\n  seriesType === 'scatter' || hasForecast && isObservation)) {\n    plotType = 'scatter';\n  } else\n  if (isConfidenceBand) {\n    plotType = 'line';\n  } else\n  {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  /**\n   * if timeShiftColor is enabled the colorScaleKey forces the color to be the\n   * same as the original series, otherwise uses separate colors\n   * */\n  const itemStyle = {\n    color: timeShiftColor ?\n    colorScale(colorScaleKey, sliceId) :\n    colorScale(seriesKey || forecastSeries.name, sliceId),\n    opacity,\n    borderWidth: 0\n  };\n  if (seriesType === 'bar' && connectNulls) {\n    itemStyle.borderWidth = 1.5;\n    itemStyle.borderType = 'dotted';\n    itemStyle.borderColor = itemStyle.color;\n  }\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else\n    if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else\n    if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1\n        }\n      };\n    } else\n    if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle = isConfidenceBand || stack === StackControlsValue.Stream && area ?\n  { ...opts.lineStyle, opacity: OpacityEnum.Transparent } :\n  { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    connectNulls,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType) ?\n    seriesType :\n    undefined,\n    stack: stackId,\n    stackStrategy: isConfidenceBand || stack === StackControlsValue.Stream ?\n    'all' :\n    'samesign',\n    lineStyle,\n    areaStyle: area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper ?\n    {\n      opacity: opacity * areaOpacity\n    } :\n    undefined,\n    emphasis,\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params) => {\n        // don't show confidence band value labels, as they're already visible on the tooltip\n        if ([\n        ForecastSeriesEnum.ForecastUpper,\n        ForecastSeriesEnum.ForecastLower].\n        includes(forecastSeries.type)) {\n          return '';\n        }\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (numericValue >= (\n          thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      }\n    }\n  };\n}\nexport function transformFormulaAnnotation(layer, data, xAxisCol, xAxisType, colorScale, sliceId, orientation) {\n  const { name, color, opacity, width, style } = layer;\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId)\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style,\n      width\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType).map(([x, y]) => isHorizontal ? [y, x] : [x, y]),\n    symbolSize: 0\n  };\n}\nexport function transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const intervalData = [\n    [\n    {\n      name: label,\n      ...(isHorizontal ? { yAxis: time } : { xAxis: time })\n    },\n    isHorizontal ? { yAxis: intervalEnd } : { xAxis: intervalEnd }]];\n\n\n    const intervalLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideTop',\n      verticalAlign: 'top',\n      fontWeight: 'bold',\n      // @ts-ignore\n      emphasis: {\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      // @ts-ignore\n      emphasis: {\n        fontWeight: 'bold',\n        show: true,\n        position: 'insideTop',\n        verticalAlign: 'top',\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8\n          }\n        },\n        label: intervalLabel,\n        data: intervalData\n      }\n    });\n  });\n  return series;\n}\nexport function transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation) {\n  const series = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach((annotation) => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const eventData = [\n    {\n      name: label,\n      ...(isHorizontal ? { yAxis: time } : { xAxis: time })\n    }];\n\n    const lineStyle = {\n      width,\n      type: style,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1\n      }\n    };\n    const eventLabel = showLabel ?\n    {\n      show: true,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      fontWeight: 'bold',\n      formatter: (params) => params.name,\n      // @ts-ignore\n      emphasis: {\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    } :\n    {\n      show: false,\n      color: theme.colors.grayscale.dark2,\n      position: 'insideEndTop',\n      // @ts-ignore\n      emphasis: {\n        formatter: (params) => params.name,\n        fontWeight: 'bold',\n        show: true,\n        backgroundColor: theme.colors.grayscale.light5\n      }\n    };\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData\n      }\n    });\n  });\n  return series;\n}\nexport function transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId, orientation) {\n  const series = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach((annotation) => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map(({ x, y }) => isHorizontal ?\n        [y, x] :\n        [x, y]),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId)\n        }\n      });\n    });\n  }\n  return series;\n}\nexport function getPadding(showLegend, legendOrientation, addYAxisTitleOffset, zoomable, margin, addXAxisTitleOffset, yAxisTitlePosition, yAxisTitleMargin, xAxisTitleMargin, isHorizontal) {\n  const yAxisOffset = addYAxisTitleOffset ?\n  TIMESERIES_CONSTANTS.yAxisLabelTopOffset :\n  0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n  return getChartPadding(showLegend, legendOrientation, margin, {\n    top: yAxisTitlePosition && yAxisTitlePosition === 'Top' ?\n    TIMESERIES_CONSTANTS.gridOffsetTop + (Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetTop + yAxisOffset,\n    bottom: zoomable && !isHorizontal ?\n    TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset :\n    TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n    left: yAxisTitlePosition === 'Left' ?\n    TIMESERIES_CONSTANTS.gridOffsetLeft + (\n    Number(yAxisTitleMargin) || 0) :\n    TIMESERIES_CONSTANTS.gridOffsetLeft,\n    right: showLegend && legendOrientation === LegendOrientation.Right ?\n    0 :\n    TIMESERIES_CONSTANTS.gridOffsetRight\n  }, isHorizontal);\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getBaselineSeriesForStream, \"getBaselineSeriesForStream\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformSeries, \"transformSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformFormulaAnnotation, \"transformFormulaAnnotation\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformIntervalAnnotation, \"transformIntervalAnnotation\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformEventAnnotation, \"transformEventAnnotation\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(transformTimeseriesAnnotation, \"transformTimeseriesAnnotation\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");reactHotLoader.register(getPadding, \"getPadding\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["AnnotationOpacity","isTimeseriesAnnotationResult","extractForecastSeriesContext","EchartsTimeseriesSeriesType","ForecastSeriesEnum","LegendOrientation","OrientationType","evalFormula","extractRecordAnnotations","formatAnnotationLabel","parseAnnotationOpacity","getChartPadding","getTimeCompareStackId","OpacityEnum","StackControlsValue","TIMESERIES_CONSTANTS","getBaselineSeriesForStream","series","seriesType","seriesLength","length","baselineSeriesDelta","Array","fill","getVal","value","i","seriesSum","weightedSeriesSum","j","delta","deltaPrev","k","baselineSeries","reduce","acc","curr","push","data","name","stack","stackStrategy","type","lineStyle","opacity","tooltip","show","silent","showSymbol","areaStyle","step","Start","Middle","End","includes","undefined","smooth","Smooth","transformSeries","colorScale","colorScaleKey","opts","_opts$lineStyle","area","connectNulls","filterState","seriesContexts","markerEnabled","markerSize","areaOpacity","stackIdSuffix","yAxisIndex","showValue","onlyTotal","formatter","legendState","totalStackedValues","showValueIndexes","thresholdValues","richTooltip","seriesKey","sliceId","isHorizontal","queryIndex","timeCompare","timeShiftColor","contexts","hasForecast","ForecastTrend","ForecastLower","ForecastUpper","forecastSeries","isConfidenceBand","isFiltered","selectedValues","SemiTransparent","NonTransparent","isObservation","Observation","isTrend","stackId","plotType","itemStyle","color","borderWidth","borderType","borderColor","emphasis","Stream","Transparent","triggerLineEvent","symbolSize","label","position","params","dataIndex","seriesIndex","seriesName","numericValue","isSelectedLegend","isAreaExpand","Expand","Number","MIN_SAFE_INTEGER","transformFormulaAnnotation","layer","xAxisCol","xAxisType","orientation","width","style","Horizontal","id","map","x","y","transformIntervalAnnotation","annotationData","theme","annotations","forEach","annotation","showLabel","descriptions","intervalEnd","time","title","intervalData","yAxis","xAxis","intervalLabel","colors","grayscale","dark2","verticalAlign","fontWeight","backgroundColor","light5","animation","markArea","Medium","transformEventAnnotation","eventData","eventLabel","markLine","symbol","transformTimeseriesAnnotation","hideLine","showMarkers","result","key","values","getPadding","showLegend","legendOrientation","addYAxisTitleOffset","zoomable","margin","addXAxisTitleOffset","yAxisTitlePosition","yAxisTitleMargin","xAxisTitleMargin","yAxisOffset","yAxisLabelTopOffset","xAxisOffset","top","gridOffsetTop","bottom","gridOffsetBottomZoomable","gridOffsetBottom","left","gridOffsetLeft","right","Right","gridOffsetRight","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformers.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AnnotationData,\n  AnnotationOpacity,\n  AxisType,\n  CategoricalColorScale,\n  EventAnnotationLayer,\n  FilterState,\n  FormulaAnnotationLayer,\n  IntervalAnnotationLayer,\n  isTimeseriesAnnotationResult,\n  LegendState,\n  SupersetTheme,\n  TimeseriesAnnotationLayer,\n  TimeseriesDataRecord,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport type {\n  CallbackDataParams,\n  DefaultStatesMixin,\n  ItemStyleOption,\n  LineStyleOption,\n  OptionName,\n  SeriesLabelOption,\n  SeriesLineLabelOption,\n  ZRLineType,\n} from 'echarts/types/src/util/types';\nimport type { SeriesOption } from 'echarts';\nimport type {\n  MarkArea1DDataItemOption,\n  MarkArea2DDataItemOption,\n} from 'echarts/types/src/component/marker/MarkAreaModel';\nimport type { MarkLine1DDataItemOption } from 'echarts/types/src/component/marker/MarkLineModel';\nimport { extractForecastSeriesContext } from '../utils/forecast';\nimport {\n  EchartsTimeseriesSeriesType,\n  ForecastSeriesEnum,\n  LegendOrientation,\n  OrientationType,\n  StackType,\n} from '../types';\n\nimport {\n  evalFormula,\n  extractRecordAnnotations,\n  formatAnnotationLabel,\n  parseAnnotationOpacity,\n} from '../utils/annotation';\nimport { getChartPadding, getTimeCompareStackId } from '../utils/series';\nimport {\n  OpacityEnum,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\n\n// based on weighted wiggle algorithm\n// source: https://ieeexplore.ieee.org/document/4658136\nexport const getBaselineSeriesForStream = (\n  series: [string | number, number][][],\n  seriesType: EchartsTimeseriesSeriesType,\n) => {\n  const seriesLength = series[0].length;\n  const baselineSeriesDelta = new Array(seriesLength).fill([0, 0]);\n  const getVal = (value: number | null) => value ?? 0;\n  for (let i = 0; i < seriesLength; i += 1) {\n    let seriesSum = 0;\n    let weightedSeriesSum = 0;\n    for (let j = 0; j < series.length; j += 1) {\n      const delta =\n        i > 0\n          ? getVal(series[j][i][1]) - getVal(series[j][i - 1][1])\n          : getVal(series[j][i][1]);\n      let deltaPrev = 0;\n      for (let k = 1; k < j - 1; k += 1) {\n        deltaPrev +=\n          i > 0\n            ? getVal(series[k][i][1]) - getVal(series[k][i - 1][1])\n            : getVal(series[k][i][1]);\n      }\n      weightedSeriesSum += (0.5 * delta + deltaPrev) * getVal(series[j][i][1]);\n      seriesSum += getVal(series[j][i][1]);\n    }\n    baselineSeriesDelta[i] = [series[0][i][0], -weightedSeriesSum / seriesSum];\n  }\n  const baselineSeries = baselineSeriesDelta.reduce((acc, curr, i) => {\n    if (i === 0) {\n      acc.push(curr);\n    } else {\n      acc.push([curr[0], acc[i - 1][1] + curr[1]]);\n    }\n    return acc;\n  }, []);\n  return {\n    data: baselineSeries,\n    name: 'baseline',\n    stack: 'obs',\n    stackStrategy: 'all' as const,\n    type: 'line' as const,\n    lineStyle: {\n      opacity: 0,\n    },\n    tooltip: {\n      show: false,\n    },\n    silent: true,\n    showSymbol: false,\n    areaStyle: {\n      opacity: 0,\n    },\n    step: [\n      EchartsTimeseriesSeriesType.Start,\n      EchartsTimeseriesSeriesType.Middle,\n      EchartsTimeseriesSeriesType.End,\n    ].includes(seriesType)\n      ? (seriesType as\n          | EchartsTimeseriesSeriesType.Start\n          | EchartsTimeseriesSeriesType.Middle\n          | EchartsTimeseriesSeriesType.End)\n      : undefined,\n    smooth: seriesType === EchartsTimeseriesSeriesType.Smooth,\n  };\n};\n\nexport function transformSeries(\n  series: SeriesOption,\n  colorScale: CategoricalColorScale,\n  colorScaleKey: string,\n  opts: {\n    area?: boolean;\n    connectNulls?: boolean;\n    filterState?: FilterState;\n    seriesContexts?: { [key: string]: ForecastSeriesEnum[] };\n    markerEnabled?: boolean;\n    markerSize?: number;\n    areaOpacity?: number;\n    seriesType?: EchartsTimeseriesSeriesType;\n    stack?: StackType;\n    stackIdSuffix?: string;\n    yAxisIndex?: number;\n    showValue?: boolean;\n    onlyTotal?: boolean;\n    legendState?: LegendState;\n    formatter?: ValueFormatter;\n    totalStackedValues?: number[];\n    showValueIndexes?: number[];\n    thresholdValues?: number[];\n    richTooltip?: boolean;\n    seriesKey?: OptionName;\n    sliceId?: number;\n    isHorizontal?: boolean;\n    lineStyle?: LineStyleOption;\n    queryIndex?: number;\n    timeCompare?: string[];\n    timeShiftColor?: boolean;\n  },\n): SeriesOption | undefined {\n  const { name } = series;\n  const {\n    area,\n    connectNulls,\n    filterState,\n    seriesContexts = {},\n    markerEnabled,\n    markerSize,\n    areaOpacity = 1,\n    seriesType,\n    stack,\n    stackIdSuffix,\n    yAxisIndex = 0,\n    showValue,\n    onlyTotal,\n    formatter,\n    legendState,\n    totalStackedValues = [],\n    showValueIndexes = [],\n    thresholdValues = [],\n    richTooltip,\n    seriesKey,\n    sliceId,\n    isHorizontal = false,\n    queryIndex = 0,\n    timeCompare = [],\n    timeShiftColor,\n  } = opts;\n  const contexts = seriesContexts[name || ''] || [];\n  const hasForecast =\n    contexts.includes(ForecastSeriesEnum.ForecastTrend) ||\n    contexts.includes(ForecastSeriesEnum.ForecastLower) ||\n    contexts.includes(ForecastSeriesEnum.ForecastUpper);\n\n  const forecastSeries = extractForecastSeriesContext(name || '');\n  const isConfidenceBand =\n    forecastSeries.type === ForecastSeriesEnum.ForecastLower ||\n    forecastSeries.type === ForecastSeriesEnum.ForecastUpper;\n  const isFiltered =\n    filterState?.selectedValues && !filterState?.selectedValues.includes(name);\n  const opacity = isFiltered\n    ? OpacityEnum.SemiTransparent\n    : opts.lineStyle?.opacity || OpacityEnum.NonTransparent;\n\n  // don't create a series if doing a stack or area chart and the result\n  // is a confidence band\n  if ((stack || area) && isConfidenceBand) return undefined;\n\n  const isObservation = forecastSeries.type === ForecastSeriesEnum.Observation;\n  const isTrend = forecastSeries.type === ForecastSeriesEnum.ForecastTrend;\n  let stackId;\n  if (isConfidenceBand) {\n    stackId = forecastSeries.name;\n  } else if (stack && isObservation) {\n    // the suffix of the observation series is '' (falsy), which disables\n    // stacking. Therefore, we need to set something that is truthy.\n    stackId = getTimeCompareStackId('obs', timeCompare, name);\n  } else if (stack && isTrend) {\n    stackId = getTimeCompareStackId(forecastSeries.type, timeCompare, name);\n  }\n  if (stackId && stackIdSuffix) {\n    stackId += stackIdSuffix;\n  }\n  let plotType;\n  if (\n    !isConfidenceBand &&\n    (seriesType === 'scatter' || (hasForecast && isObservation))\n  ) {\n    plotType = 'scatter';\n  } else if (isConfidenceBand) {\n    plotType = 'line';\n  } else {\n    plotType = seriesType === 'bar' ? 'bar' : 'line';\n  }\n  /**\n   * if timeShiftColor is enabled the colorScaleKey forces the color to be the\n   * same as the original series, otherwise uses separate colors\n   * */\n  const itemStyle: ItemStyleOption = {\n    color: timeShiftColor\n      ? colorScale(colorScaleKey, sliceId)\n      : colorScale(seriesKey || forecastSeries.name, sliceId),\n    opacity,\n    borderWidth: 0,\n  };\n  if (seriesType === 'bar' && connectNulls) {\n    itemStyle.borderWidth = 1.5;\n    itemStyle.borderType = 'dotted';\n    itemStyle.borderColor = itemStyle.color;\n  }\n  let emphasis = {};\n  let showSymbol = false;\n  if (!isConfidenceBand) {\n    if (plotType === 'scatter') {\n      showSymbol = true;\n    } else if (hasForecast && isObservation) {\n      showSymbol = true;\n    } else if (plotType === 'line' && showValue) {\n      showSymbol = true;\n    } else if (plotType === 'line' && !richTooltip && !markerEnabled) {\n      // this is hack to make timeseries line chart clickable when tooltip trigger is 'item'\n      // so that the chart can emit cross-filtering\n      showSymbol = true;\n      itemStyle.opacity = 0;\n      emphasis = {\n        itemStyle: {\n          opacity: 1,\n        },\n      };\n    } else if (markerEnabled) {\n      showSymbol = true;\n    }\n  }\n  const lineStyle =\n    isConfidenceBand || (stack === StackControlsValue.Stream && area)\n      ? { ...opts.lineStyle, opacity: OpacityEnum.Transparent }\n      : { ...opts.lineStyle, opacity };\n  return {\n    ...series,\n    connectNulls,\n    queryIndex,\n    yAxisIndex,\n    name: forecastSeries.name,\n    itemStyle,\n    // @ts-ignore\n    type: plotType,\n    smooth: seriesType === 'smooth',\n    triggerLineEvent: true,\n    // @ts-ignore\n    step: ['start', 'middle', 'end'].includes(seriesType as string)\n      ? seriesType\n      : undefined,\n    stack: stackId,\n    stackStrategy:\n      isConfidenceBand || stack === StackControlsValue.Stream\n        ? 'all'\n        : 'samesign',\n    lineStyle,\n    areaStyle:\n      area || forecastSeries.type === ForecastSeriesEnum.ForecastUpper\n        ? {\n            opacity: opacity * areaOpacity,\n          }\n        : undefined,\n    emphasis,\n    showSymbol,\n    symbolSize: markerSize,\n    label: {\n      show: !!showValue,\n      position: isHorizontal ? 'right' : 'top',\n      formatter: (params: any) => {\n        // don't show confidence band value labels, as they're already visible on the tooltip\n        if (\n          [\n            ForecastSeriesEnum.ForecastUpper,\n            ForecastSeriesEnum.ForecastLower,\n          ].includes(forecastSeries.type)\n        ) {\n          return '';\n        }\n        const { value, dataIndex, seriesIndex, seriesName } = params;\n        const numericValue = isHorizontal ? value[0] : value[1];\n        const isSelectedLegend = !legendState || legendState[seriesName];\n        const isAreaExpand = stack === StackControlsValue.Expand;\n        if (!formatter) {\n          return numericValue;\n        }\n        if (!stack && isSelectedLegend) {\n          return formatter(numericValue);\n        }\n        if (!onlyTotal) {\n          if (\n            numericValue >=\n            (thresholdValues[dataIndex] || Number.MIN_SAFE_INTEGER)\n          ) {\n            return formatter(numericValue);\n          }\n          return '';\n        }\n        if (seriesIndex === showValueIndexes[dataIndex]) {\n          return formatter(isAreaExpand ? 1 : totalStackedValues[dataIndex]);\n        }\n        return '';\n      },\n    },\n  };\n}\n\nexport function transformFormulaAnnotation(\n  layer: FormulaAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  xAxisCol: string,\n  xAxisType: AxisType,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n  orientation?: OrientationType,\n): SeriesOption {\n  const { name, color, opacity, width, style } = layer;\n  const isHorizontal = orientation === OrientationType.Horizontal;\n\n  return {\n    name,\n    id: name,\n    itemStyle: {\n      color: color || colorScale(name, sliceId),\n    },\n    lineStyle: {\n      opacity: parseAnnotationOpacity(opacity),\n      type: style as ZRLineType,\n      width,\n    },\n    type: 'line',\n    smooth: true,\n    data: evalFormula(layer, data, xAxisCol, xAxisType).map(([x, y]) =>\n      isHorizontal ? [y, x] : [x, y],\n    ),\n    symbolSize: 0,\n  };\n}\n\nexport function transformIntervalAnnotation(\n  layer: IntervalAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n  orientation?: OrientationType,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, showLabel } = layer;\n    const { descriptions, intervalEnd, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const intervalData: (\n      | MarkArea1DDataItemOption\n      | MarkArea2DDataItemOption\n    )[] = [\n      [\n        {\n          name: label,\n          ...(isHorizontal ? { yAxis: time } : { xAxis: time }),\n        },\n        isHorizontal ? { yAxis: intervalEnd } : { xAxis: intervalEnd },\n      ],\n    ];\n    const intervalLabel: SeriesLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideTop',\n          verticalAlign: 'top',\n          fontWeight: 'bold',\n          // @ts-ignore\n          emphasis: {\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          // @ts-ignore\n          emphasis: {\n            fontWeight: 'bold',\n            show: true,\n            position: 'insideTop',\n            verticalAlign: 'top',\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n    series.push({\n      id: `Interval - ${label}`,\n      type: 'line',\n      animation: false,\n      markArea: {\n        silent: false,\n        itemStyle: {\n          color: color || colorScale(name, sliceId),\n          opacity: parseAnnotationOpacity(opacity || AnnotationOpacity.Medium),\n          emphasis: {\n            opacity: 0.8,\n          },\n        } as ItemStyleOption,\n        label: intervalLabel,\n        data: intervalData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformEventAnnotation(\n  layer: EventAnnotationLayer,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  theme: SupersetTheme,\n  sliceId?: number,\n  orientation?: OrientationType,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const annotations = extractRecordAnnotations(layer, annotationData);\n  annotations.forEach(annotation => {\n    const { name, color, opacity, style, width, showLabel } = layer;\n    const { descriptions, time, title } = annotation;\n    const label = formatAnnotationLabel(name, title, descriptions);\n    const isHorizontal = orientation === OrientationType.Horizontal;\n    const eventData: MarkLine1DDataItemOption[] = [\n      {\n        name: label,\n        ...(isHorizontal ? { yAxis: time } : { xAxis: time }),\n      },\n    ];\n\n    const lineStyle: LineStyleOption & DefaultStatesMixin['emphasis'] = {\n      width,\n      type: style as ZRLineType,\n      color: color || colorScale(name, sliceId),\n      opacity: parseAnnotationOpacity(opacity),\n      emphasis: {\n        width: width ? width + 1 : width,\n        opacity: 1,\n      },\n    };\n\n    const eventLabel: SeriesLineLabelOption = showLabel\n      ? {\n          show: true,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          fontWeight: 'bold',\n          formatter: (params: CallbackDataParams) => params.name,\n          // @ts-ignore\n          emphasis: {\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        }\n      : {\n          show: false,\n          color: theme.colors.grayscale.dark2,\n          position: 'insideEndTop',\n          // @ts-ignore\n          emphasis: {\n            formatter: (params: CallbackDataParams) => params.name,\n            fontWeight: 'bold',\n            show: true,\n            backgroundColor: theme.colors.grayscale.light5,\n          },\n        };\n\n    series.push({\n      id: `Event - ${label}`,\n      type: 'line',\n      animation: false,\n      markLine: {\n        silent: false,\n        symbol: 'none',\n        lineStyle,\n        label: eventLabel,\n        data: eventData,\n      },\n    });\n  });\n  return series;\n}\n\nexport function transformTimeseriesAnnotation(\n  layer: TimeseriesAnnotationLayer,\n  markerSize: number,\n  data: TimeseriesDataRecord[],\n  annotationData: AnnotationData,\n  colorScale: CategoricalColorScale,\n  sliceId?: number,\n  orientation?: OrientationType,\n): SeriesOption[] {\n  const series: SeriesOption[] = [];\n  const { hideLine, name, opacity, showMarkers, style, width, color } = layer;\n  const result = annotationData[name];\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  if (isTimeseriesAnnotationResult(result)) {\n    result.forEach(annotation => {\n      const { key, values } = annotation;\n      series.push({\n        type: 'line',\n        id: key,\n        name: key,\n        data: values.map(({ x, y }) =>\n          isHorizontal\n            ? ([y, x] as [number, OptionName])\n            : ([x, y] as [OptionName, number]),\n        ),\n        symbolSize: showMarkers ? markerSize : 0,\n        lineStyle: {\n          opacity: parseAnnotationOpacity(opacity),\n          type: style as ZRLineType,\n          width: hideLine ? 0 : width,\n          color: color || colorScale(name, sliceId),\n        },\n      });\n    });\n  }\n  return series;\n}\n\nexport function getPadding(\n  showLegend: boolean,\n  legendOrientation: LegendOrientation,\n  addYAxisTitleOffset: boolean,\n  zoomable: boolean,\n  margin?: string | number | null,\n  addXAxisTitleOffset?: boolean,\n  yAxisTitlePosition?: string,\n  yAxisTitleMargin?: number,\n  xAxisTitleMargin?: number,\n  isHorizontal?: boolean,\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  const yAxisOffset = addYAxisTitleOffset\n    ? TIMESERIES_CONSTANTS.yAxisLabelTopOffset\n    : 0;\n  const xAxisOffset = addXAxisTitleOffset ? Number(xAxisTitleMargin) || 0 : 0;\n\n  return getChartPadding(\n    showLegend,\n    legendOrientation,\n    margin,\n    {\n      top:\n        yAxisTitlePosition && yAxisTitlePosition === 'Top'\n          ? TIMESERIES_CONSTANTS.gridOffsetTop + (Number(yAxisTitleMargin) || 0)\n          : TIMESERIES_CONSTANTS.gridOffsetTop + yAxisOffset,\n      bottom:\n        zoomable && !isHorizontal\n          ? TIMESERIES_CONSTANTS.gridOffsetBottomZoomable + xAxisOffset\n          : TIMESERIES_CONSTANTS.gridOffsetBottom + xAxisOffset,\n      left:\n        yAxisTitlePosition === 'Left'\n          ? TIMESERIES_CONSTANTS.gridOffsetLeft +\n            (Number(yAxisTitleMargin) || 0)\n          : TIMESERIES_CONSTANTS.gridOffsetLeft,\n      right:\n        showLegend && legendOrientation === LegendOrientation.Right\n          ? 0\n          : TIMESERIES_CONSTANTS.gridOffsetRight,\n    },\n    isHorizontal,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}