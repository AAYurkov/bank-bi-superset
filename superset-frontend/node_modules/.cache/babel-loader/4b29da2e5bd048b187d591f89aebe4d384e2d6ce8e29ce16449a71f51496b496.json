{"ast":null,"code":"import _invert from \"lodash/invert\"; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\nimport { AxisType, buildCustomFormatters, CategoricalColorNamespace, CurrencyFormatter, ensureIsArray, tooltipHtml, GenericDataType, getCustomFormatter, getMetricLabel, getNumberFormatter, getXAxisLabel, isDefined, isEventAnnotationLayer, isFormulaAnnotationLayer, isIntervalAnnotationLayer, isPhysicalColumn, isTimeseriesAnnotationLayer, t, NumberFormats } from '@superset-ui/core';\nimport { extractExtraMetrics, getOriginalSeries, isDerivedSeries } from '@superset-ui/chart-controls';\nimport { OrientationType } from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport { calculateLowerLogTick, dedupSeries, extractDataTotalValues, extractSeries, extractShowValueIndexes, extractTooltipKeys, getAxisType, getColtypesMapping, getLegendProps, getMinAndMaxFromBounds } from '../utils/series';\nimport { extractAnnotationLabels, getAnnotationData } from '../utils/annotation';\nimport { extractForecastSeriesContext, extractForecastSeriesContexts, extractForecastValuesFromTooltipParams, formatForecastTooltipSeries, rebaseForecastDatum, reorderForecastSeries } from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport { getBaselineSeriesForStream, getPadding, transformEventAnnotation, transformFormulaAnnotation, transformIntervalAnnotation, transformSeries, transformTimeseriesAnnotation } from './transformers';\nimport { OpacityEnum, StackControlsValue, TIMEGRAIN_TO_TIMESTAMP, TIMESERIES_CONSTANTS } from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport { getPercentFormatter, getTooltipTimeFormatter, getXAxisFormatter, getYAxisFormatter } from '../utils/formatters';\nexport default function transformProps(chartProps) {var _chartProps$rawFormDa, _dataTypes$xAxisLabel, _chartProps$rawFormDa2;\n  const { width, height, filterState, legendState, formData, hooks, queriesData, datasource, theme, inContextMenu, emitCrossFilters } = chartProps;\n  let focusedSeries = null;\n  const { verboseMap = {}, columnFormats = {}, currencyFormats = {} } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } = queryData;\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n  const { area, annotationLayers, colorScheme, contributionMode, forecastEnabled, groupby, legendOrientation, legendType, legendMargin, logAxis, markerEnabled, markerSize, metrics, minorSplitLine, minorTicks, onlyTotal, opacity, orientation, percentageThreshold, richTooltip, seriesType, showLegend, showValue, sliceId, sortSeriesType, sortSeriesAscending, timeGrainSqla, timeCompare, timeShiftColor, stack, tooltipTimeFormat, tooltipSortByMetric, showTooltipTotal, showTooltipPercentage, truncateXAxis, truncateYAxis, xAxis: xAxisOrig, xAxisBounds, xAxisForceCategorical, xAxisLabelRotation, xAxisSort, xAxisSortAsc, xAxisTimeFormat, xAxisTitle, xAxisTitleMargin, yAxisBounds, yAxisFormat, currencyFormat, yAxisTitle, yAxisTitleMargin, yAxisTitlePosition, zoomable } = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs = {};\n  const groupBy = ensureIsArray(groupby);\n  const labelMap = Object.entries(label_map).reduce((acc, entry) => {\n    if (entry[1].length > groupBy.length &&\n    Array.isArray(timeCompare) &&\n    timeCompare.includes(entry[1][0])) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData);\n  if (isPhysicalColumn((_chartProps$rawFormDa = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa.x_axis) &&\n  isDefined(verboseMap[xAxisLabel])) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(rebasedData, {\n    stack,\n    percentageThreshold,\n    xAxisCol: xAxisLabel,\n    legendState\n  });\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(getMetricLabel);\n  const isMultiSeries = groupBy.length || (metrics == null ? void 0 : metrics.length) > 1;\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(rebasedData, {\n    fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n    xAxis: xAxisLabel,\n    extraMetricLabels,\n    stack,\n    totalStackedValues,\n    isHorizontal,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries: isMultiSeries ? xAxisSort : undefined,\n    xAxisSortSeriesAscending: isMultiSeries ? xAxisSortAsc : undefined\n  });\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState\n  });\n  const seriesContexts = extractForecastSeriesContexts(rawSeries.map((series) => series.name));\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = (_dataTypes$xAxisLabel = dataTypes == null ? void 0 : dataTypes[xAxisLabel]) != null ? _dataTypes$xAxisLabel : dataTypes == null ? void 0 : dataTypes[xAxisOrig];\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series = [];\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = forcePercentFormatter ?\n  getPercentFormatter(yAxisFormat) :\n  getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const defaultFormatter = currencyFormat != null && currencyFormat.symbol ?\n  new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat }) :\n  getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(metrics, currencyFormats, columnFormats, yAxisFormat, currencyFormat);\n  const array = ensureIsArray((_chartProps$rawFormDa2 = chartProps.rawFormData) == null ? void 0 : _chartProps$rawFormDa2.time_compare);\n  const inverted = _invert(verboseMap);\n  let patternIncrement = 0;\n  rawSeries.forEach((entry) => {var _getCustomFormatter, _labelMap$seriesName;\n    const derivedSeries = isDerivedSeries(entry, chartProps.rawFormData);\n    const lineStyle = {};\n    if (derivedSeries) {\n      patternIncrement += 1;\n      // use a combination of dash and dot for the line style\n      lineStyle.type = [patternIncrement % 5 + 1, patternIncrement % 3 + 1];\n      lineStyle.opacity = OpacityEnum.DerivedSeries;\n    }\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n    const transformedSeries = transformSeries(entry, colorScale, colorScaleKey, {\n      area,\n      connectNulls: derivedSeries,\n      filterState,\n      seriesContexts,\n      markerEnabled,\n      markerSize,\n      areaOpacity: opacity,\n      seriesType,\n      legendState,\n      stack,\n      formatter: forcePercentFormatter ?\n      percentFormatter : (_getCustomFormatter =\n      getCustomFormatter(customFormatters, metrics, labelMap == null ? void 0 : (_labelMap$seriesName = labelMap[seriesName]) == null ? void 0 : _labelMap$seriesName[0])) != null ? _getCustomFormatter : defaultFormatter,\n      showValue,\n      onlyTotal,\n      totalStackedValues: sortedTotalValues,\n      showValueIndexes,\n      thresholdValues,\n      richTooltip,\n      sliceId,\n      isHorizontal,\n      lineStyle,\n      timeCompare: array,\n      timeShiftColor\n    });\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: transformedSeries.data.map((row) => {var _row$;return [row[0], (_row$ = row[1]) != null ? _row$ : 0];})\n        });\n      } else\n      {\n        series.push(transformedSeries);\n      }\n    }\n  });\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(series.map((entry) => entry.data), seriesType);\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce((acc, selectedValue) => {\n    const index = series.findIndex(({ name }) => name === selectedValue);\n    return {\n      ...acc,\n      [index]: selectedValue\n    };\n  }, {});\n  annotationLayers.\n  filter((layer) => layer.show).\n  forEach((layer) => {\n    if (isFormulaAnnotationLayer(layer))\n    series.push(transformFormulaAnnotation(layer, data, xAxisLabel, xAxisType, colorScale, sliceId, orientation));else\n    if (isIntervalAnnotationLayer(layer)) {\n      series.push(...transformIntervalAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation));\n    } else\n    if (isEventAnnotationLayer(layer)) {\n      series.push(...transformEventAnnotation(layer, data, annotationData, colorScale, theme, sliceId, orientation));\n    } else\n    if (isTimeseriesAnnotationLayer(layer)) {\n      series.push(...transformTimeseriesAnnotation(layer, markerSize, data, annotationData, colorScale, sliceId, orientation));\n    }\n  });\n  // axis bounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (yAxisMin === undefined)\n    yAxisMin = 0;\n    if (yAxisMax === undefined)\n    yAxisMax = 1;\n  } else\n  if (logAxis &&\n  yAxisMin === undefined &&\n  minPositiveValue !== undefined) {\n    yAxisMin = calculateLowerLogTick(minPositiveValue);\n  }\n  const tooltipFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getTooltipTimeFormatter(tooltipTimeFormat) :\n  String;\n  const xAxisFormatter = xAxisDataType === GenericDataType.Temporal ?\n  getXAxisFormatter(xAxisTimeFormat) :\n  String;\n  const { setDataMask = () => {}, setControlValue = () => {}, onContextMenu, onLegendStateChanged } = hooks;\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(showLegend, legendOrientation, addYAxisLabelOffset, zoomable, legendMargin, addXAxisLabelOffset, yAxisTitlePosition, convertInteger(yAxisTitleMargin), convertInteger(xAxisTitleMargin), isHorizontal);\n  const legendData = rawSeries.\n  filter((entry) => extractForecastSeriesContext(entry.name || '').type ===\n  ForecastSeriesEnum.Observation).\n  map((entry) => entry.name || '').\n  concat(extractAnnotationLabels(annotationLayers, annotationData));\n  let xAxis = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation\n    },\n    minorTick: { show: minorTicks },\n    minInterval: xAxisType === AxisType.Time && timeGrainSqla ?\n    TIMEGRAIN_TO_TIMESTAMP[timeGrainSqla] :\n    0,\n    ...getMinAndMaxFromBounds(xAxisType, truncateXAxis, xAxisMin, xAxisMax, seriesType)\n  };\n  let yAxis = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.Log : AxisType.Value,\n    min: yAxisMin,\n    max: yAxisMax,\n    minorTick: { show: minorTicks },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(metrics, forcePercentFormatter, customFormatters, defaultFormatter, yAxisFormat)\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end'\n  };\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n  }\n  const echartOptions = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params) => {var _getCustomFormatter2;\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue = richTooltip ?\n        params[0].value[xIndex] :\n        params.value[xIndex];\n        const forecastValue = richTooltip ? params : [params];\n        const sortedKeys = extractTooltipKeys(forecastValue, yIndex, richTooltip, tooltipSortByMetric);\n        const forecastValues = extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n        const isForecast = Object.values(forecastValues).some((value) => value.forecastTrend || value.forecastLower || value.forecastUpper);\n        const formatter = forcePercentFormatter ?\n        percentFormatter : (_getCustomFormatter2 =\n        getCustomFormatter(customFormatters, metrics)) != null ? _getCustomFormatter2 : defaultFormatter;\n        const rows = [];\n        const total = Object.values(forecastValues).reduce((acc, value) => value.observation !== undefined ? acc + value.observation : acc, 0);\n        const allowTotal = Boolean(isMultiSeries) && richTooltip && !isForecast;\n        const showPercentage = allowTotal && !forcePercentFormatter && showTooltipPercentage;\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys.\n        filter((key) => keys.includes(key)).\n        forEach((key) => {\n          const value = forecastValues[key];\n          if (value.observation === 0 && stack) {\n            return;\n          }\n          const row = formatForecastTooltipSeries({\n            ...value,\n            seriesName: key,\n            formatter\n          });\n          if (showPercentage && value.observation !== undefined) {\n            row.push(percentFormatter.format(value.observation / (total || 1)));\n          }\n          rows.push(row);\n          if (key === focusedSeries) {\n            focusedRow = rows.length - 1;\n          }\n        });\n        if (stack) {\n          rows.reverse();\n          if (focusedRow !== undefined) {\n            focusedRow = rows.length - focusedRow - 1;\n          }\n        }\n        if (allowTotal && showTooltipTotal) {\n          const totalRow = ['Total', formatter.format(total)];\n          if (showPercentage) {\n            totalRow.push(percentFormatter.format(1));\n          }\n          rows.push(totalRow);\n        }\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      }\n    },\n    legend: {\n      ...getLegendProps(legendType, legendOrientation, showLegend, theme, zoomable, legendState, padding),\n      data: legendData\n    },\n    series: dedupSeries(reorderForecastSeries(series)),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          ...(stack ? { yAxisIndex: false } : {}),\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom')\n          }\n        }\n      }\n    },\n    dataZoom: zoomable ?\n    [\n    {\n      type: 'slider',\n      start: TIMESERIES_CONSTANTS.dataZoomStart,\n      end: TIMESERIES_CONSTANTS.dataZoomEnd,\n      bottom: TIMESERIES_CONSTANTS.zoomBottom,\n      yAxisIndex: isHorizontal ? 0 : undefined\n    },\n    {\n      type: 'inside',\n      yAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    },\n    {\n      type: 'inside',\n      xAxisIndex: 0,\n      zoomOnMouseWheel: false,\n      moveOnMouseWheel: true\n    }] :\n\n    []\n  };\n  const onFocusedSeries = (seriesName) => {\n    focusedSeries = seriesName;\n  };\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby: groupBy,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType\n    },\n    refs,\n    coltypeMapping: dataTypes\n  };\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(transformProps, \"transformProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","AxisType","buildCustomFormatters","CategoricalColorNamespace","CurrencyFormatter","ensureIsArray","tooltipHtml","GenericDataType","getCustomFormatter","getMetricLabel","getNumberFormatter","getXAxisLabel","isDefined","isEventAnnotationLayer","isFormulaAnnotationLayer","isIntervalAnnotationLayer","isPhysicalColumn","isTimeseriesAnnotationLayer","t","NumberFormats","extractExtraMetrics","getOriginalSeries","isDerivedSeries","OrientationType","DEFAULT_FORM_DATA","ForecastSeriesEnum","parseAxisBound","calculateLowerLogTick","dedupSeries","extractDataTotalValues","extractSeries","extractShowValueIndexes","extractTooltipKeys","getAxisType","getColtypesMapping","getLegendProps","getMinAndMaxFromBounds","extractAnnotationLabels","getAnnotationData","extractForecastSeriesContext","extractForecastSeriesContexts","extractForecastValuesFromTooltipParams","formatForecastTooltipSeries","rebaseForecastDatum","reorderForecastSeries","convertInteger","defaultGrid","defaultYAxis","getBaselineSeriesForStream","getPadding","transformEventAnnotation","transformFormulaAnnotation","transformIntervalAnnotation","transformSeries","transformTimeseriesAnnotation","OpacityEnum","StackControlsValue","TIMEGRAIN_TO_TIMESTAMP","TIMESERIES_CONSTANTS","getDefaultTooltip","getPercentFormatter","getTooltipTimeFormatter","getXAxisFormatter","getYAxisFormatter","transformProps","chartProps","_chartProps$rawFormDa","_dataTypes$xAxisLabel","_chartProps$rawFormDa2","width","height","filterState","legendState","formData","hooks","queriesData","datasource","theme","inContextMenu","emitCrossFilters","focusedSeries","verboseMap","columnFormats","currencyFormats","queryData","data","label_map","dataTypes","annotationData","area","annotationLayers","colorScheme","contributionMode","forecastEnabled","groupby","legendOrientation","legendType","legendMargin","logAxis","markerEnabled","markerSize","metrics","minorSplitLine","minorTicks","onlyTotal","opacity","orientation","percentageThreshold","richTooltip","seriesType","showLegend","showValue","sliceId","sortSeriesType","sortSeriesAscending","timeGrainSqla","timeCompare","timeShiftColor","stack","tooltipTimeFormat","tooltipSortByMetric","showTooltipTotal","showTooltipPercentage","truncateXAxis","truncateYAxis","xAxis","xAxisOrig","xAxisBounds","xAxisForceCategorical","xAxisLabelRotation","xAxisSort","xAxisSortAsc","xAxisTimeFormat","xAxisTitle","xAxisTitleMargin","yAxisBounds","yAxisFormat","currencyFormat","yAxisTitle","yAxisTitleMargin","yAxisTitlePosition","zoomable","refs","groupBy","labelMap","Object","entries","reduce","acc","entry","length","Array","isArray","includes","shift","colorScale","getScale","rebasedData","xAxisLabel","rawFormData","x_axis","isHorizontal","Horizontal","totalStackedValues","thresholdValues","xAxisCol","extraMetricLabels","map","isMultiSeries","rawSeries","sortedTotalValues","minPositiveValue","fillNeighborValue","xAxisSortSeries","xAxisSortSeriesAscending","showValueIndexes","seriesContexts","series","name","isAreaExpand","Expand","xAxisDataType","xAxisType","forcePercentFormatter","Boolean","percentFormatter","PERCENT_2_POINT","defaultFormatter","symbol","d3Format","currency","customFormatters","array","time_compare","inverted","_invert","patternIncrement","forEach","_getCustomFormatter","_labelMap$seriesName","derivedSeries","lineStyle","type","DerivedSeries","entryName","String","seriesName","colorScaleKey","transformedSeries","connectNulls","areaOpacity","formatter","Stream","push","row","_row$","baselineSeries","unshift","selectedValues","selectedValue","index","findIndex","filter","layer","show","xAxisMin","xAxisMax","yAxisMin","yAxisMax","tooltipFormatter","Temporal","xAxisFormatter","setDataMask","setControlValue","onContextMenu","onLegendStateChanged","addYAxisLabelOffset","addXAxisLabelOffset","padding","legendData","Observation","concat","nameGap","nameLocation","axisLabel","hideOverlap","rotate","minorTick","minInterval","Time","yAxis","Log","Value","min","max","scale","bottom","left","echartOptions","useUTC","grid","tooltip","trigger","params","_getCustomFormatter2","xIndex","yIndex","xValue","value","forecastValue","sortedKeys","forecastValues","isForecast","values","some","forecastTrend","forecastLower","forecastUpper","rows","total","observation","allowTotal","showPercentage","keys","focusedRow","key","format","reverse","totalRow","legend","toolbox","top","toolboxTop","right","toolboxRight","feature","dataZoom","yAxisIndex","title","zoom","back","start","dataZoomStart","end","dataZoomEnd","zoomBottom","zoomOnMouseWheel","moveOnMouseWheel","xAxisIndex","onFocusedSeries","xValueFormatter","label","coltypeMapping","reactHotLoader","register","leaveModule"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/Timeseries/transformProps.ts"],"sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { invert } from 'lodash';\nimport {\n  AnnotationLayer,\n  AxisType,\n  buildCustomFormatters,\n  CategoricalColorNamespace,\n  CurrencyFormatter,\n  ensureIsArray,\n  tooltipHtml,\n  GenericDataType,\n  getCustomFormatter,\n  getMetricLabel,\n  getNumberFormatter,\n  getXAxisLabel,\n  isDefined,\n  isEventAnnotationLayer,\n  isFormulaAnnotationLayer,\n  isIntervalAnnotationLayer,\n  isPhysicalColumn,\n  isTimeseriesAnnotationLayer,\n  t,\n  TimeseriesChartDataResponseResult,\n  NumberFormats,\n} from '@superset-ui/core';\nimport {\n  extractExtraMetrics,\n  getOriginalSeries,\n  isDerivedSeries,\n} from '@superset-ui/chart-controls';\nimport type { EChartsCoreOption } from 'echarts/core';\nimport type { LineStyleOption } from 'echarts/types/src/util/types';\nimport type { SeriesOption } from 'echarts';\nimport {\n  EchartsTimeseriesChartProps,\n  EchartsTimeseriesFormData,\n  OrientationType,\n  TimeseriesChartTransformedProps,\n} from './types';\nimport { DEFAULT_FORM_DATA } from './constants';\nimport { ForecastSeriesEnum, ForecastValue, Refs } from '../types';\nimport { parseAxisBound } from '../utils/controls';\nimport {\n  calculateLowerLogTick,\n  dedupSeries,\n  extractDataTotalValues,\n  extractSeries,\n  extractShowValueIndexes,\n  extractTooltipKeys,\n  getAxisType,\n  getColtypesMapping,\n  getLegendProps,\n  getMinAndMaxFromBounds,\n} from '../utils/series';\nimport {\n  extractAnnotationLabels,\n  getAnnotationData,\n} from '../utils/annotation';\nimport {\n  extractForecastSeriesContext,\n  extractForecastSeriesContexts,\n  extractForecastValuesFromTooltipParams,\n  formatForecastTooltipSeries,\n  rebaseForecastDatum,\n  reorderForecastSeries,\n} from '../utils/forecast';\nimport { convertInteger } from '../utils/convertInteger';\nimport { defaultGrid, defaultYAxis } from '../defaults';\nimport {\n  getBaselineSeriesForStream,\n  getPadding,\n  transformEventAnnotation,\n  transformFormulaAnnotation,\n  transformIntervalAnnotation,\n  transformSeries,\n  transformTimeseriesAnnotation,\n} from './transformers';\nimport {\n  OpacityEnum,\n  StackControlsValue,\n  TIMEGRAIN_TO_TIMESTAMP,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport { getDefaultTooltip } from '../utils/tooltip';\nimport {\n  getPercentFormatter,\n  getTooltipTimeFormatter,\n  getXAxisFormatter,\n  getYAxisFormatter,\n} from '../utils/formatters';\n\nexport default function transformProps(\n  chartProps: EchartsTimeseriesChartProps,\n): TimeseriesChartTransformedProps {\n  const {\n    width,\n    height,\n    filterState,\n    legendState,\n    formData,\n    hooks,\n    queriesData,\n    datasource,\n    theme,\n    inContextMenu,\n    emitCrossFilters,\n  } = chartProps;\n\n  let focusedSeries: string | null = null;\n\n  const {\n    verboseMap = {},\n    columnFormats = {},\n    currencyFormats = {},\n  } = datasource;\n  const [queryData] = queriesData;\n  const { data = [], label_map = {} } =\n    queryData as TimeseriesChartDataResponseResult;\n\n  const dataTypes = getColtypesMapping(queryData);\n  const annotationData = getAnnotationData(chartProps);\n\n  const {\n    area,\n    annotationLayers,\n    colorScheme,\n    contributionMode,\n    forecastEnabled,\n    groupby,\n    legendOrientation,\n    legendType,\n    legendMargin,\n    logAxis,\n    markerEnabled,\n    markerSize,\n    metrics,\n    minorSplitLine,\n    minorTicks,\n    onlyTotal,\n    opacity,\n    orientation,\n    percentageThreshold,\n    richTooltip,\n    seriesType,\n    showLegend,\n    showValue,\n    sliceId,\n    sortSeriesType,\n    sortSeriesAscending,\n    timeGrainSqla,\n    timeCompare,\n    timeShiftColor,\n    stack,\n    tooltipTimeFormat,\n    tooltipSortByMetric,\n    showTooltipTotal,\n    showTooltipPercentage,\n    truncateXAxis,\n    truncateYAxis,\n    xAxis: xAxisOrig,\n    xAxisBounds,\n    xAxisForceCategorical,\n    xAxisLabelRotation,\n    xAxisSort,\n    xAxisSortAsc,\n    xAxisTimeFormat,\n    xAxisTitle,\n    xAxisTitleMargin,\n    yAxisBounds,\n    yAxisFormat,\n    currencyFormat,\n    yAxisTitle,\n    yAxisTitleMargin,\n    yAxisTitlePosition,\n    zoomable,\n  }: EchartsTimeseriesFormData = { ...DEFAULT_FORM_DATA, ...formData };\n  const refs: Refs = {};\n  const groupBy = ensureIsArray(groupby);\n  const labelMap: { [key: string]: string[] } = Object.entries(\n    label_map,\n  ).reduce((acc, entry) => {\n    if (\n      entry[1].length > groupBy.length &&\n      Array.isArray(timeCompare) &&\n      timeCompare.includes(entry[1][0])\n    ) {\n      entry[1].shift();\n    }\n    return { ...acc, [entry[0]]: entry[1] };\n  }, {});\n  const colorScale = CategoricalColorNamespace.getScale(colorScheme as string);\n  const rebasedData = rebaseForecastDatum(data, verboseMap);\n  let xAxisLabel = getXAxisLabel(chartProps.rawFormData) as string;\n  if (\n    isPhysicalColumn(chartProps.rawFormData?.x_axis) &&\n    isDefined(verboseMap[xAxisLabel])\n  ) {\n    xAxisLabel = verboseMap[xAxisLabel];\n  }\n  const isHorizontal = orientation === OrientationType.Horizontal;\n  const { totalStackedValues, thresholdValues } = extractDataTotalValues(\n    rebasedData,\n    {\n      stack,\n      percentageThreshold,\n      xAxisCol: xAxisLabel,\n      legendState,\n    },\n  );\n  const extraMetricLabels = extractExtraMetrics(chartProps.rawFormData).map(\n    getMetricLabel,\n  );\n\n  const isMultiSeries = groupBy.length || metrics?.length > 1;\n\n  const [rawSeries, sortedTotalValues, minPositiveValue] = extractSeries(\n    rebasedData,\n    {\n      fillNeighborValue: stack && !forecastEnabled ? 0 : undefined,\n      xAxis: xAxisLabel,\n      extraMetricLabels,\n      stack,\n      totalStackedValues,\n      isHorizontal,\n      sortSeriesType,\n      sortSeriesAscending,\n      xAxisSortSeries: isMultiSeries ? xAxisSort : undefined,\n      xAxisSortSeriesAscending: isMultiSeries ? xAxisSortAsc : undefined,\n    },\n  );\n  const showValueIndexes = extractShowValueIndexes(rawSeries, {\n    stack,\n    onlyTotal,\n    isHorizontal,\n    legendState,\n  });\n  const seriesContexts = extractForecastSeriesContexts(\n    rawSeries.map(series => series.name as string),\n  );\n  const isAreaExpand = stack === StackControlsValue.Expand;\n  const xAxisDataType = dataTypes?.[xAxisLabel] ?? dataTypes?.[xAxisOrig];\n\n  const xAxisType = getAxisType(stack, xAxisForceCategorical, xAxisDataType);\n  const series: SeriesOption[] = [];\n\n  const forcePercentFormatter = Boolean(contributionMode || isAreaExpand);\n  const percentFormatter = forcePercentFormatter\n    ? getPercentFormatter(yAxisFormat)\n    : getPercentFormatter(NumberFormats.PERCENT_2_POINT);\n  const defaultFormatter = currencyFormat?.symbol\n    ? new CurrencyFormatter({ d3Format: yAxisFormat, currency: currencyFormat })\n    : getNumberFormatter(yAxisFormat);\n  const customFormatters = buildCustomFormatters(\n    metrics,\n    currencyFormats,\n    columnFormats,\n    yAxisFormat,\n    currencyFormat,\n  );\n\n  const array = ensureIsArray(chartProps.rawFormData?.time_compare);\n  const inverted = invert(verboseMap);\n\n  let patternIncrement = 0;\n\n  rawSeries.forEach(entry => {\n    const derivedSeries = isDerivedSeries(entry, chartProps.rawFormData);\n    const lineStyle: LineStyleOption = {};\n    if (derivedSeries) {\n      patternIncrement += 1;\n      // use a combination of dash and dot for the line style\n      lineStyle.type = [(patternIncrement % 5) + 1, (patternIncrement % 3) + 1];\n      lineStyle.opacity = OpacityEnum.DerivedSeries;\n    }\n\n    const entryName = String(entry.name || '');\n    const seriesName = inverted[entryName] || entryName;\n    const colorScaleKey = getOriginalSeries(seriesName, array);\n\n    const transformedSeries = transformSeries(\n      entry,\n      colorScale,\n      colorScaleKey,\n      {\n        area,\n        connectNulls: derivedSeries,\n        filterState,\n        seriesContexts,\n        markerEnabled,\n        markerSize,\n        areaOpacity: opacity,\n        seriesType,\n        legendState,\n        stack,\n        formatter: forcePercentFormatter\n          ? percentFormatter\n          : (getCustomFormatter(\n              customFormatters,\n              metrics,\n              labelMap?.[seriesName]?.[0],\n            ) ?? defaultFormatter),\n        showValue,\n        onlyTotal,\n        totalStackedValues: sortedTotalValues,\n        showValueIndexes,\n        thresholdValues,\n        richTooltip,\n        sliceId,\n        isHorizontal,\n        lineStyle,\n        timeCompare: array,\n        timeShiftColor,\n      },\n    );\n    if (transformedSeries) {\n      if (stack === StackControlsValue.Stream) {\n        // bug in Echarts - `stackStrategy: 'all'` doesn't work with nulls, so we cast them to 0\n        series.push({\n          ...transformedSeries,\n          data: (transformedSeries.data as any).map(\n            (row: [string | number, number]) => [row[0], row[1] ?? 0],\n          ),\n        });\n      } else {\n        series.push(transformedSeries);\n      }\n    }\n  });\n\n  if (stack === StackControlsValue.Stream) {\n    const baselineSeries = getBaselineSeriesForStream(\n      series.map(entry => entry.data) as [string | number, number][][],\n      seriesType,\n    );\n\n    series.unshift(baselineSeries);\n  }\n  const selectedValues = (filterState.selectedValues || []).reduce(\n    (acc: Record<string, number>, selectedValue: string) => {\n      const index = series.findIndex(({ name }) => name === selectedValue);\n      return {\n        ...acc,\n        [index]: selectedValue,\n      };\n    },\n    {},\n  );\n\n  annotationLayers\n    .filter((layer: AnnotationLayer) => layer.show)\n    .forEach((layer: AnnotationLayer) => {\n      if (isFormulaAnnotationLayer(layer))\n        series.push(\n          transformFormulaAnnotation(\n            layer,\n            data,\n            xAxisLabel,\n            xAxisType,\n            colorScale,\n            sliceId,\n            orientation,\n          ),\n        );\n      else if (isIntervalAnnotationLayer(layer)) {\n        series.push(\n          ...transformIntervalAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n            orientation,\n          ),\n        );\n      } else if (isEventAnnotationLayer(layer)) {\n        series.push(\n          ...transformEventAnnotation(\n            layer,\n            data,\n            annotationData,\n            colorScale,\n            theme,\n            sliceId,\n            orientation,\n          ),\n        );\n      } else if (isTimeseriesAnnotationLayer(layer)) {\n        series.push(\n          ...transformTimeseriesAnnotation(\n            layer,\n            markerSize,\n            data,\n            annotationData,\n            colorScale,\n            sliceId,\n            orientation,\n          ),\n        );\n      }\n    });\n\n  // axis bounds need to be parsed to replace incompatible values with undefined\n  const [xAxisMin, xAxisMax] = (xAxisBounds || []).map(parseAxisBound);\n  let [yAxisMin, yAxisMax] = (yAxisBounds || []).map(parseAxisBound);\n\n  // default to 0-100% range when doing row-level contribution chart\n  if ((contributionMode === 'row' || isAreaExpand) && stack) {\n    if (yAxisMin === undefined) yAxisMin = 0;\n    if (yAxisMax === undefined) yAxisMax = 1;\n  } else if (\n    logAxis &&\n    yAxisMin === undefined &&\n    minPositiveValue !== undefined\n  ) {\n    yAxisMin = calculateLowerLogTick(minPositiveValue);\n  }\n\n  const tooltipFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getTooltipTimeFormatter(tooltipTimeFormat)\n      : String;\n  const xAxisFormatter =\n    xAxisDataType === GenericDataType.Temporal\n      ? getXAxisFormatter(xAxisTimeFormat)\n      : String;\n\n  const {\n    setDataMask = () => {},\n    setControlValue = () => {},\n    onContextMenu,\n    onLegendStateChanged,\n  } = hooks;\n\n  const addYAxisLabelOffset = !!yAxisTitle;\n  const addXAxisLabelOffset = !!xAxisTitle;\n  const padding = getPadding(\n    showLegend,\n    legendOrientation,\n    addYAxisLabelOffset,\n    zoomable,\n    legendMargin,\n    addXAxisLabelOffset,\n    yAxisTitlePosition,\n    convertInteger(yAxisTitleMargin),\n    convertInteger(xAxisTitleMargin),\n    isHorizontal,\n  );\n\n  const legendData = rawSeries\n    .filter(\n      entry =>\n        extractForecastSeriesContext(entry.name || '').type ===\n        ForecastSeriesEnum.Observation,\n    )\n    .map(entry => entry.name || '')\n    .concat(extractAnnotationLabels(annotationLayers, annotationData));\n\n  let xAxis: any = {\n    type: xAxisType,\n    name: xAxisTitle,\n    nameGap: convertInteger(xAxisTitleMargin),\n    nameLocation: 'middle',\n    axisLabel: {\n      hideOverlap: true,\n      formatter: xAxisFormatter,\n      rotate: xAxisLabelRotation,\n    },\n    minorTick: { show: minorTicks },\n    minInterval:\n      xAxisType === AxisType.Time && timeGrainSqla\n        ? TIMEGRAIN_TO_TIMESTAMP[\n            timeGrainSqla as keyof typeof TIMEGRAIN_TO_TIMESTAMP\n          ]\n        : 0,\n    ...getMinAndMaxFromBounds(\n      xAxisType,\n      truncateXAxis,\n      xAxisMin,\n      xAxisMax,\n      seriesType,\n    ),\n  };\n\n  let yAxis: any = {\n    ...defaultYAxis,\n    type: logAxis ? AxisType.Log : AxisType.Value,\n    min: yAxisMin,\n    max: yAxisMax,\n    minorTick: { show: minorTicks },\n    minorSplitLine: { show: minorSplitLine },\n    axisLabel: {\n      formatter: getYAxisFormatter(\n        metrics,\n        forcePercentFormatter,\n        customFormatters,\n        defaultFormatter,\n        yAxisFormat,\n      ),\n    },\n    scale: truncateYAxis,\n    name: yAxisTitle,\n    nameGap: convertInteger(yAxisTitleMargin),\n    nameLocation: yAxisTitlePosition === 'Left' ? 'middle' : 'end',\n  };\n\n  if (isHorizontal) {\n    [xAxis, yAxis] = [yAxis, xAxis];\n    [padding.bottom, padding.left] = [padding.left, padding.bottom];\n  }\n\n  const echartOptions: EChartsCoreOption = {\n    useUTC: true,\n    grid: {\n      ...defaultGrid,\n      ...padding,\n    },\n    xAxis,\n    yAxis,\n    tooltip: {\n      ...getDefaultTooltip(refs),\n      show: !inContextMenu,\n      trigger: richTooltip ? 'axis' : 'item',\n      formatter: (params: any) => {\n        const [xIndex, yIndex] = isHorizontal ? [1, 0] : [0, 1];\n        const xValue: number = richTooltip\n          ? params[0].value[xIndex]\n          : params.value[xIndex];\n        const forecastValue: any[] = richTooltip ? params : [params];\n        const sortedKeys = extractTooltipKeys(\n          forecastValue,\n          yIndex,\n          richTooltip,\n          tooltipSortByMetric,\n        );\n        const forecastValues: Record<string, ForecastValue> =\n          extractForecastValuesFromTooltipParams(forecastValue, isHorizontal);\n\n        const isForecast = Object.values(forecastValues).some(\n          value =>\n            value.forecastTrend || value.forecastLower || value.forecastUpper,\n        );\n\n        const formatter = forcePercentFormatter\n          ? percentFormatter\n          : (getCustomFormatter(customFormatters, metrics) ?? defaultFormatter);\n\n        const rows: string[][] = [];\n        const total = Object.values(forecastValues).reduce(\n          (acc, value) =>\n            value.observation !== undefined ? acc + value.observation : acc,\n          0,\n        );\n        const allowTotal = Boolean(isMultiSeries) && richTooltip && !isForecast;\n        const showPercentage =\n          allowTotal && !forcePercentFormatter && showTooltipPercentage;\n        const keys = Object.keys(forecastValues);\n        let focusedRow;\n        sortedKeys\n          .filter(key => keys.includes(key))\n          .forEach(key => {\n            const value = forecastValues[key];\n            if (value.observation === 0 && stack) {\n              return;\n            }\n            const row = formatForecastTooltipSeries({\n              ...value,\n              seriesName: key,\n              formatter,\n            });\n            if (showPercentage && value.observation !== undefined) {\n              row.push(\n                percentFormatter.format(value.observation / (total || 1)),\n              );\n            }\n            rows.push(row);\n            if (key === focusedSeries) {\n              focusedRow = rows.length - 1;\n            }\n          });\n        if (stack) {\n          rows.reverse();\n          if (focusedRow !== undefined) {\n            focusedRow = rows.length - focusedRow - 1;\n          }\n        }\n        if (allowTotal && showTooltipTotal) {\n          const totalRow = ['Total', formatter.format(total)];\n          if (showPercentage) {\n            totalRow.push(percentFormatter.format(1));\n          }\n          rows.push(totalRow);\n        }\n        return tooltipHtml(rows, tooltipFormatter(xValue), focusedRow);\n      },\n    },\n    legend: {\n      ...getLegendProps(\n        legendType,\n        legendOrientation,\n        showLegend,\n        theme,\n        zoomable,\n        legendState,\n        padding,\n      ),\n      data: legendData as string[],\n    },\n    series: dedupSeries(reorderForecastSeries(series) as SeriesOption[]),\n    toolbox: {\n      show: zoomable,\n      top: TIMESERIES_CONSTANTS.toolboxTop,\n      right: TIMESERIES_CONSTANTS.toolboxRight,\n      feature: {\n        dataZoom: {\n          ...(stack ? { yAxisIndex: false } : {}), // disable y-axis zoom for stacked charts\n          title: {\n            zoom: t('zoom area'),\n            back: t('restore zoom'),\n          },\n        },\n      },\n    },\n    dataZoom: zoomable\n      ? [\n          {\n            type: 'slider',\n            start: TIMESERIES_CONSTANTS.dataZoomStart,\n            end: TIMESERIES_CONSTANTS.dataZoomEnd,\n            bottom: TIMESERIES_CONSTANTS.zoomBottom,\n            yAxisIndex: isHorizontal ? 0 : undefined,\n          },\n          {\n            type: 'inside',\n            yAxisIndex: 0,\n            zoomOnMouseWheel: false,\n            moveOnMouseWheel: true,\n          },\n          {\n            type: 'inside',\n            xAxisIndex: 0,\n            zoomOnMouseWheel: false,\n            moveOnMouseWheel: true,\n          },\n        ]\n      : [],\n  };\n\n  const onFocusedSeries = (seriesName: string | null) => {\n    focusedSeries = seriesName;\n  };\n\n  return {\n    echartOptions,\n    emitCrossFilters,\n    formData,\n    groupby: groupBy,\n    height,\n    labelMap,\n    selectedValues,\n    setDataMask,\n    setControlValue,\n    width,\n    legendData,\n    onContextMenu,\n    onLegendStateChanged,\n    onFocusedSeries,\n    xValueFormatter: tooltipFormatter,\n    xAxis: {\n      label: xAxisLabel,\n      type: xAxisType,\n    },\n    refs,\n    coltypeMapping: dataTypes,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}