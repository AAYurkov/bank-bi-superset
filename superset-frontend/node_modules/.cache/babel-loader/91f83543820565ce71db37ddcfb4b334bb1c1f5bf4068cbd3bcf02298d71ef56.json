{"ast":null,"code":"import _sumBy from \"lodash/sumBy\";import _orderBy from \"lodash/orderBy\";import _minBy from \"lodash/minBy\";import _meanBy from \"lodash/meanBy\";import _maxBy from \"lodash/maxBy\";import _isEmpty from \"lodash/isEmpty\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { AxisType, DTTM_ALIAS, ensureIsArray, GenericDataType, normalizeTimestamp, NumberFormats, NumberFormatter } from '@superset-ui/core';\nimport { SortSeriesType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts/core';\n\nimport { NULL_STRING, StackControlsValue, TIMESERIES_CONSTANTS } from '../constants';\nimport { EchartsTimeseriesSeriesType, LegendOrientation } from '../types';\nimport { defaultLegendPadding } from '../defaults';\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nexport function extractDataTotalValues(data, opts) {\n  const totalStackedValues = [];\n  const thresholdValues = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach((datum) => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + value;\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push((percentageThreshold || 0) / 100 * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues\n  };\n}\nexport function extractShowValueIndexes(series, opts) {\n  const showValueIndexes = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      data.forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (!showValueIndexes[dataIndex] &&\n          datum[isHorizontal ? 0 : 1] !== null) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\nexport function sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending) {\n  const seriesNames = Object.keys(rows[0]).\n  filter((key) => key !== xAxis).\n  filter((key) => !extraMetricLabels.includes(key));\n  let aggregator;\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = (name) => ({ name, value: _sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = (name) => {var _minBy2;return { name, value: (_minBy2 = _minBy(rows, name)) == null ? void 0 : _minBy2[name] };};\n      break;\n    case SortSeriesType.Max:\n      aggregator = (name) => {var _maxBy2;return { name, value: (_maxBy2 = _maxBy(rows, name)) == null ? void 0 : _maxBy2[name] };};\n      break;\n    case SortSeriesType.Avg:\n      aggregator = (name) => ({ name, value: _meanBy(rows, name) });\n      break;\n    default:{\n        const collator = new Intl.Collator(undefined, {\n          numeric: true,\n          sensitivity: 'base'\n        });\n        return seriesNames.sort((a, b) => sortSeriesAscending ? collator.compare(a, b) : collator.compare(b, a));\n      }\n  }\n  const sortedValues = seriesNames.map(aggregator);\n  return _orderBy(sortedValues, ['value'], [sortSeriesAscending ? 'asc' : 'desc']).map(({ name }) => name);\n}\nexport function sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey = '';\n    let aggregate;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (xAxisSortSeries === SortSeriesType.Name ||\n      typeof value !== 'number') {\n        return;\n      }\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else\n          {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n          aggregate === undefined || isValueDefined && value < aggregate ?\n          value :\n          aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n          aggregate === undefined || isValueDefined && value > aggregate ?\n          value :\n          aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (xAxisSortSeries === SortSeriesType.Avg &&\n    entries > 0 &&\n    aggregate !== undefined) {\n      aggregate /= entries;\n    }\n    const value = xAxisSortSeries === SortSeriesType.Name ?\n    typeof sortKey === 'string' ?\n    sortKey.toLowerCase() :\n    sortKey :\n    aggregate;\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx]\n    };\n  });\n  return _orderBy(sortedRows, ['value'], [xAxisSortSeriesAscending ? 'asc' : 'desc']).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\nexport function extractSeries(data, opts = {}) {\n  const { fillNeighborValue, xAxis = DTTM_ALIAS, extraMetricLabels = [], removeNulls = false, stack = false, totalStackedValues = [], isHorizontal = false, sortSeriesType, sortSeriesAscending, xAxisSortSeries, xAxisSortSeriesAscending } = opts;\n  if (data.length === 0)\n  return [[], [], undefined];\n  const rows = data.map((datum) => ({\n    ...datum,\n    [xAxis]: datum[xAxis]\n  }));\n  const sortedSeries = sortAndFilterSeries(rows, xAxis, extraMetricLabels, sortSeriesType, sortSeriesAscending);\n  const sortedRows = isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending) ?\n  sortRows(rows, totalStackedValues, xAxis, xAxisSortSeries, xAxisSortSeriesAscending) :\n  rows.map((row, idx) => ({\n    row,\n    totalStackedValue: totalStackedValues[idx]\n  }));\n  let minPositiveValue;\n  const finalSeries = sortedSeries.map((name) => ({\n    id: name,\n    name,\n    data: sortedRows.\n    map(({ row, totalStackedValue }, idx) => {var _rows, _rows2;\n      const currentValue = row[name];\n      if (typeof currentValue === 'number' &&\n      currentValue > 0 && (\n      minPositiveValue === undefined || minPositiveValue > currentValue)) {\n        minPositiveValue = currentValue;\n      }\n      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[name]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[name]);\n      const isFillNeighborValue = !isDefined(currentValue) &&\n      isNextToDefinedValue &&\n      fillNeighborValue !== undefined;\n      let value = currentValue;\n      if (isFillNeighborValue) {\n        value = fillNeighborValue;\n      } else\n      if (stack === StackControlsValue.Expand &&\n      totalStackedValue !== undefined) {\n        value = (value || 0) / totalStackedValue;\n      }\n      return [row[xAxis], value];\n    }).\n    filter((obs) => !removeNulls || obs[0] !== null && obs[1] !== null).\n    map((obs) => isHorizontal ? [obs[1], obs[0]] : obs)\n  }));\n  return [\n  finalSeries,\n  sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n  minPositiveValue];\n\n}\nexport function formatSeriesName(name, { numberFormatter, timeFormatter, coltype } = {}) {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean' || typeof name === 'bigint') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.Temporal) {\n    const normalizedName = typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d = normalizedName instanceof Date ?\n    normalizedName :\n    new Date(normalizedName);\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\nexport const getColtypesMapping = ({ coltypes = [], colnames = [] }) => colnames.reduce((accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }), {});\nexport function extractGroupbyLabel({ datum = {}, groupby, numberFormatter, timeFormatter, coltypeMapping = {} }) {\n  return ensureIsArray(groupby).\n  map((val) => formatSeriesName(datum[val], {\n    numberFormatter,\n    timeFormatter,\n    ...(coltypeMapping[val] && { coltype: coltypeMapping[val] })\n  })).\n  join(', ');\n}\nexport function getLegendProps(type, orientation, show, theme, zoomable = false, legendState, padding) {\n  const legend = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(orientation) ?\n    'horizontal' :\n    'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base\n    }\n  };\n  const MIN_LEGEND_WIDTH = 0;\n  const MARGIN_GUTTER = 45;\n  const getLegendWidth = (paddingWidth) => Math.max(paddingWidth - MARGIN_GUTTER, MIN_LEGEND_WIDTH);\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      if (padding != null && padding.left) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.left)\n        };\n      }\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      if (padding != null && padding.right) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.right)\n        };\n      }\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\nexport function getChartPadding(show, orientation, margin, padding, isHorizontal) {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else\n  if (margin === null ||\n  margin === undefined ||\n  typeof margin === 'string') {\n    legendMargin = defaultLegendPadding[orientation];\n  } else\n  {\n    legendMargin = margin;\n  }\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n  if (isHorizontal) {\n    return {\n      left: left + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n      right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n      top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n      bottom: bottom + (orientation === LegendOrientation.Left ? legendMargin : 0)\n    };\n  }\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom: bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0)\n  };\n}\nexport function dedupSeries(series) {\n  const counter = new Map();\n  return series.map((row) => {\n    let { id } = row;\n    if (id === undefined)\n    return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`\n    };\n  });\n}\nexport function sanitizeHtml(text) {\n  return format.encodeHTML(text);\n}\nexport function getAxisType(stack, forceCategorical, dataType) {\n  if (forceCategorical) {\n    return AxisType.Category;\n  }\n  if (dataType === GenericDataType.Temporal) {\n    return AxisType.Time;\n  }\n  if (dataType === GenericDataType.Numeric && !stack) {\n    return AxisType.Value;\n  }\n  return AxisType.Category;\n}\nexport function getOverMaxHiddenFormatter(config = {}) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n  return new NumberFormatter({\n    formatFunc: (value) => `${shouldHideIfOverMax && value > max ?\n    '' :\n    (formatter == null ? void 0 : formatter.format(value)) || value}`,\n    id: NumberFormats.OVER_MAX_HIDDEN\n  });\n}\nexport function calculateLowerLogTick(minPositiveValue) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\nexport function getMinAndMaxFromBounds(axisType, truncateAxis, min, max, seriesType) {\n  if (axisType === AxisType.Value && truncateAxis) {\n    const ret = {};\n    if (seriesType === EchartsTimeseriesSeriesType.Bar) {\n      ret.scale = true;\n    }\n    if (min !== undefined) {\n      ret.min = min;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.min = 'dataMin';\n    }\n    if (max !== undefined) {\n      ret.max = max;\n    } else\n    if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.max = 'dataMax';\n    }\n    return ret;\n  }\n  return {};\n}\n/**\n * Returns the stackId used in stacked series.\n * It will return the defaultId if the chart is not using time comparison.\n * If time comparison is used, it will return the time comparison value as the stackId\n * if the name includes the time comparison value.\n *\n * @param {string} defaultId The default stackId.\n * @param {string[]} timeCompare The time comparison values.\n * @param {string | number} name The name of the serie.\n *\n * @returns {string} The stackId.\n */\nexport function getTimeCompareStackId(defaultId, timeCompare, name) {\n  if (_isEmpty(timeCompare)) {\n    return defaultId;\n  }\n  // Each timeCompare is its own stack so it doesn't stack on top of original ones\n  return timeCompare.find((value) => {\n    if (typeof name === 'string') {\n      // offset is represented as <offset>, group by list\n      return name.includes(`${value},`) ||\n      // offset is represented as <metric>__<offset>\n      name.includes(`__${value}`);\n    }\n    return name == null ? void 0 : name.toString().includes(value);\n  }) || defaultId;\n}\nconst TOOLTIP_SERIES_KEY = 'seriesId';\nexport function extractTooltipKeys(forecastValue, yIndex, richTooltip, tooltipSortByMetric) {\n  if (richTooltip && tooltipSortByMetric) {\n    return forecastValue.\n    slice().\n    sort((a, b) => b.data[yIndex] - a.data[yIndex]).\n    map((value) => value[TOOLTIP_SERIES_KEY]);\n  }\n  if (richTooltip) {\n    return forecastValue.map((s) => s[TOOLTIP_SERIES_KEY]);\n  }\n  return [forecastValue[0][TOOLTIP_SERIES_KEY]];\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isDefined, \"isDefined\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractDataTotalValues, \"extractDataTotalValues\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractShowValueIndexes, \"extractShowValueIndexes\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortAndFilterSeries, \"sortAndFilterSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sortRows, \"sortRows\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractSeries, \"extractSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(formatSeriesName, \"formatSeriesName\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getColtypesMapping, \"getColtypesMapping\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractGroupbyLabel, \"extractGroupbyLabel\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getLegendProps, \"getLegendProps\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getChartPadding, \"getChartPadding\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(dedupSeries, \"dedupSeries\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(sanitizeHtml, \"sanitizeHtml\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getAxisType, \"getAxisType\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getOverMaxHiddenFormatter, \"getOverMaxHiddenFormatter\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(calculateLowerLogTick, \"calculateLowerLogTick\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getMinAndMaxFromBounds, \"getMinAndMaxFromBounds\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(getTimeCompareStackId, \"getTimeCompareStackId\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(TOOLTIP_SERIES_KEY, \"TOOLTIP_SERIES_KEY\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");reactHotLoader.register(extractTooltipKeys, \"extractTooltipKeys\", \"/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"names":["AxisType","DTTM_ALIAS","ensureIsArray","GenericDataType","normalizeTimestamp","NumberFormats","NumberFormatter","SortSeriesType","format","NULL_STRING","StackControlsValue","TIMESERIES_CONSTANTS","EchartsTimeseriesSeriesType","LegendOrientation","defaultLegendPadding","isDefined","value","undefined","extractDataTotalValues","data","opts","totalStackedValues","thresholdValues","stack","percentageThreshold","xAxisCol","legendState","forEach","datum","values","Object","keys","reduce","prev","curr","push","extractShowValueIndexes","series","showValueIndexes","isHorizontal","onlyTotal","entry","seriesIndex","dataIndex","id","sortAndFilterSeries","rows","xAxis","extraMetricLabels","sortSeriesType","sortSeriesAscending","seriesNames","filter","key","includes","aggregator","Sum","name","_sumBy","Min","_minBy2","_minBy","Max","_maxBy2","_maxBy","Avg","_meanBy","collator","Intl","Collator","numeric","sensitivity","sort","a","b","compare","sortedValues","map","_orderBy","sortRows","xAxisSortSeries","xAxisSortSeriesAscending","sortedRows","row","idx","sortKey","aggregate","entries","isValueDefined","Name","toLowerCase","totalStackedValue","extractSeries","fillNeighborValue","removeNulls","length","sortedSeries","minPositiveValue","finalSeries","_rows","_rows2","currentValue","isNextToDefinedValue","isFillNeighborValue","Expand","obs","formatSeriesName","numberFormatter","timeFormatter","coltype","toString","Date","Temporal","normalizedName","d","toISOString","getColtypesMapping","coltypes","colnames","accumulator","item","index","extractGroupbyLabel","groupby","coltypeMapping","val","join","getLegendProps","type","orientation","show","theme","zoomable","padding","legend","orient","Top","Bottom","selected","selector","selectorLabel","fontFamily","typography","families","sansSerif","fontSize","sizes","s","color","colors","grayscale","base","borderColor","MIN_LEGEND_WIDTH","MARGIN_GUTTER","getLegendWidth","paddingWidth","Math","max","Left","left","textStyle","overflow","width","Right","right","top","legendRightTopOffset","bottom","legendTopRightOffset","getChartPadding","margin","legendMargin","dedupSeries","counter","Map","String","count","get","suffix","set","sanitizeHtml","text","encodeHTML","getAxisType","forceCategorical","dataType","Category","Time","Numeric","Value","getOverMaxHiddenFormatter","config","formatter","shouldHideIfOverMax","formatFunc","OVER_MAX_HIDDEN","calculateLowerLogTick","logBase10","floor","log10","pow","getMinAndMaxFromBounds","axisType","truncateAxis","min","seriesType","ret","Bar","scale","getTimeCompareStackId","defaultId","timeCompare","_isEmpty","find","TOOLTIP_SERIES_KEY","extractTooltipKeys","forecastValue","yIndex","richTooltip","tooltipSortByMetric","slice","reactHotLoader","reactHotLoaderGlobal","default","register","leaveModule","module"],"sources":["/Users/aryurkov/superset/superset-frontend/plugins/plugin-chart-echarts/src/utils/series.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  AxisType,\n  ChartDataResponseResult,\n  DataRecord,\n  DataRecordValue,\n  DTTM_ALIAS,\n  ensureIsArray,\n  GenericDataType,\n  LegendState,\n  normalizeTimestamp,\n  NumberFormats,\n  NumberFormatter,\n  SupersetTheme,\n  TimeFormatter,\n  ValueFormatter,\n} from '@superset-ui/core';\nimport { SortSeriesType, LegendPaddingType } from '@superset-ui/chart-controls';\nimport { format } from 'echarts/core';\nimport type { LegendComponentOption } from 'echarts/components';\nimport type { SeriesOption } from 'echarts';\nimport { isEmpty, maxBy, meanBy, minBy, orderBy, sumBy } from 'lodash';\nimport {\n  NULL_STRING,\n  StackControlsValue,\n  TIMESERIES_CONSTANTS,\n} from '../constants';\nimport {\n  EchartsTimeseriesSeriesType,\n  LegendOrientation,\n  LegendType,\n  StackType,\n} from '../types';\nimport { defaultLegendPadding } from '../defaults';\n\nfunction isDefined<T>(value: T | undefined | null): boolean {\n  return value !== undefined && value !== null;\n}\n\nexport function extractDataTotalValues(\n  data: DataRecord[],\n  opts: {\n    stack: StackType;\n    percentageThreshold: number;\n    xAxisCol: string;\n    legendState?: LegendState;\n  },\n): {\n  totalStackedValues: number[];\n  thresholdValues: number[];\n} {\n  const totalStackedValues: number[] = [];\n  const thresholdValues: number[] = [];\n  const { stack, percentageThreshold, xAxisCol, legendState } = opts;\n  if (stack) {\n    data.forEach(datum => {\n      const values = Object.keys(datum).reduce((prev, curr) => {\n        if (curr === xAxisCol) {\n          return prev;\n        }\n        if (legendState && !legendState[curr]) {\n          return prev;\n        }\n        const value = datum[curr] || 0;\n        return prev + (value as number);\n      }, 0);\n      totalStackedValues.push(values);\n      thresholdValues.push(((percentageThreshold || 0) / 100) * values);\n    });\n  }\n  return {\n    totalStackedValues,\n    thresholdValues,\n  };\n}\n\nexport function extractShowValueIndexes(\n  series: SeriesOption[],\n  opts: {\n    stack: StackType;\n    onlyTotal?: boolean;\n    isHorizontal?: boolean;\n    legendState?: LegendState;\n  },\n): number[] {\n  const showValueIndexes: number[] = [];\n  const { legendState, stack, isHorizontal, onlyTotal } = opts;\n  if (stack) {\n    series.forEach((entry, seriesIndex) => {\n      const { data = [] } = entry;\n      (data as [any, number][]).forEach((datum, dataIndex) => {\n        if (entry.id && legendState && !legendState[entry.id]) {\n          return;\n        }\n        if (!onlyTotal && datum[isHorizontal ? 0 : 1] !== null) {\n          showValueIndexes[dataIndex] = seriesIndex;\n        }\n        if (onlyTotal) {\n          if (datum[isHorizontal ? 0 : 1] > 0) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n          if (\n            !showValueIndexes[dataIndex] &&\n            datum[isHorizontal ? 0 : 1] !== null\n          ) {\n            showValueIndexes[dataIndex] = seriesIndex;\n          }\n        }\n      });\n    });\n  }\n  return showValueIndexes;\n}\n\nexport function sortAndFilterSeries(\n  rows: DataRecord[],\n  xAxis: string,\n  extraMetricLabels: any[],\n  sortSeriesType?: SortSeriesType,\n  sortSeriesAscending?: boolean,\n): string[] {\n  const seriesNames = Object.keys(rows[0])\n    .filter(key => key !== xAxis)\n    .filter(key => !extraMetricLabels.includes(key));\n\n  let aggregator: (name: string) => { name: string; value: any };\n\n  switch (sortSeriesType) {\n    case SortSeriesType.Sum:\n      aggregator = name => ({ name, value: sumBy(rows, name) });\n      break;\n    case SortSeriesType.Min:\n      aggregator = name => ({ name, value: minBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Max:\n      aggregator = name => ({ name, value: maxBy(rows, name)?.[name] });\n      break;\n    case SortSeriesType.Avg:\n      aggregator = name => ({ name, value: meanBy(rows, name) });\n      break;\n    default: {\n      const collator = new Intl.Collator(undefined, {\n        numeric: true,\n        sensitivity: 'base',\n      });\n      return seriesNames.sort((a, b) =>\n        sortSeriesAscending ? collator.compare(a, b) : collator.compare(b, a),\n      );\n    }\n  }\n\n  const sortedValues = seriesNames.map(aggregator);\n\n  return orderBy(\n    sortedValues,\n    ['value'],\n    [sortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ name }) => name);\n}\n\nexport function sortRows(\n  rows: DataRecord[],\n  totalStackedValues: number[],\n  xAxis: string,\n  xAxisSortSeries: SortSeriesType,\n  xAxisSortSeriesAscending: boolean,\n) {\n  const sortedRows = rows.map((row, idx) => {\n    let sortKey: DataRecordValue = '';\n    let aggregate: number | undefined;\n    let entries = 0;\n    Object.entries(row).forEach(([key, value]) => {\n      const isValueDefined = isDefined(value);\n      if (key === xAxis) {\n        sortKey = value;\n      }\n      if (\n        xAxisSortSeries === SortSeriesType.Name ||\n        typeof value !== 'number'\n      ) {\n        return;\n      }\n\n      if (!(xAxisSortSeries === SortSeriesType.Avg && !isValueDefined)) {\n        entries += 1;\n      }\n\n      switch (xAxisSortSeries) {\n        case SortSeriesType.Avg:\n        case SortSeriesType.Sum:\n          if (aggregate === undefined) {\n            aggregate = value;\n          } else {\n            aggregate += value;\n          }\n          break;\n        case SortSeriesType.Min:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value < aggregate)\n              ? value\n              : aggregate;\n          break;\n        case SortSeriesType.Max:\n          aggregate =\n            aggregate === undefined || (isValueDefined && value > aggregate)\n              ? value\n              : aggregate;\n          break;\n        default:\n          break;\n      }\n    });\n    if (\n      xAxisSortSeries === SortSeriesType.Avg &&\n      entries > 0 &&\n      aggregate !== undefined\n    ) {\n      aggregate /= entries;\n    }\n\n    const value =\n      xAxisSortSeries === SortSeriesType.Name\n        ? typeof sortKey === 'string'\n          ? sortKey.toLowerCase()\n          : sortKey\n        : aggregate;\n\n    return {\n      key: sortKey,\n      value,\n      row,\n      totalStackedValue: totalStackedValues[idx],\n    };\n  });\n\n  return orderBy(\n    sortedRows,\n    ['value'],\n    [xAxisSortSeriesAscending ? 'asc' : 'desc'],\n  ).map(({ row, totalStackedValue }) => ({ row, totalStackedValue }));\n}\n\nexport function extractSeries(\n  data: DataRecord[],\n  opts: {\n    fillNeighborValue?: number;\n    xAxis?: string;\n    extraMetricLabels?: string[];\n    removeNulls?: boolean;\n    stack?: StackType;\n    totalStackedValues?: number[];\n    isHorizontal?: boolean;\n    sortSeriesType?: SortSeriesType;\n    sortSeriesAscending?: boolean;\n    xAxisSortSeries?: SortSeriesType;\n    xAxisSortSeriesAscending?: boolean;\n  } = {},\n): [SeriesOption[], number[], number | undefined] {\n  const {\n    fillNeighborValue,\n    xAxis = DTTM_ALIAS,\n    extraMetricLabels = [],\n    removeNulls = false,\n    stack = false,\n    totalStackedValues = [],\n    isHorizontal = false,\n    sortSeriesType,\n    sortSeriesAscending,\n    xAxisSortSeries,\n    xAxisSortSeriesAscending,\n  } = opts;\n  if (data.length === 0) return [[], [], undefined];\n  const rows: DataRecord[] = data.map(datum => ({\n    ...datum,\n    [xAxis]: datum[xAxis],\n  }));\n  const sortedSeries = sortAndFilterSeries(\n    rows,\n    xAxis,\n    extraMetricLabels,\n    sortSeriesType,\n    sortSeriesAscending,\n  );\n  const sortedRows =\n    isDefined(xAxisSortSeries) && isDefined(xAxisSortSeriesAscending)\n      ? sortRows(\n          rows,\n          totalStackedValues,\n          xAxis,\n          xAxisSortSeries!,\n          xAxisSortSeriesAscending!,\n        )\n      : rows.map((row, idx) => ({\n          row,\n          totalStackedValue: totalStackedValues[idx],\n        }));\n\n  let minPositiveValue: number | undefined;\n  const finalSeries = sortedSeries.map(name => ({\n    id: name,\n    name,\n    data: sortedRows\n      .map(({ row, totalStackedValue }, idx) => {\n        const currentValue = row[name];\n        if (\n          typeof currentValue === 'number' &&\n          currentValue > 0 &&\n          (minPositiveValue === undefined || minPositiveValue > currentValue)\n        ) {\n          minPositiveValue = currentValue;\n        }\n        const isNextToDefinedValue =\n          isDefined(rows[idx - 1]?.[name]) || isDefined(rows[idx + 1]?.[name]);\n        const isFillNeighborValue =\n          !isDefined(currentValue) &&\n          isNextToDefinedValue &&\n          fillNeighborValue !== undefined;\n        let value: DataRecordValue | undefined = currentValue;\n        if (isFillNeighborValue) {\n          value = fillNeighborValue;\n        } else if (\n          stack === StackControlsValue.Expand &&\n          totalStackedValue !== undefined\n        ) {\n          value = ((value || 0) as number) / totalStackedValue;\n        }\n        return [row[xAxis], value];\n      })\n      .filter(obs => !removeNulls || (obs[0] !== null && obs[1] !== null))\n      .map(obs => (isHorizontal ? [obs[1], obs[0]] : obs)),\n  }));\n  return [\n    finalSeries,\n    sortedRows.map(({ totalStackedValue }) => totalStackedValue),\n    minPositiveValue,\n  ];\n}\n\nexport function formatSeriesName(\n  name: DataRecordValue | undefined,\n  {\n    numberFormatter,\n    timeFormatter,\n    coltype,\n  }: {\n    numberFormatter?: ValueFormatter;\n    timeFormatter?: TimeFormatter;\n    coltype?: GenericDataType;\n  } = {},\n): string {\n  if (name === undefined || name === null) {\n    return NULL_STRING;\n  }\n  if (typeof name === 'boolean' || typeof name === 'bigint') {\n    return name.toString();\n  }\n  if (name instanceof Date || coltype === GenericDataType.Temporal) {\n    const normalizedName =\n      typeof name === 'string' ? normalizeTimestamp(name) : name;\n    const d =\n      normalizedName instanceof Date\n        ? normalizedName\n        : new Date(normalizedName);\n\n    return timeFormatter ? timeFormatter(d) : d.toISOString();\n  }\n  if (typeof name === 'number') {\n    return numberFormatter ? numberFormatter(name) : name.toString();\n  }\n  return name;\n}\n\nexport const getColtypesMapping = ({\n  coltypes = [],\n  colnames = [],\n}: Pick<ChartDataResponseResult, 'coltypes' | 'colnames'>): Record<\n  string,\n  GenericDataType\n> =>\n  colnames.reduce(\n    (accumulator, item, index) => ({ ...accumulator, [item]: coltypes[index] }),\n    {},\n  );\n\nexport function extractGroupbyLabel({\n  datum = {},\n  groupby,\n  numberFormatter,\n  timeFormatter,\n  coltypeMapping = {},\n}: {\n  datum?: DataRecord;\n  groupby?: string[] | null;\n  numberFormatter?: NumberFormatter;\n  timeFormatter?: TimeFormatter;\n  coltypeMapping?: Record<string, GenericDataType>;\n}): string {\n  return ensureIsArray(groupby)\n    .map(val =>\n      formatSeriesName(datum[val], {\n        numberFormatter,\n        timeFormatter,\n        ...(coltypeMapping[val] && { coltype: coltypeMapping[val] }),\n      }),\n    )\n    .join(', ');\n}\n\nexport function getLegendProps(\n  type: LegendType,\n  orientation: LegendOrientation,\n  show: boolean,\n  theme: SupersetTheme,\n  zoomable = false,\n  legendState?: LegendState,\n  padding?: LegendPaddingType,\n): LegendComponentOption | LegendComponentOption[] {\n  const legend: LegendComponentOption | LegendComponentOption[] = {\n    orient: [LegendOrientation.Top, LegendOrientation.Bottom].includes(\n      orientation,\n    )\n      ? 'horizontal'\n      : 'vertical',\n    show,\n    type,\n    selected: legendState,\n    selector: ['all', 'inverse'],\n    selectorLabel: {\n      fontFamily: theme.typography.families.sansSerif,\n      fontSize: theme.typography.sizes.s,\n      color: theme.colors.grayscale.base,\n      borderColor: theme.colors.grayscale.base,\n    },\n  };\n  const MIN_LEGEND_WIDTH = 0;\n  const MARGIN_GUTTER = 45;\n  const getLegendWidth = (paddingWidth: number) =>\n    Math.max(paddingWidth - MARGIN_GUTTER, MIN_LEGEND_WIDTH);\n\n  switch (orientation) {\n    case LegendOrientation.Left:\n      legend.left = 0;\n      if (padding?.left) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.left),\n        };\n      }\n      break;\n    case LegendOrientation.Right:\n      legend.right = 0;\n      legend.top = zoomable ? TIMESERIES_CONSTANTS.legendRightTopOffset : 0;\n      if (padding?.right) {\n        legend.textStyle = {\n          overflow: 'truncate',\n          width: getLegendWidth(padding.right),\n        };\n      }\n      break;\n    case LegendOrientation.Bottom:\n      legend.bottom = 0;\n      break;\n    case LegendOrientation.Top:\n    default:\n      legend.top = 0;\n      legend.right = zoomable ? TIMESERIES_CONSTANTS.legendTopRightOffset : 0;\n      break;\n  }\n  return legend;\n}\n\nexport function getChartPadding(\n  show: boolean,\n  orientation: LegendOrientation,\n  margin?: string | number | null,\n  padding?: LegendPaddingType,\n  isHorizontal?: boolean,\n): {\n  bottom: number;\n  left: number;\n  right: number;\n  top: number;\n} {\n  let legendMargin;\n  if (!show) {\n    legendMargin = 0;\n  } else if (\n    margin === null ||\n    margin === undefined ||\n    typeof margin === 'string'\n  ) {\n    legendMargin = defaultLegendPadding[orientation];\n  } else {\n    legendMargin = margin;\n  }\n\n  const { bottom = 0, left = 0, right = 0, top = 0 } = padding || {};\n\n  if (isHorizontal) {\n    return {\n      left:\n        left + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n      right:\n        right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n      top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n      bottom:\n        bottom + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    };\n  }\n\n  return {\n    left: left + (orientation === LegendOrientation.Left ? legendMargin : 0),\n    right: right + (orientation === LegendOrientation.Right ? legendMargin : 0),\n    top: top + (orientation === LegendOrientation.Top ? legendMargin : 0),\n    bottom:\n      bottom + (orientation === LegendOrientation.Bottom ? legendMargin : 0),\n  };\n}\n\nexport function dedupSeries(series: SeriesOption[]): SeriesOption[] {\n  const counter = new Map<string, number>();\n  return series.map(row => {\n    let { id } = row;\n    if (id === undefined) return row;\n    id = String(id);\n    const count = counter.get(id) || 0;\n    const suffix = count > 0 ? ` (${count})` : '';\n    counter.set(id, count + 1);\n    return {\n      ...row,\n      id: `${id}${suffix}`,\n    };\n  });\n}\n\nexport function sanitizeHtml(text: string): string {\n  return format.encodeHTML(text);\n}\n\nexport function getAxisType(\n  stack: StackType,\n  forceCategorical?: boolean,\n  dataType?: GenericDataType,\n): AxisType {\n  if (forceCategorical) {\n    return AxisType.Category;\n  }\n  if (dataType === GenericDataType.Temporal) {\n    return AxisType.Time;\n  }\n  if (dataType === GenericDataType.Numeric && !stack) {\n    return AxisType.Value;\n  }\n  return AxisType.Category;\n}\n\nexport function getOverMaxHiddenFormatter(\n  config: {\n    max?: number;\n    formatter?: ValueFormatter;\n  } = {},\n) {\n  const { max, formatter } = config;\n  // Only apply this logic if there's a MAX set in the controls\n  const shouldHideIfOverMax = !!max || max === 0;\n\n  return new NumberFormatter({\n    formatFunc: value =>\n      `${\n        shouldHideIfOverMax && value > max\n          ? ''\n          : formatter?.format(value) || value\n      }`,\n    id: NumberFormats.OVER_MAX_HIDDEN,\n  });\n}\n\nexport function calculateLowerLogTick(minPositiveValue: number) {\n  const logBase10 = Math.floor(Math.log10(minPositiveValue));\n  return Math.pow(10, logBase10);\n}\n\ntype BoundsType = {\n  min?: number | 'dataMin';\n  max?: number | 'dataMax';\n  scale?: true;\n};\n\nexport function getMinAndMaxFromBounds(\n  axisType: AxisType,\n  truncateAxis: boolean,\n  min?: number,\n  max?: number,\n  seriesType?: EchartsTimeseriesSeriesType,\n): BoundsType | {} {\n  if (axisType === AxisType.Value && truncateAxis) {\n    const ret: BoundsType = {};\n    if (seriesType === EchartsTimeseriesSeriesType.Bar) {\n      ret.scale = true;\n    }\n    if (min !== undefined) {\n      ret.min = min;\n    } else if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.min = 'dataMin';\n    }\n    if (max !== undefined) {\n      ret.max = max;\n    } else if (seriesType !== EchartsTimeseriesSeriesType.Bar) {\n      ret.max = 'dataMax';\n    }\n    return ret;\n  }\n  return {};\n}\n\n/**\n * Returns the stackId used in stacked series.\n * It will return the defaultId if the chart is not using time comparison.\n * If time comparison is used, it will return the time comparison value as the stackId\n * if the name includes the time comparison value.\n *\n * @param {string} defaultId The default stackId.\n * @param {string[]} timeCompare The time comparison values.\n * @param {string | number} name The name of the serie.\n *\n * @returns {string} The stackId.\n */\nexport function getTimeCompareStackId(\n  defaultId: string,\n  timeCompare: string[],\n  name?: string | number,\n): string {\n  if (isEmpty(timeCompare)) {\n    return defaultId;\n  }\n  // Each timeCompare is its own stack so it doesn't stack on top of original ones\n  return (\n    timeCompare.find(value => {\n      if (typeof name === 'string') {\n        // offset is represented as <offset>, group by list\n        return (\n          name.includes(`${value},`) ||\n          // offset is represented as <metric>__<offset>\n          name.includes(`__${value}`)\n        );\n      }\n      return name?.toString().includes(value);\n    }) || defaultId\n  );\n}\n\nconst TOOLTIP_SERIES_KEY = 'seriesId';\nexport function extractTooltipKeys(\n  forecastValue: any[],\n  yIndex: number,\n  richTooltip?: boolean,\n  tooltipSortByMetric?: boolean,\n): string[] {\n  if (richTooltip && tooltipSortByMetric) {\n    return forecastValue\n      .slice()\n      .sort((a, b) => b.data[yIndex] - a.data[yIndex])\n      .map(value => value[TOOLTIP_SERIES_KEY]);\n  }\n  if (richTooltip) {\n    return forecastValue.map(s => s[TOOLTIP_SERIES_KEY]);\n  }\n  return [forecastValue[0][TOOLTIP_SERIES_KEY]];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}